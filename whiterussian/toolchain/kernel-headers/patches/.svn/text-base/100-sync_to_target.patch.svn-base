diff -urN linux-2.4.30.old/arch/mips/config-shared.in linux-2.4.30.dev/arch/mips/config-shared.in
--- linux-2.4.30.old/arch/mips/config-shared.in	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30.dev/arch/mips/config-shared.in	2008-05-11 02:17:54.000000000 +0200
@@ -21,16 +21,19 @@
 comment 'Machine selection'
 dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
 dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
+dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1000 board' CONFIG_MIPS_DB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1100 board' CONFIG_MIPS_DB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1500 board' CONFIG_MIPS_DB1500 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1550 board' CONFIG_MIPS_DB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1200 board' CONFIG_MIPS_DB1200 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1000 board' CONFIG_MIPS_PB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1100 board' CONFIG_MIPS_PB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
-dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1550 board' CONFIG_MIPS_PB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1200 board' CONFIG_MIPS_PB1200 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
 dep_bool 'Support for MyCable XXS1500 board' CONFIG_MIPS_XXS1500 $CONFIG_MIPS32
 dep_bool 'Support for 4G Systems MTX-1 board' CONFIG_MIPS_MTX1 $CONFIG_MIPS32
 dep_bool 'Support for Cogent CSB250 board' CONFIG_COGENT_CSB250 $CONFIG_MIPS32
@@ -205,6 +208,14 @@
    fi
    define_bool CONFIG_MIPS_RTC y
 fi
+dep_bool 'Support for Broadcom MIPS-based boards' CONFIG_MIPS_BRCM $CONFIG_EXPERIMENTAL
+dep_bool 'Support for Broadcom BCM947XX' CONFIG_BCM947XX $CONFIG_MIPS_BRCM
+if [ "$CONFIG_BCM947XX" = "y" ] ; then
+   bool '    Support for Broadcom BCM4710' CONFIG_BCM4710
+   bool '    Support for Broadcom BCM4310' CONFIG_BCM4310
+   bool '    Support for Broadcom BCM4704' CONFIG_BCM4704
+   bool '    Support for Broadcom BCM5365' CONFIG_BCM5365
+fi
 bool 'Support for SNI RM200 PCI' CONFIG_SNI_RM200_PCI
 bool 'Support for TANBAC TB0226 (Mbase)' CONFIG_TANBAC_TB0226
 bool 'Support for TANBAC TB0229 (VR4131DIMM)' CONFIG_TANBAC_TB0229
@@ -226,6 +237,11 @@
 define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM n
 
 #
+# Provide an option for a default kernel command line
+#
+string 'Default kernel command string' CONFIG_CMDLINE ""
+
+#
 # Select some configuration options automatically based on user selections.
 #
 if [ "$CONFIG_ACER_PICA_61" = "y" ]; then
@@ -249,6 +265,12 @@
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
+if [ "$CONFIG_MIPS_FICMMP" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_MIPS_BOSPORUS" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
@@ -263,6 +285,12 @@
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
+if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_MIPS_PB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
@@ -271,9 +299,15 @@
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
-if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
+if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_SOC_AU1550 y
+   define_bool CONFIG_NONCOHERENT_IO n
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_PB1200" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
@@ -290,18 +324,24 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
 if [ "$CONFIG_MIPS_DB1550" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1550 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
-if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
+if [ "$CONFIG_MIPS_DB1200" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_SOC_AU1200 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_SWAP_IO_SPACE y
 fi
 if [ "$CONFIG_MIPS_HYDROGEN3" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
@@ -327,12 +367,6 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
-if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
-   define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1550 y
-   define_bool CONFIG_NONCOHERENT_IO n
-   define_bool CONFIG_PC_KEYB y
-fi
 if [ "$CONFIG_MIPS_COBALT" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
    define_bool CONFIG_COBALT_LCD y
@@ -533,6 +567,13 @@
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_BOOT_ELF32 y
 fi
+if [ "$CONFIG_BCM947XX" = "y" ] ; then
+   define_bool CONFIG_PCI y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_NEW_IRQ y
+   define_bool CONFIG_HND y
+fi
 if [ "$CONFIG_SNI_RM200_PCI" = "y" ]; then
    define_bool CONFIG_ARC32 y
    define_bool CONFIG_ARC_MEMORY y
@@ -729,6 +770,13 @@
      "$CONFIG_MIPS_PB1000" = "y" -o \
      "$CONFIG_MIPS_PB1100" = "y" -o \
      "$CONFIG_MIPS_PB1500" = "y" -o \
+     "$CONFIG_MIPS_PB1550" = "y" -o \
+     "$CONFIG_MIPS_PB1200" = "y" -o \
+     "$CONFIG_MIPS_DB1000" = "y" -o \
+     "$CONFIG_MIPS_DB1100" = "y" -o \
+     "$CONFIG_MIPS_DB1500" = "y" -o \
+     "$CONFIG_MIPS_DB1550" = "y" -o \
+     "$CONFIG_MIPS_DB1200" = "y" -o \
      "$CONFIG_NEC_OSPREY" = "y" -o \
      "$CONFIG_NEC_EAGLE" = "y" -o \
      "$CONFIG_NINO" = "y" -o \
@@ -845,6 +893,9 @@
 define_bool CONFIG_KCORE_AOUT n
 define_bool CONFIG_BINFMT_AOUT n
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 dep_bool 'Kernel support for Linux/MIPS 32-bit binary compatibility' CONFIG_MIPS32_COMPAT $CONFIG_MIPS64
 dep_bool 'Kernel support for o32 binaries' CONFIG_MIPS32_O32 $CONFIG_MIPS32_COMPAT
 dep_bool 'Kernel support for n32 binaries' CONFIG_MIPS32_N32 $CONFIG_MIPS32_COMPAT
@@ -1011,7 +1062,11 @@
 
 bool 'Are you using a crosscompiler' CONFIG_CROSSCOMPILE
 bool 'Enable run-time debugging' CONFIG_RUNTIME_DEBUG
-bool 'Remote GDB kernel debugging' CONFIG_KGDB
+if [ "$CONFIG_BCM947XX" = "y" ] ; then
+	bool 'Remote GDB kernel debugging' CONFIG_REMOTE_DEBUG
+else 
+	bool 'Remote GDB kernel debugging' CONFIG_KGDB
+fi
 dep_bool '  Console output to GDB' CONFIG_GDB_CONSOLE $CONFIG_KGDB
 if [ "$CONFIG_KGDB" = "y" ]; then
    define_bool CONFIG_DEBUG_INFO y
diff -urN linux-2.4.30.old/arch/mips/Makefile linux-2.4.30.dev/arch/mips/Makefile
--- linux-2.4.30.old/arch/mips/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30.dev/arch/mips/Makefile	2008-05-11 02:17:54.000000000 +0200
@@ -30,8 +30,6 @@
 
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
 
-check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
-
 #
 #
 # GCC uses -G 0 -mabicalls -fpic as default.  We don't want PIC in the kernel
@@ -46,10 +44,10 @@
 GCCFLAGS	:= -I $(TOPDIR)/include/asm/gcc
 GCCFLAGS	+= -G 0 -mno-abicalls -fno-pic -pipe
 GCCFLAGS	+= $(call check_gcc, -finline-limit=100000,)
-LINKFLAGS	+= -G 0 -static -n
-MODFLAGS	+= -mlong-calls
+LINKFLAGS	+= -G 0 -static -n -nostdlib
+MODFLAGS	+= -mlong-calls -fno-common
 
-ifdef CONFIG_DEBUG_INFO
+ifdef CONFIG_REMOTE_DEBUG
 GCCFLAGS	+= -g
 ifdef CONFIG_SB1XXX_CORELIS
 GCCFLAGS	+= -mno-sched-prolog -fno-omit-frame-pointer
@@ -71,13 +69,13 @@
 set_gccflags = $(shell \
 while :; do \
 	cpu=$(1); isa=-$(2); \
-	for gcc_opt in -march= -mcpu=; do \
+	for gcc_opt in -march= -mtune=; do \
 		$(CC) $$gcc_opt$$cpu $$isa -S -o /dev/null \
 			-xc /dev/null > /dev/null 2>&1 && \
 			break 2; \
 	done; \
 	cpu=$(3); isa=-$(4); \
-	for gcc_opt in -march= -mcpu=; do \
+	for gcc_opt in -march= -mtune=; do \
 		$(CC) $$gcc_opt$$cpu $$isa -S -o /dev/null \
 			-xc /dev/null > /dev/null 2>&1 && \
 			break 2; \
@@ -92,7 +90,7 @@
 fi; \
 gas_abi=-Wa,-32; gas_cpu=$$cpu; gas_isa=-Wa,$$isa; \
 while :; do \
-	for gas_opt in -Wa,-march= -Wa,-mcpu=; do \
+	for gas_opt in -Wa,-march= -Wa,-mtune=; do \
 		$(CC) $$gas_abi $$gas_opt$$cpu $$gas_isa -Wa,-Z -c \
 			-o /dev/null -xassembler /dev/null > /dev/null 2>&1 && \
 			break 2; \
@@ -174,6 +172,7 @@
 endif
 
 AFLAGS		+= $(GCCFLAGS)
+ASFLAGS		+= $(GCCFLAGS)
 CFLAGS		+= $(GCCFLAGS)
 
 LD		+= -m $(ld-emul)
@@ -211,7 +210,7 @@
 endif
 
 #
-# Au1000 (Alchemy Semi PB1000) eval board
+# Au1x AMD Alchemy eval boards
 #
 ifdef CONFIG_MIPS_PB1000
 LIBS		+= arch/mips/au1000/pb1000/pb1000.o \
@@ -220,9 +219,6 @@
 LOADADDR	:= 0x80100000
 endif
 
-#
-# Au1100 (Alchemy Semi PB1100) eval board
-#
 ifdef CONFIG_MIPS_PB1100
 LIBS          += arch/mips/au1000/pb1100/pb1100.o \
                  arch/mips/au1000/common/au1000.o
@@ -230,9 +226,6 @@
 LOADADDR      += 0x80100000
 endif
 
-#
-# Au1500 (Alchemy Semi PB1500) eval board
-#
 ifdef CONFIG_MIPS_PB1500
 LIBS		+= arch/mips/au1000/pb1500/pb1500.o \
 		   arch/mips/au1000/common/au1000.o
@@ -240,9 +233,6 @@
 LOADADDR	:= 0x80100000
 endif
 
-#
-# Au1x00 (AMD/Alchemy) eval boards
-#
 ifdef CONFIG_MIPS_DB1000
 LIBS          += arch/mips/au1000/db1x00/db1x00.o \
                  arch/mips/au1000/common/au1000.o
@@ -313,6 +303,27 @@
 LOADADDR      += 0x80100000
 endif
 
+ifdef CONFIG_MIPS_PB1200
+LIBS          += arch/mips/au1000/pb1200/pb1200.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/pb1200 arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
+ifdef CONFIG_MIPS_DB1200
+LIBS          += arch/mips/au1000/pb1200/pb1200.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/pb1200 arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
+ifdef CONFIG_MIPS_FICMMP
+LIBS          += arch/mips/au1000/ficmmp/ficmmp.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/ficmmp arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
 
 #
 # Cogent CSB250
@@ -715,6 +726,19 @@
 endif
 
 #
+# Broadcom BCM947XX variants
+#
+ifdef CONFIG_BCM947XX
+LIBS		+= arch/mips/bcm947xx/generic/brcm.o arch/mips/bcm947xx/bcm947xx.o 
+SUBDIRS		+= arch/mips/bcm947xx/generic arch/mips/bcm947xx 
+LOADADDR	:= 0x80001000
+
+zImage: vmlinux
+	$(MAKE) -C arch/$(ARCH)/bcm947xx/compressed
+export LOADADDR
+endif
+
+#
 # Choosing incompatible machines durings configuration will result in
 # error messages during linking.  Select a default linkscript if
 # none has been choosen above.
@@ -767,6 +791,7 @@
 	$(MAKE) -C arch/$(ARCH)/tools clean
 	$(MAKE) -C arch/mips/baget clean
 	$(MAKE) -C arch/mips/lasat clean
+	$(MAKE) -C arch/mips/bcm947xx/compressed clean
 
 archmrproper:
 	@$(MAKEBOOT) mrproper
diff -urN linux-2.4.30.old/crypto/Config.in linux-2.4.30.dev/crypto/Config.in
--- linux-2.4.30.old/crypto/Config.in	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.30.dev/crypto/Config.in	2008-05-11 02:17:51.000000000 +0200
@@ -11,7 +11,9 @@
      "$CONFIG_INET6_AH" = "y" -o \
      "$CONFIG_INET6_AH" = "m" -o \
      "$CONFIG_INET6_ESP" = "y" -o \
-     "$CONFIG_INET6_ESP" = "m" ]; then
+     "$CONFIG_INET6_ESP" = "m" -o \
+     "$CONFIG_PPP_MPPE_MPPC" = "y" -o \
+     "$CONFIG_PPP_MPPE_MPPC" = "m" ]; then
   define_bool CONFIG_CRYPTO y
 else
   bool 'Cryptographic API' CONFIG_CRYPTO
@@ -51,11 +53,24 @@
        "$CONFIG_INET6_AH" = "y" -o \
        "$CONFIG_INET6_AH" = "m" -o \
        "$CONFIG_INET6_ESP" = "y" -o \
-       "$CONFIG_INET6_ESP" = "m" ]; then
-    define_bool CONFIG_CRYPTO_SHA1 y
-  else
-    tristate       '  SHA1 digest algorithm' CONFIG_CRYPTO_SHA1
+       "$CONFIG_INET6_ESP" = "m" -o \
+       "$CONFIG_PPP_MPPE_MPPC" = "y" -o \
+       "$CONFIG_PPP_MPPE_MPPC" = "m" ]; then
+    if [ "$CONFIG_INET_AH" = "y" -o \
+	 "$CONFIG_INET_ESP" = "y" -o \
+	 "$CONFIG_INET6_AH" = "y" -o \
+	 "$CONFIG_INET6_ESP" = "y" -o \
+	 "$CONFIG_PPP_MPPE_MPPC" = "y" ]; then
+      define_tristate CONFIG_CRYPTO_SHA1 y
+    else
+      if [ "$CONFIG_CRYPTO_SHA1" != "y" -a \
+	   "$CONFIG_CRYPTO_SHA1" != "m" ]; then
+	define_tristate CONFIG_CRYPTO_SHA1 m
+      fi
+    fi
   fi
+  tristate       '  SHA1 digest algorithm' CONFIG_CRYPTO_SHA1
+
   tristate       '  SHA256 digest algorithm' CONFIG_CRYPTO_SHA256
   tristate       '  SHA384 and SHA512 digest algorithms' CONFIG_CRYPTO_SHA512
   tristate       '  Whirlpool digest algorithms' CONFIG_CRYPTO_WP512
@@ -76,7 +91,20 @@
   tristate       '  TEA and XTEA cipher algorithms' CONFIG_CRYPTO_TEA
   tristate       '  Khazad cipher algorithm' CONFIG_CRYPTO_KHAZAD
   tristate       '  Anubis cipher algorithm' CONFIG_CRYPTO_ANUBIS
+
+  if [ "$CONFIG_PPP_MPPE_MPPC" = "y" -o \
+       "$CONFIG_PPP_MPPE_MPPC" = "m" ]; then
+    if [ "$CONFIG_PPP_MPPE_MPPC" = "y" ]; then
+      define_tristate CONFIG_CRYPTO_ARC4 y
+    else
+      if [ "$CONFIG_CRYPTO_ARC4" != "y" -a \
+	   "$CONFIG_CRYPTO_ARC4" != "m" ]; then
+	define_tristate CONFIG_CRYPTO_ARC4 m
+      fi
+    fi
+  fi
   tristate       '  ARC4 cipher algorithm' CONFIG_CRYPTO_ARC4
+
   if [ "$CONFIG_INET_IPCOMP" = "y" -o \
        "$CONFIG_INET_IPCOMP" = "m" -o \
        "$CONFIG_INET6_IPCOMP" = "y" -o \
diff -urN linux-2.4.30.old/drivers/char/Config.in linux-2.4.30.dev/drivers/char/Config.in
--- linux-2.4.30.old/drivers/char/Config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.30.dev/drivers/char/Config.in	2008-05-11 02:17:53.000000000 +0200
@@ -263,6 +263,7 @@
    tristate '  W83877F (EMACS) Watchdog Timer' CONFIG_W83877F_WDT
    tristate '  WDT Watchdog timer' CONFIG_WDT
    tristate '  WDT PCI Watchdog timer' CONFIG_WDTPCI
+   tristate '  W83627HF/F/HG/G Watchdog' CONFIG_WDT_W83627
    if [ "$CONFIG_WDT" != "n" ]; then
       bool '    WDT501 features' CONFIG_WDT_501
       if [ "$CONFIG_WDT_501" = "y" ]; then
@@ -313,14 +314,11 @@
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
    bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
 fi
-if [ "$CONFIG_MIPS" = "y" -a "$CONFIG_NEW_TIME_C" = "y" ]; then
-   tristate 'Generic MIPS RTC Support' CONFIG_MIPS_RTC
-fi
 if [ "$CONFIG_SGI_IP22" = "y" ]; then
-   bool 'SGI DS1286 RTC support' CONFIG_SGI_DS1286
+   tristate 'Dallas DS1286 RTC support' CONFIG_DS1286
 fi
 if [ "$CONFIG_SGI_IP27" = "y" ]; then
-   bool 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
+   tristate 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
 fi
 if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" -o "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
    tristate 'Dallas DS1742 RTC support' CONFIG_DS1742
@@ -383,6 +381,11 @@
       source drivers/char/drm/Config.in
    fi
 fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
+fi
+
 endmenu
 
 if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
@@ -391,6 +394,7 @@
 if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
    tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
    tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
+   #tristate ' Alchemy Au1550 PSC SPI support' CONFIG_AU1550_PSC_SPI
 fi
 if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
   tristate ' ITE GPIO' CONFIG_ITE_GPIO
diff -urN linux-2.4.30.old/drivers/input/Config.in linux-2.4.30.dev/drivers/input/Config.in
--- linux-2.4.30.old/drivers/input/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30.dev/drivers/input/Config.in	2008-05-11 02:17:53.000000000 +0200
@@ -7,6 +7,11 @@
 
 tristate 'Input core support' CONFIG_INPUT
 dep_tristate '  Keyboard support' CONFIG_INPUT_KEYBDEV $CONFIG_INPUT
+
+if [ "$CONFIG_INPUT_KEYBDEV" = "n" ]; then
+	bool '  Use dummy keyboard driver' CONFIG_DUMMY_KEYB $CONFIG_INPUT
+fi
+
 dep_tristate '  Mouse support' CONFIG_INPUT_MOUSEDEV $CONFIG_INPUT
 if [ "$CONFIG_INPUT_MOUSEDEV" != "n" ]; then
    int '   Horizontal screen resolution' CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
diff -urN linux-2.4.30.old/drivers/isdn/Config.in linux-2.4.30.dev/drivers/isdn/Config.in
--- linux-2.4.30.old/drivers/isdn/Config.in	2003-11-28 19:26:20.000000000 +0100
+++ linux-2.4.30.dev/drivers/isdn/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -4,11 +4,9 @@
 
 # only included if CONFIG_ISDN != n
 
-define_bool CONFIG_ISDN_BOOL y
 if [ "$CONFIG_INET" != "n" ]; then
    bool '  Support synchronous PPP' CONFIG_ISDN_PPP
    if [ "$CONFIG_ISDN_PPP" != "n" ]; then
-      dep_bool     '    PPP filtering for ISDN' CONFIG_IPPP_FILTER $CONFIG_FILTER
       bool         '    Use VJ-compression with synchronous PPP' CONFIG_ISDN_PPP_VJ
       bool         '    Support generic MP (RFC 1717)' CONFIG_ISDN_MPP
       dep_tristate '    Support BSD compression' CONFIG_ISDN_PPP_BSDCOMP $CONFIG_ISDN
@@ -23,6 +21,30 @@
 fi
 
 mainmenu_option next_comment
+comment 'ISDN abc-dw-extension'
+bool 'Enable isdn-abc-dw-extension' CONFIG_ISDN_WITH_ABC
+if [ "$CONFIG_ISDN_WITH_ABC" != "n" ]; then
+	bool '  Use D-Channel-Callback with Channel in use check' CONFIG_ISDN_WITH_ABC_CALLB
+	bool '  Enable Outgoing-EAZ-Support' CONFIG_ISDN_WITH_ABC_OUTGOING_EAZ
+	bool '  Enable LCR-Support (need isdnlog)' CONFIG_ISDN_WITH_ABC_LCR_SUPPORT
+	bool '  RX dont reset hanguptimeout' CONFIG_ISDN_WITH_ABC_RCV_NO_HUPTIMER
+	if [ "$CONFIG_EXPERIMENTAL" != "n" ]; then
+		bool '  Enable UDP-Info-Support' CONFIG_ISDN_WITH_ABC_UDP_CHECK
+		if [ "$CONFIG_ISDN_WITH_ABC_UDP_CHECK" != "n" ]; then
+			bool '    Enable Hangup-Support with UDP-INFO' CONFIG_ISDN_WITH_ABC_UDP_CHECK_HANGUP
+			bool '    Enable Dial-Support with UDP-INFO' CONFIG_ISDN_WITH_ABC_UDP_CHECK_DIAL
+		fi
+	fi
+
+	bool '  Skip channel if used external (dial only)' CONFIG_ISDN_WITH_ABC_CH_EXTINUSE
+	bool '  Support interface-auto-disable if config-error' CONFIG_ISDN_WITH_ABC_CONN_ERROR
+	if [ "$CONFIG_ISDN_PPP" != "n" ]; then
+		bool '  Enable Compression with rawip and x75i' CONFIG_ISDN_WITH_ABC_RAWIPCOMPRESS
+	fi
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ISDN feature submodules'
    dep_tristate 'isdnloop support' CONFIG_ISDN_DRV_LOOP $CONFIG_ISDN
    dep_tristate 'Support isdn diversion services' CONFIG_ISDN_DIVERSION $CONFIG_ISDN
@@ -34,7 +56,6 @@
 comment 'Passive ISDN cards'
 dep_tristate 'HiSax SiemensChipSet driver support' CONFIG_ISDN_DRV_HISAX $CONFIG_ISDN
 if [ "$CONFIG_ISDN_DRV_HISAX" != "n" ]; then
-   define_bool CONFIG_ISDN_HISAX y
    comment '  D-channel protocol features'
    bool '  HiSax Support for EURO/DSS1' CONFIG_HISAX_EURO
    if [ "$CONFIG_HISAX_EURO" != "n" ]; then
@@ -45,31 +66,28 @@
    fi
    bool '  HiSax Support for german 1TR6' CONFIG_HISAX_1TR6
    bool '  HiSax Support for US NI1' CONFIG_HISAX_NI1
-   int  '  Maximum number of cards supported by HiSax' CONFIG_HISAX_MAX_CARDS 8
    comment '  HiSax supported cards'
-   if [ "$CONFIG_ISA" != "n" ]; then
-      bool '  Teles 16.0/8.0' CONFIG_HISAX_16_0
-      bool '  Teles 16.3 or PNP or PCMCIA' CONFIG_HISAX_16_3
-      bool '  AVM A1 (Fritz)' CONFIG_HISAX_AVM_A1
-      bool '  ITK ix1-micro Revision 2' CONFIG_HISAX_IX1MICROR2
-      bool '  ASUSCOM ISA cards' CONFIG_HISAX_ASUSCOM
-      bool '  TELEINT cards' CONFIG_HISAX_TELEINT
-      bool '  HFC-S based cards' CONFIG_HISAX_HFCS
-      bool '  USR Sportster internal TA' CONFIG_HISAX_SPORTSTER
-      bool '  MIC card' CONFIG_HISAX_MIC
-      bool '  Siemens I-Surf card' CONFIG_HISAX_ISURF
-      bool '  HST Saphir card' CONFIG_HISAX_HSTSAPHIR
-   fi
+   bool '  Teles 16.0/8.0' CONFIG_HISAX_16_0
+   bool '  Teles 16.3 or PNP or PCMCIA' CONFIG_HISAX_16_3
    bool '  Teles PCI' CONFIG_HISAX_TELESPCI 
    bool '  Teles S0Box' CONFIG_HISAX_S0BOX 
+   bool '  AVM A1 (Fritz)' CONFIG_HISAX_AVM_A1
    bool '  AVM PnP/PCI (Fritz!PnP/PCI)' CONFIG_HISAX_FRITZPCI
    bool '  AVM A1 PCMCIA (Fritz)' CONFIG_HISAX_AVM_A1_PCMCIA
    bool '  Elsa cards' CONFIG_HISAX_ELSA
+   bool '  ITK ix1-micro Revision 2' CONFIG_HISAX_IX1MICROR2
    bool '  Eicon.Diehl Diva cards' CONFIG_HISAX_DIEHLDIVA
+   bool '  ASUSCOM ISA cards' CONFIG_HISAX_ASUSCOM
+   bool '  TELEINT cards' CONFIG_HISAX_TELEINT
+   bool '  HFC-S based cards' CONFIG_HISAX_HFCS
    bool '  Sedlbauer cards' CONFIG_HISAX_SEDLBAUER
+   bool '  USR Sportster internal TA' CONFIG_HISAX_SPORTSTER
+   bool '  MIC card' CONFIG_HISAX_MIC
    bool '  NETjet card' CONFIG_HISAX_NETJET
    bool '  NETspider U card' CONFIG_HISAX_NETJET_U
    bool '  Niccy PnP/PCI card' CONFIG_HISAX_NICCY
+   bool '  Siemens I-Surf card' CONFIG_HISAX_ISURF
+   bool '  HST Saphir card' CONFIG_HISAX_HSTSAPHIR
    bool '  Telekom A4T card' CONFIG_HISAX_BKM_A4T
    bool '  Scitel Quadro card' CONFIG_HISAX_SCT_QUADRO
    bool '  Gazel cards' CONFIG_HISAX_GAZEL
@@ -78,20 +96,27 @@
    bool '  HFC-S+, HFC-SP, HFC-PCMCIA cards' CONFIG_HISAX_HFC_SX
    if [ "$CONFIG_EXPERIMENTAL" != "n" ]; then
 #      bool '  TESTEMULATOR (EXPERIMENTAL)' CONFIG_HISAX_TESTEMU
-      bool '  Formula-n enter:now PCI card' CONFIG_HISAX_ENTERNOW_PCI
       if [ "$ARCH" = "sparc" -o "$ARCH" = "sparc64" ]; then
 	 bool '  Am7930' CONFIG_HISAX_AMD7930
       fi
    fi
    bool '  HiSax debugging' CONFIG_HISAX_DEBUG
 
-   dep_tristate 'Sedlbauer PCMCIA cards'                              CONFIG_HISAX_SEDLBAUER_CS  $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA
-   dep_tristate 'ELSA PCMCIA MicroLink cards'                         CONFIG_HISAX_ELSA_CS       $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA
-   dep_tristate 'AVM A1 PCMCIA cards'                                 CONFIG_HISAX_AVM_A1_CS     $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA $CONFIG_HISAX_AVM_A1_PCMCIA
-   dep_tristate 'ST5481 USB ISDN modem (EXPERIMENTAL)'                CONFIG_HISAX_ST5481        $CONFIG_ISDN_DRV_HISAX    $CONFIG_EXPERIMENTAL
-   dep_tristate 'AVM Fritz!Card PCI/PCIv2/PnP support (EXPERIMENTAL)' CONFIG_HISAX_FRITZ_PCIPNP  $CONFIG_ISDN_DRV_HISAX                $CONFIG_EXPERIMENTAL
-   dep_tristate 'Auerswald devices ISDN support'                      CONFIG_USB_AUERISDN        $CONFIG_ISDN_DRV_HISAX
+   dep_tristate 'Sedlbauer PCMCIA cards' CONFIG_HISAX_SEDLBAUER_CS $CONFIG_PCMCIA
+   dep_tristate 'ELSA PCMCIA MicroLink cards' CONFIG_HISAX_ELSA_CS $CONFIG_PCMCIA
+   dep_tristate 'Colognechip HFC-USB support' CONFIG_HISAX_HFC_USB_CS $CONFIG_HISAX $CONFIG_USB
+   dep_tristate 'ST5481 USB ISDN modem (EXPERIMENTAL)' CONFIG_HISAX_ST5481 $CONFIG_HISAX $CONFIG_USB $CONFIG_EXPERIMENTAL
+   dep_tristate 'Fritz!PCIv2 support (EXPERIMENTAL)' CONFIG_HISAX_FRITZ_PCIPNP $CONFIG_HISAX $CONFIG_EXPERIMENTAL
 
+   if [ "$CONFIG_HISAX_SEDLBAUER_CS" != "n" ]; then
+      define_bool CONFIG_HISAX_SEDLBAUER y
+   fi
+   if [ "$CONFIG_HISAX_ELSA_CS" != "n" ]; then
+      define_bool CONFIG_HISAX_ELSA y
+   fi
+   if [ "$CONFIG_HISAX_HFC_USB_CS" != "n" ]; then
+      define_bool CONFIG_HISAX_HFC_USB y
+   fi
 fi
 endmenu
 
diff -urN linux-2.4.30.old/drivers/i2c/Config.in linux-2.4.30.dev/drivers/i2c/Config.in
--- linux-2.4.30.old/drivers/i2c/Config.in	2004-04-14 15:05:29.000000000 +0200
+++ linux-2.4.30.dev/drivers/i2c/Config.in	2008-05-11 02:17:53.000000000 +0200
@@ -1,5 +1,5 @@
 #
-# Character device configuration
+# I2C subsystem configuration
 #
 mainmenu_option next_comment
 comment 'I2C support'
@@ -57,6 +57,10 @@
    if [ "$CONFIG_SGI_IP22" = "y" ]; then
       dep_tristate 'I2C SGI interfaces' CONFIG_I2C_ALGO_SGI $CONFIG_I2C
    fi
+
+   if [ "$CONFIG_SOC_AU1550" = "y" -o "$CONFIG_SOC_AU1200" ]; then
+      dep_tristate 'Au1550/Au1200 SMBus interface' CONFIG_I2C_ALGO_AU1550 $CONFIG_I2C
+   fi
  
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -urN linux-2.4.30.old/drivers/mtd/chips/Config.in linux-2.4.30.dev/drivers/mtd/chips/Config.in
--- linux-2.4.30.old/drivers/mtd/chips/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30.dev/drivers/mtd/chips/Config.in	2008-05-11 02:17:54.000000000 +0200
@@ -45,6 +45,7 @@
 dep_tristate '  Support for Intel/Sharp flash chips' CONFIG_MTD_CFI_INTELEXT $CONFIG_MTD_GEN_PROBE
 dep_tristate '  Support for AMD/Fujitsu flash chips' CONFIG_MTD_CFI_AMDSTD $CONFIG_MTD_GEN_PROBE
 dep_tristate '  Support for ST (Advanced Architecture) flash chips' CONFIG_MTD_CFI_STAA $CONFIG_MTD_GEN_PROBE
+dep_tristate '  Support for SST flash chips' CONFIG_MTD_CFI_SSTSTD $CONFIG_MTD_GEN_PROBE
 
 dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
 dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
diff -urN linux-2.4.30.old/drivers/mtd/maps/Config.in linux-2.4.30.dev/drivers/mtd/maps/Config.in
--- linux-2.4.30.old/drivers/mtd/maps/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30.dev/drivers/mtd/maps/Config.in	2008-05-11 02:17:54.000000000 +0200
@@ -48,14 +48,30 @@
 fi
 
 if [ "$CONFIG_MIPS" = "y" ]; then
+   dep_tristate '  CFI Flash device mapped on Broadcom BCM947XX boards' CONFIG_MTD_BCM947XX $CONFIG_MTD_CFI
    dep_tristate '  Pb1000 MTD support' CONFIG_MTD_PB1000 $CONFIG_MIPS_PB1000
    dep_tristate '  Pb1500 MTD support' CONFIG_MTD_PB1500 $CONFIG_MIPS_PB1500
    dep_tristate '  Pb1100 MTD support' CONFIG_MTD_PB1100 $CONFIG_MIPS_PB1100
+   dep_tristate '  Bosporus MTD support' CONFIG_MTD_BOSPORUS $CONFIG_MIPS_BOSPORUS
+   dep_tristate '  XXS1500 boot flash device' CONFIG_MTD_XXS1500 $CONFIG_MIPS_XXS1500
+   dep_tristate '  MTX-1 flash device' CONFIG_MTD_MTX1 $CONFIG_MIPS_MTX1
    if [ "$CONFIG_MTD_PB1500" = "y" -o "$CONFIG_MTD_PB1500" = "m" \
 	-o "$CONFIG_MTD_PB1100" = "y" -o "$CONFIG_MTD_PB1100" = "m" ]; then
       bool '  Pb[15]00 boot flash device' CONFIG_MTD_PB1500_BOOT 
       bool '  Pb[15]00 user flash device (2nd 32MiB bank)' CONFIG_MTD_PB1500_USER
    fi
+   tristate '  Db1x00 MTD support' CONFIG_MTD_DB1X00
+   if [ "$CONFIG_MTD_DB1X00" = "y" -o "$CONFIG_MTD_DB1X00" = "m" ]; then
+      bool '  Db1x00 boot flash device' CONFIG_MTD_DB1X00_BOOT 
+      bool '  Db1x00 user flash device (2nd bank)' CONFIG_MTD_DB1X00_USER
+   fi
+   tristate '  Pb1550 MTD support' CONFIG_MTD_PB1550
+   if [ "$CONFIG_MTD_PB1550" = "y" -o "$CONFIG_MTD_PB1550" = "m" ]; then
+      bool '  Pb1550 Boot Flash' CONFIG_MTD_PB1550_BOOT
+      bool '  Pb1550 User Parameter Flash' CONFIG_MTD_PB1550_USER
+   fi
+   dep_tristate '  Hydrogen 3 MTD support' CONFIG_MTD_HYDROGEN3 $CONFIG_MIPS_HYDROGEN3
+   dep_tristate '  Mirage MTD support' CONFIG_MTD_MIRAGE $CONFIG_MIPS_MIRAGE
    dep_tristate '  Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board' CONFIG_MTD_CSTM_MIPS_IXX $CONFIG_MTD_CFI $CONFIG_MTD_JEDEC $CONFIG_MTD_PARTITIONS 
    if [ "$CONFIG_MTD_CSTM_MIPS_IXX" = "y" -o "$CONFIG_MTD_CSTM_MIPS_IXX" = "m" ]; then
       hex '    Physical start address of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_START 0x8000000
diff -urN linux-2.4.30.old/drivers/net/Config.in linux-2.4.30.dev/drivers/net/Config.in
--- linux-2.4.30.old/drivers/net/Config.in	2005-01-19 15:09:56.000000000 +0100
+++ linux-2.4.30.dev/drivers/net/Config.in	2008-05-11 02:17:54.000000000 +0200
@@ -2,12 +2,20 @@
 # Network device configuration
 #
 
+tristate 'Broadcom Home Network Division' CONFIG_HND $CONFIG_PCI
+
 source drivers/net/arcnet/Config.in
 
 tristate 'Dummy net driver support' CONFIG_DUMMY
 tristate 'Bonding driver support' CONFIG_BONDING
 tristate 'EQL (serial line load balancing) support' CONFIG_EQUALIZER
+if [ "$CONFIG_NETFILTER" = "y" ]; then
+  tristate 'IMQ (intermediate queueing device) support' CONFIG_IMQ
+else
+  comment 'IMQ needs CONFIG_NETFILTER enabled'
+fi
 tristate 'Universal TUN/TAP device driver support' CONFIG_TUN
+bool 'Allow Net Devices to contribute to /dev/random' CONFIG_NET_RANDOM
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    tristate 'Ethertap network tap (OBSOLETE)' CONFIG_ETHERTAP
 fi
@@ -272,6 +280,10 @@
 if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
    tristate 'SB1250 Ethernet support' CONFIG_NET_SB1250_MAC
 fi
+
+dep_tristate 'Alternate Marvell Yukon Chipset Support (not Yukon2)' CONFIG_SKGE $CONFIG_PCI
+dep_tristate 'Alternate Marvell Yukon 2 Chipset Support' CONFIG_SKY2 $CONFIG_PCI
+
 dep_tristate 'Marvell Yukon Chipset / SysKonnect SK-98xx Support' CONFIG_SK98LIN $CONFIG_PCI
 dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
@@ -332,6 +344,7 @@
    dep_tristate '  PPP support for sync tty ports' CONFIG_PPP_SYNC_TTY $CONFIG_PPP
    dep_tristate '  PPP Deflate compression' CONFIG_PPP_DEFLATE $CONFIG_PPP
    dep_tristate '  PPP BSD-Compress compression' CONFIG_PPP_BSDCOMP $CONFIG_PPP
+   dep_tristate '  Microsoft PPP compression/encryption (MPPC/MPPE)' CONFIG_PPP_MPPE_MPPC $CONFIG_PPP
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       dep_tristate '  PPP over Ethernet (EXPERIMENTAL)' CONFIG_PPPOE $CONFIG_PPP
    fi
diff -urN linux-2.4.30.old/drivers/net/wireless/Config.in linux-2.4.30.dev/drivers/net/wireless/Config.in
--- linux-2.4.30.old/drivers/net/wireless/Config.in	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.30.dev/drivers/net/wireless/Config.in	2008-05-11 02:17:54.000000000 +0200
@@ -13,6 +13,7 @@
 fi
 
 if [ "$CONFIG_PCI" = "y" ]; then
+   dep_tristate '    Proprietary Broadcom BCM43xx 802.11 Wireless support' CONFIG_WL
    dep_tristate '    Hermes in PLX9052 based PCI adaptor support (Netgear MA301 etc.) (EXPERIMENTAL)' CONFIG_PLX_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
    dep_tristate '    Hermes in TMD7160/NCP130 based PCI adaptor support (Pheecom WL-PCI etc.) (EXPERIMENTAL)' CONFIG_TMD_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
    dep_tristate '    Prism 2.5 PCI 802.11b adaptor support (EXPERIMENTAL)' CONFIG_PCI_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
diff -urN linux-2.4.30.old/drivers/parport/Config.in linux-2.4.30.dev/drivers/parport/Config.in
--- linux-2.4.30.old/drivers/parport/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30.dev/drivers/parport/Config.in	2008-05-11 02:17:54.000000000 +0200
@@ -11,6 +11,7 @@
 tristate 'Parallel port support' CONFIG_PARPORT
 if [ "$CONFIG_PARPORT" != "n" ]; then
    dep_tristate '  PC-style hardware' CONFIG_PARPORT_PC $CONFIG_PARPORT
+   dep_tristate '  Asus WL500g parallel port' CONFIG_PARPORT_SPLINK $CONFIG_PARPORT
    if [ "$CONFIG_PARPORT_PC" != "n" -a "$CONFIG_SERIAL" != "n" ]; then
       if [ "$CONFIG_SERIAL" = "m" ]; then
          define_tristate CONFIG_PARPORT_PC_CML1 m
diff -urN linux-2.4.30.old/drivers/pcmcia/Config.in linux-2.4.30.dev/drivers/pcmcia/Config.in
--- linux-2.4.30.old/drivers/pcmcia/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30.dev/drivers/pcmcia/Config.in	2008-05-11 02:17:50.000000000 +0200
@@ -30,16 +30,14 @@
       dep_tristate '  M8xx support' CONFIG_PCMCIA_M8XX $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
-      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA 
-      if [ "$CONFIG_PCMCIA_AU1X00" != "n" ]; then
-        bool '  Pb1x00 board support' CONFIG_PCMCIA_PB1X00
-        bool '  Db1x00 board support' CONFIG_PCMCIA_DB1X00
-        bool '  XXS1500 board support' CONFIG_PCMCIA_XXS1500
-      fi
+      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
       dep_bool '  SiByte PCMCIA support' CONFIG_PCMCIA_SIBYTE $CONFIG_PCMCIA $CONFIG_BLK_DEV_IDE_SIBYTE
    fi
+   if [ "$CONFIG_VRC4171" = "y" -o "$CONFIG_VRC4171" = "m" ]; then
+      dep_tristate '  NEC VRC4171 Card Controllers support' CONFIG_PCMCIA_VRC4171 $CONFIG_PCMCIA
+   fi
    if [ "$CONFIG_VRC4173" = "y" -o "$CONFIG_VRC4173" = "m" ]; then
       dep_tristate '  NEC VRC4173 CARDU support' CONFIG_PCMCIA_VRC4173 $CONFIG_PCMCIA
    fi
diff -urN linux-2.4.30.old/drivers/video/Config.in linux-2.4.30.dev/drivers/video/Config.in
--- linux-2.4.30.old/drivers/video/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30.dev/drivers/video/Config.in	2008-05-11 02:17:50.000000000 +0200
@@ -87,8 +87,8 @@
    if [ "$CONFIG_HP300" = "y" ]; then
       define_bool CONFIG_FB_HP300 y
    fi
-   if [ "$ARCH" = "alpha" ]; then
-      tristate '  TGA framebuffer support' CONFIG_FB_TGA
+   if [ "$ARCH" = "alpha" -o "$CONFIG_TC" = "y" ]; then
+      tristate '  TGA/SFB+ framebuffer support' CONFIG_FB_TGA
    fi
    if [ "$CONFIG_X86" = "y" ]; then
       bool '  VESA VGA graphics console' CONFIG_FB_VESA
@@ -121,6 +121,17 @@
          hex '    Framebuffer Base Address' CONFIG_E1355_FB_BASE a8200000
       fi
    fi
+   if [ "$CONFIG_SOC_AU1100" = "y" ]; then
+      bool '  Au1100 LCD Driver' CONFIG_FB_AU1100
+   fi
+   
+   if [ "$CONFIG_SOC_AU1200" = "y" ]; then
+      bool '  Au1200 LCD Driver' CONFIG_FB_AU1200
+      if [ "$CONFIG_FB_AU1200" = "y" ]; then
+      int  '    Number of planes (1 to 4)' CONFIG_FB_AU1200_DEVS 1
+      fi
+   fi
+   
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       if [ "$CONFIG_PCI" != "n" ]; then
 	 tristate '  Matrox acceleration (EXPERIMENTAL)' CONFIG_FB_MATROX
@@ -178,9 +189,6 @@
 	     bool '    Use CRT on Pb1100 ' CONFIG_PB1500_CRT
 	     bool '    Use TFT Panel on Pb1100 ' CONFIG_PB1500_TFT
            fi
-           if [ "$CONFIG_SOC_AU1100" = "y" ]; then
-	     bool '    Au1100 LCD Driver' CONFIG_FB_AU1100
-           fi
 	 fi
       fi
    fi
diff -urN linux-2.4.30.old/fs/Config.in linux-2.4.30.dev/fs/Config.in
--- linux-2.4.30.old/fs/Config.in	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.30.dev/fs/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -50,7 +50,14 @@
 if [ "$CONFIG_JFFS2_FS" = "y" -o "$CONFIG_JFFS2_FS" = "m" ] ; then
    int 'JFFS2 debugging verbosity (0 = quiet, 2 = noisy)' CONFIG_JFFS2_FS_DEBUG 0
 fi
+dep_mbool '  ARMLIB compression support for BBC (EXPERIMENTAL)' CONFIG_JFFS2_BBC_ARMLIB $CONFIG_JFFS2_FS
+dep_mbool '  LZO1X-* compression support for BBC (EXPERIMENTAL)' CONFIG_JFFS2_BBC_LZO $CONFIG_JFFS2_FS
+dep_mbool '  LZARI compression support for BBC (EXPERIMENTAL)' CONFIG_JFFS2_BBC_LZARI $CONFIG_JFFS2_FS
+dep_mbool '  LZHD compression support for BBC (EXPERIMENTAL)' CONFIG_JFFS2_BBC_LZHD $CONFIG_JFFS2_FS
+dep_mbool '  LZSS compression support for BBC (EXPERIMENTAL)' CONFIG_JFFS2_BBC_LZSS $CONFIG_JFFS2_FS
+
 tristate 'Compressed ROM file system support' CONFIG_CRAMFS
+tristate 'Squashed file system support' CONFIG_SQUASHFS
 bool 'Virtual memory file system support (former shm fs)' CONFIG_TMPFS
 define_bool CONFIG_RAMFS y
 
@@ -63,6 +70,7 @@
 dep_mbool '  JFS statistics' CONFIG_JFS_STATISTICS $CONFIG_JFS_FS
 
 tristate 'Minix fs support' CONFIG_MINIX_FS
+tristate 'mini_fo filesystem overlay' CONFIG_MINI_FO
 
 tristate 'FreeVxFS file system support (VERITAS VxFS(TM) compatible)' CONFIG_VXFS_FS
 tristate 'NTFS file system support (read only)' CONFIG_NTFS_FS
@@ -139,6 +147,10 @@
      define_bool CONFIG_LOCKD_V4 y
    fi
 
+   dep_tristate 'CIFS support (advanced network filesystem for Samba, Window and other CIFS compliant servers)' CONFIG_CIFS $CONFIG_INET
+   dep_mbool '  CIFS statistics' CONFIG_CIFS_STATS $CONFIG_CIFS
+   dep_mbool '  CIFS POSIX Protocol Extensions' CONFIG_CIFS_POSIX $CONFIG_CIFS
+
    dep_tristate 'SMB file system support (to mount Windows shares etc.)' CONFIG_SMB_FS $CONFIG_INET
    if [ "$CONFIG_SMB_FS" != "n" ]; then
       bool '  Use a default NLS' CONFIG_SMB_NLS_DEFAULT
diff -urN linux-2.4.30.old/fs/nls/Config.in linux-2.4.30.dev/fs/nls/Config.in
--- linux-2.4.30.old/fs/nls/Config.in	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.30.dev/fs/nls/Config.in	2008-05-11 02:17:51.000000000 +0200
@@ -11,6 +11,7 @@
 
 # msdos and Joliet want NLS
 if [ "$CONFIG_JOLIET" = "y" -o "$CONFIG_FAT_FS" != "n" \
+	-o "$CONFIG_CIFS" != "n" \
 	-o "$CONFIG_NTFS_FS" != "n" -o "$CONFIG_NCPFS_NLS" = "y" \
 	-o "$CONFIG_SMB_NLS" = "y" -o "$CONFIG_JFS_FS" != "n" \
 	-o "$CONFIG_BEFS_FS" != "n" -o "$CONFIG_HFSPLUS_FS" != "n" ]; then
diff -urN linux-2.4.30.old/include/asm-alpha/hardirq.h linux-2.4.30.dev/include/asm-alpha/hardirq.h
--- linux-2.4.30.old/include/asm-alpha/hardirq.h	2001-07-09 23:47:39.000000000 +0200
+++ linux-2.4.30.dev/include/asm-alpha/hardirq.h	2008-05-11 02:17:53.000000000 +0200
@@ -31,7 +31,7 @@
 #ifndef CONFIG_SMP
 
 extern unsigned long __irq_attempt[];
-#define irq_attempt(cpu, irq)  ((void)(cpu), __irq_attempt[irq])
+#define irq_attempt(cpu, irq)  (__irq_attempt[irq])
 
 #define hardirq_trylock(cpu)	(local_irq_count(cpu) == 0)
 #define hardirq_endlock(cpu)	((void) 0)
diff -urN linux-2.4.30.old/include/asm-alpha/param.h linux-2.4.30.dev/include/asm-alpha/param.h
--- linux-2.4.30.old/include/asm-alpha/param.h	2000-11-08 08:37:31.000000000 +0100
+++ linux-2.4.30.dev/include/asm-alpha/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -13,6 +13,9 @@
 # else
 #  define HZ	1200
 # endif
+#ifdef __KERNEL__
+# define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -urN linux-2.4.30.old/include/asm-alpha/pci.h linux-2.4.30.dev/include/asm-alpha/pci.h
--- linux-2.4.30.old/include/asm-alpha/pci.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/asm-alpha/pci.h	2008-05-11 02:17:53.000000000 +0200
@@ -6,6 +6,7 @@
 #include <linux/spinlock.h>
 #include <asm/scatterlist.h>
 #include <asm/machvec.h>
+#include <asm/io.h>
 
 /*
  * The following structure is used to manage multiple PCI busses.
diff -urN linux-2.4.30.old/include/asm-alpha/signal.h linux-2.4.30.dev/include/asm-alpha/signal.h
--- linux-2.4.30.old/include/asm-alpha/signal.h	1998-06-24 23:30:11.000000000 +0200
+++ linux-2.4.30.dev/include/asm-alpha/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -121,8 +121,15 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x40000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          1	/* for blocking signals */
 #define SIG_UNBLOCK        2	/* for unblocking signals */
 #define SIG_SETMASK        3	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-arm/arch-sa1100/SA-1101.h linux-2.4.30.dev/include/asm-arm/arch-sa1100/SA-1101.h
--- linux-2.4.30.old/include/asm-arm/arch-sa1100/SA-1101.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.30.dev/include/asm-arm/arch-sa1100/SA-1101.h	2008-05-11 02:17:53.000000000 +0200
@@ -98,7 +98,7 @@
 #define SMCR_ColAdrBits( x )		  /* col. addr bits 8..11 */ \
 	(( (x) - 8 ) << FShft (SMCR_DCAC))
 #define SMCR_RowAdrBits( x )		  /* row addr bits 9..12 */\
-	(( (x) - 9 ) << FShft (SMCR_DRAC)
+	(( (x) - 9 ) << FShft (SMCR_DRAC))
 
 #define SNPR_VFBstart	  Fld(12,0)	/* Video frame buffer addr */
 #define SNPR_VFBsize	  Fld(11,12)	/* Video frame buffer size */
@@ -386,7 +386,7 @@
 #define VgaStatus      (*((volatile Word *) SA1101_p2v (_VgaStatus)))
 #define VgaInterruptMask (*((volatile Word *) SA1101_p2v (_VgaInterruptMask)))
 #define VgaPalette     (*((volatile Word *) SA1101_p2v (_VgaPalette)))
-#define DacControl     (*((volatile Word *) SA1101_p2v (_DacControl))
+#define DacControl     (*((volatile Word *) SA1101_p2v (_DacControl)))
 #define VgaTest        (*((volatile Word *) SA1101_p2v (_VgaTest)))
 
 #define VideoControl_VgaEn    0x00000000
diff -urN linux-2.4.30.old/include/asm-arm/signal.h linux-2.4.30.dev/include/asm-arm/signal.h
--- linux-2.4.30.old/include/asm-arm/signal.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.30.dev/include/asm-arm/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -125,8 +125,15 @@
 #define SA_PROBE		0x80000000
 #define SA_SAMPLE_RANDOM	0x10000000
 #define SA_SHIRQ		0x04000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0	/* for blocking signals */
 #define SIG_UNBLOCK        1	/* for unblocking signals */
 #define SIG_SETMASK        2	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-cris/signal.h linux-2.4.30.dev/include/asm-cris/signal.h
--- linux-2.4.30.old/include/asm-cris/signal.h	2001-02-09 01:32:44.000000000 +0100
+++ linux-2.4.30.dev/include/asm-cris/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -120,8 +120,15 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0	/* for blocking signals */
 #define SIG_UNBLOCK        1	/* for unblocking signals */
 #define SIG_SETMASK        2	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-ia64/param.h linux-2.4.30.dev/include/asm-ia64/param.h
--- linux-2.4.30.old/include/asm-ia64/param.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ia64/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -7,9 +7,15 @@
  * Based on <asm-i386/param.h>.
  *
  * Modified 1998, 1999, 2002-2003
- *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
+ *    David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
  */
 
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
+
 #define EXEC_PAGESIZE	65536
 
 #ifndef NGROUPS
diff -urN linux-2.4.30.old/include/asm-ia64/signal.h linux-2.4.30.dev/include/asm-ia64/signal.h
--- linux-2.4.30.old/include/asm-ia64/signal.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ia64/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -117,6 +117,12 @@
 #define SA_SHIRQ		0x04000000
 #define SA_PERCPU_IRQ		0x02000000
 
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
+#endif
+
 #endif /* __KERNEL__ */
 
 #define SIG_BLOCK          0	/* for blocking signals */
diff -urN linux-2.4.30.old/include/asm-i386/bitops.h linux-2.4.30.dev/include/asm-i386/bitops.h
--- linux-2.4.30.old/include/asm-i386/bitops.h	2004-08-08 01:26:06.000000000 +0200
+++ linux-2.4.30.dev/include/asm-i386/bitops.h	2008-05-11 02:17:53.000000000 +0200
@@ -38,7 +38,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btsl %1,%0"
 		:"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 }
 
 /**
@@ -55,7 +55,7 @@
 	__asm__(
 		"btsl %1,%0"
 		:"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 }
 
 /**
@@ -73,7 +73,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btrl %1,%0"
 		:"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 }
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
@@ -92,7 +92,7 @@
 	__asm__ __volatile__(
 		"btcl %1,%0"
 		:"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 }
 
 /**
@@ -109,7 +109,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btcl %1,%0"
 		:"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 }
 
 /**
@@ -127,7 +127,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btsl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr) : "memory");
+		:"Ir" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -147,7 +147,7 @@
 	__asm__(
 		"btsl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 	return oldbit;
 }
 
@@ -166,7 +166,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btrl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr) : "memory");
+		:"Ir" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -186,7 +186,7 @@
 	__asm__(
 		"btrl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr));
+		:"Ir" (nr), "m" (ADDR));
 	return oldbit;
 }
 
@@ -198,7 +198,7 @@
 	__asm__ __volatile__(
 		"btcl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr) : "memory");
+		:"Ir" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -217,7 +217,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btcl %2,%1\n\tsbbl %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"Ir" (nr) : "memory");
+		:"Ir" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
diff -urN linux-2.4.30.old/include/asm-i386/byteorder.h linux-2.4.30.dev/include/asm-i386/byteorder.h
--- linux-2.4.30.old/include/asm-i386/byteorder.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-i386/byteorder.h	2008-05-11 02:17:53.000000000 +0200
@@ -2,6 +2,7 @@
 #define _I386_BYTEORDER_H
 
 #include <asm/types.h>
+#include <linux/compiler.h>
 
 #ifdef __GNUC__
 
@@ -10,7 +11,7 @@
 #include <linux/config.h>
 #endif
 
-static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
+static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 x)
 {
 #ifdef CONFIG_X86_BSWAP
 	__asm__("bswap %0" : "=r" (x) : "0" (x));
@@ -26,7 +27,7 @@
 
 /* gcc should generate this for open coded C now too. May be worth switching to 
    it because inline assembly cannot be scheduled. -AK */
-static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
+static __inline__ __attribute_const__ __u16 ___arch__swab16(__u16 x)
 {
 	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
 		: "=q" (x)
diff -urN linux-2.4.30.old/include/asm-i386/mpspec.h linux-2.4.30.dev/include/asm-i386/mpspec.h
--- linux-2.4.30.old/include/asm-i386/mpspec.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/asm-i386/mpspec.h	2008-05-11 02:17:53.000000000 +0200
@@ -84,7 +84,7 @@
 {
 	unsigned char mpc_type;
 	unsigned char mpc_busid;
-	unsigned char mpc_bustype[6] __attribute((packed));
+	unsigned char mpc_bustype[6];
 };
 
 /* List of Bus Type string values, Intel MP Spec. */
diff -urN linux-2.4.30.old/include/asm-i386/page.h linux-2.4.30.dev/include/asm-i386/page.h
--- linux-2.4.30.old/include/asm-i386/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.30.dev/include/asm-i386/page.h	2008-05-11 02:17:53.000000000 +0200
@@ -41,11 +41,13 @@
 typedef struct { unsigned long long pmd; } pmd_t;
 typedef struct { unsigned long long pgd; } pgd_t;
 #define pte_val(x)	((x).pte_low | ((unsigned long long)(x).pte_high << 32))
+#define __pte(x) ({ pte_t __pte = {(x), (x) >> 32}; __pte; })
 #else
 typedef struct { unsigned long pte_low; } pte_t;
 typedef struct { unsigned long pmd; } pmd_t;
 typedef struct { unsigned long pgd; } pgd_t;
 #define pte_val(x)	((x).pte_low)
+#define __pte(x) ((pte_t) { (x) } )
 #endif
 #define PTE_MASK	PAGE_MASK
 
@@ -55,7 +57,6 @@
 #define pgd_val(x)	((x).pgd)
 #define pgprot_val(x)	((x).pgprot)
 
-#define __pte(x) ((pte_t) { (x) } )
 #define __pmd(x) ((pmd_t) { (x) } )
 #define __pgd(x) ((pgd_t) { (x) } )
 #define __pgprot(x)	((pgprot_t) { (x) } )
diff -urN linux-2.4.30.old/include/asm-i386/param.h linux-2.4.30.dev/include/asm-i386/param.h
--- linux-2.4.30.old/include/asm-i386/param.h	2000-10-27 20:04:43.000000000 +0200
+++ linux-2.4.30.dev/include/asm-i386/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urN linux-2.4.30.old/include/asm-i386/processor.h linux-2.4.30.dev/include/asm-i386/processor.h
--- linux-2.4.30.old/include/asm-i386/processor.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-i386/processor.h	2008-05-11 02:17:53.000000000 +0200
@@ -72,7 +72,6 @@
  */
 
 extern struct cpuinfo_x86 boot_cpu_data;
-extern struct tss_struct init_tss[NR_CPUS];
 
 #ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
@@ -235,8 +234,9 @@
 #define getCx86(reg) ({ outb((reg), 0x22); inb(0x23); })
 
 #define setCx86(reg, data) do { \
+	unsigned char _tmp_data = (data); \
 	outb((reg), 0x22); \
-	outb((data), 0x23); \
+	outb(_tmp_data, 0x23); \
 } while (0)
 
 /*
@@ -357,6 +357,8 @@
 	unsigned long __cacheline_filler[5];
 };
 
+extern struct tss_struct init_tss[NR_CPUS];
+
 struct thread_struct {
 	unsigned long	esp0;
 	unsigned long	eip;
diff -urN linux-2.4.30.old/include/asm-i386/signal.h linux-2.4.30.dev/include/asm-i386/signal.h
--- linux-2.4.30.old/include/asm-i386/signal.h	2001-11-22 20:46:18.000000000 +0100
+++ linux-2.4.30.dev/include/asm-i386/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -119,8 +119,15 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0	/* for blocking signals */
 #define SIG_UNBLOCK        1	/* for unblocking signals */
 #define SIG_SETMASK        2	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-i386/string.h linux-2.4.30.dev/include/asm-i386/string.h
--- linux-2.4.30.old/include/asm-i386/string.h	2001-11-22 20:46:18.000000000 +0100
+++ linux-2.4.30.dev/include/asm-i386/string.h	2008-05-11 02:17:53.000000000 +0200
@@ -337,7 +337,7 @@
 #define struct_cpy(x,y) 			\
 ({						\
 	if (sizeof(*(x)) != sizeof(*(y))) 	\
-		__struct_cpy_bug;		\
+		__struct_cpy_bug();		\
 	memcpy(x, y, sizeof(*(x)));		\
 })
 
diff -urN linux-2.4.30.old/include/asm-i386/system.h linux-2.4.30.dev/include/asm-i386/system.h
--- linux-2.4.30.old/include/asm-i386/system.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-i386/system.h	2008-05-11 02:17:53.000000000 +0200
@@ -84,7 +84,7 @@
 #define loadsegment(seg,value)			\
 	asm volatile("\n"			\
 		"1:\t"				\
-		"movl %0,%%" #seg "\n"		\
+		"mov %0,%%" #seg "\n"		\
 		"2:\n"				\
 		".section .fixup,\"ax\"\n"	\
 		"3:\t"				\
@@ -96,7 +96,7 @@
 		".align 4\n\t"			\
 		".long 1b,3b\n"			\
 		".previous"			\
-		: :"m" (*(unsigned int *)&(value)))
+		: :"m" (value))
 
 /*
  * Clear and set 'TS' bit respectively
@@ -302,7 +302,7 @@
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
 #define smp_wmb()	wmb()
-#define set_mb(var, value) do { xchg(&var, value); } while (0)
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
 #else
 #define smp_mb()	barrier()
 #define smp_rmb()	barrier()
diff -urN linux-2.4.30.old/include/asm-mips/au1xxx_dbdma.h linux-2.4.30.dev/include/asm-mips/au1xxx_dbdma.h
--- linux-2.4.30.old/include/asm-mips/au1xxx_dbdma.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1xxx_dbdma.h	2008-05-11 02:17:50.000000000 +0200
@@ -43,7 +43,7 @@
 #define DDMA_GLOBAL_BASE	0xb4003000
 #define DDMA_CHANNEL_BASE	0xb4002000
 
-typedef struct dbdma_global {
+typedef volatile struct dbdma_global {
 	u32	ddma_config;
 	u32	ddma_intstat;
 	u32	ddma_throttle;
@@ -60,7 +60,7 @@
 
 /* The structure of a DMA Channel.
 */
-typedef struct au1xxx_dma_channel {
+typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_cfg;	/* See below */
 	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
 	u32	ddma_statptr;	/* word aligned pointer to status word */
@@ -96,7 +96,7 @@
 /* "Standard" DDMA Descriptor.
  * Must be 32-byte aligned.
  */
-typedef struct au1xxx_ddma_desc {
+typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_cmd0;		/* See below */
 	u32	dscr_cmd1;		/* See below */
 	u32	dscr_source0;		/* source phys address */
@@ -105,6 +105,12 @@
 	u32	dscr_dest1;		/* See below */
 	u32	dscr_stat;		/* completion status */
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+	/* First 32bytes are HW specific!!!
+	   Lets have some SW data following.. make sure its 32bytes
+	 */
+	u32	sw_status;
+	u32 	sw_context;
+	u32	sw_reserved[6];
 } au1x_ddma_desc_t;
 
 #define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
@@ -123,6 +129,8 @@
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
+#define SW_STATUS_INUSE		(1<<0)
+
 /* Command 0 device IDs.
 */
 #ifdef CONFIG_SOC_AU1550
@@ -169,8 +177,8 @@
 #define DSCR_CMD0_SDMS_RX0	9
 #define DSCR_CMD0_SDMS_TX1	10
 #define DSCR_CMD0_SDMS_RX1	11
-#define DSCR_CMD0_AES_TX	12
-#define DSCR_CMD0_AES_RX	13
+#define DSCR_CMD0_AES_TX	13
+#define DSCR_CMD0_AES_RX	12
 #define DSCR_CMD0_PSC0_TX	14
 #define DSCR_CMD0_PSC0_RX	15
 #define DSCR_CMD0_PSC1_TX	16
@@ -189,6 +197,10 @@
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32
+/* THis macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x,d)	(((((x)&0xFFFF)<<8)|0x32000000)|((d)&0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x)&0xFF)
+
 
 #define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
 #define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
@@ -277,6 +289,43 @@
 */
 #define NUM_DBDMA_CHANS	16
 
+/*
+ * Ddma API definitions
+ * FIXME: may not fit to this header file
+ */
+typedef struct dbdma_device_table {
+	u32		dev_id;
+	u32		dev_flags;
+	u32		dev_tsize;
+	u32		dev_devwidth;
+	u32		dev_physaddr;		/* If FIFO */
+	u32		dev_intlevel;
+	u32		dev_intpolarity;
+} dbdev_tab_t;
+
+
+typedef struct dbdma_chan_config {
+	spinlock_t      lock;
+
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void (*chan_callback)(int, void *, struct pt_regs *);
+} chan_tab_t;
+
+#define DEV_FLAGS_INUSE		(1 << 0)
+#define DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+#define DEV_FLAGS_BURSTABLE (1 << 4)
+#define DEV_FLAGS_SYNC		(1 << 5)
+/* end Ddma API definitions */
+
 /* External functions for drivers to use.
 */
 /* Use this to allocate a dbdma channel.  The device ids are one of the
@@ -299,8 +348,8 @@
 
 /* Put buffers on source/destination descriptors.
 */
-u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes);
-u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes);
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor.
 */
@@ -314,5 +363,25 @@
 void au1xxx_dbdma_chan_free(u32 chanid);
 void au1xxx_dbdma_dump(u32 chanid);
 
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr );
+
+u32 au1xxx_ddma_add_device( dbdev_tab_t *dev );
+
+/*
+ 	Some compatibilty macros --
+		Needed to make changes to API without breaking existing drivers
+*/
+#define	au1xxx_dbdma_put_source(chanid,buf,nbytes)_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_source_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+
+#define au1xxx_dbdma_put_dest(chanid,buf,nbytes) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_dest_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+
+/*
+ *	Flags for the put_source/put_dest functions.
+ */
+#define DDMA_FLAGS_IE	(1<<0)
+#define DDMA_FLAGS_NOIE (1<<1)
+
 #endif /* _LANGUAGE_ASSEMBLY */
 #endif /* _AU1000_DBDMA_H_ */
diff -urN linux-2.4.30.old/include/asm-mips/au1xxx_gpio.h linux-2.4.30.dev/include/asm-mips/au1xxx_gpio.h
--- linux-2.4.30.old/include/asm-mips/au1xxx_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1xxx_gpio.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,22 @@
+
+
+#ifndef __AU1XXX_GPIO_H
+#define __AU1XXX_GPIO_H
+
+void au1xxx_gpio1_set_inputs(void);
+void au1xxx_gpio_tristate(int signal);
+void au1xxx_gpio_write(int signal, int value);
+int  au1xxx_gpio_read(int signal);
+
+typedef volatile struct
+{
+	u32 dir;
+	u32 reserved;
+	u32 output;
+	u32 pinstate;
+	u32 inten;
+	u32 enable;
+
+} AU1X00_GPIO2;
+
+#endif //__AU1XXX_GPIO_H
diff -urN linux-2.4.30.old/include/asm-mips/au1xxx_psc.h linux-2.4.30.dev/include/asm-mips/au1xxx_psc.h
--- linux-2.4.30.old/include/asm-mips/au1xxx_psc.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1xxx_psc.h	2008-05-11 02:17:50.000000000 +0200
@@ -41,6 +41,11 @@
 #define PSC3_BASE_ADDR		0xb0d00000
 #endif
 
+#ifdef CONFIG_SOC_AU1200
+#define PSC0_BASE_ADDR		0xb1a00000
+#define PSC1_BASE_ADDR		0xb1b00000
+#endif
+
 /* The PSC select and control registers are common to
  * all protocols.
  */
@@ -226,6 +231,8 @@
 #define PSC_I2SCFG_DD_DISABLE	(1 << 27)
 #define PSC_I2SCFG_DE_ENABLE	(1 << 26)
 #define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
+#define PSC_I2SCFG_WS(n)		((n&0xFF)<<16)
+#define PSC_I2SCFG_WS_MASK	(PSC_I2SCFG_WS(0x3F))
 #define PSC_I2SCFG_WI		(1 << 15)
 
 #define PSC_I2SCFG_DIV_MASK	(3 << 13)
diff -urN linux-2.4.30.old/include/asm-mips/au1000_gpio.h linux-2.4.30.dev/include/asm-mips/au1000_gpio.h
--- linux-2.4.30.old/include/asm-mips/au1000_gpio.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1000_gpio.h	2008-05-11 02:17:50.000000000 +0200
@@ -30,6 +30,13 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/*
+ *  Revision history
+ *    01/31/02  0.01   Initial release. Steve Longerbeam, MontaVista
+ *    10/12/03  0.1    Added Au1100/Au1500, GPIO2, and bit operations. K.C. Nishio, AMD
+ *    08/05/04  0.11   Added Au1550 and Au1200. K.C. Nishio
+ */
+
 #ifndef __AU1000_GPIO_H
 #define __AU1000_GPIO_H
 
@@ -44,13 +51,94 @@
 #define AU1000GPIO_TRISTATE	_IOW (AU1000GPIO_IOC_MAGIC, 4, int)
 #define AU1000GPIO_AVAIL_MASK	_IOR (AU1000GPIO_IOC_MAGIC, 5, int)
 
+// bit operations
+#define AU1000GPIO_BIT_READ	_IOW (AU1000GPIO_IOC_MAGIC, 6, int)
+#define AU1000GPIO_BIT_SET	_IOW (AU1000GPIO_IOC_MAGIC, 7, int)
+#define AU1000GPIO_BIT_CLEAR	_IOW (AU1000GPIO_IOC_MAGIC, 8, int)
+#define AU1000GPIO_BIT_TRISTATE	_IOW (AU1000GPIO_IOC_MAGIC, 9, int)
+#define AU1000GPIO_BIT_INIT	_IOW (AU1000GPIO_IOC_MAGIC, 10, int)
+#define AU1000GPIO_BIT_TERM	_IOW (AU1000GPIO_IOC_MAGIC, 11, int)
+
+/* set this major numer same as the CRIS GPIO driver */
+#define AU1X00_GPIO_MAJOR	(120)
+
+#define ENABLED_ZERO		(0)
+#define ENABLED_ONE		(1)
+#define ENABLED_10		(0x2)
+#define ENABLED_11		(0x3)
+#define ENABLED_111		(0x7)
+#define NOT_AVAIL		(-1)
+#define AU1X00_MAX_PRIMARY_GPIO	(32) 
+
+#define AU1000_GPIO_MINOR_MAX	AU1X00_MAX_PRIMARY_GPIO
+/* Au1100, 1500, 1550 and 1200 have the secondary GPIO block */
+#define AU1XX0_GPIO_MINOR_MAX	(48)
+
+#define AU1X00_GPIO_NAME	"gpio"
+
+/* GPIO pins which are not multiplexed */
+#if defined(CONFIG_SOC_AU1000)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 1) | (1 << 0))
+  #define NATIVE_GPIO2PIN	(0)
+#elif defined(CONFIG_SOC_AU1100)
+  #define NATIVE_GPIOPIN	((1 << 23) | (1 << 22) | (1 << 21) | (1 << 20) | (1 << 19) | (1 << 18) | \
+				 (1 << 17) | (1 << 16) | (1 << 7) | (1 << 1) | (1 << 0))
+  #define NATIVE_GPIO2PIN	(0)
+#elif defined(CONFIG_SOC_AU1500)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 1) | (1 << 0))
+  /* exclude the PCI reset output signal: GPIO[200], DMA_REQ2 and DMA_REQ3 */
+  #define NATIVE_GPIO2PIN	(0xfffe & ~((1 << 9) | (1 << 8))) 
+#elif defined(CONFIG_SOC_AU1550)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 6) | (1 << 1) | (1 << 0))
+  /* please refere Au1550 Data Book, chapter 15 */
+  #define NATIVE_GPIO2PIN	(1 << 5) 
+#elif defined(CONFIG_SOC_AU1200)
+  #define NATIVE_GPIOPIN	((1 << 7) | (1 << 5))
+  #define NATIVE_GPIO2PIN	(0) 
+#endif
+
+/* minor as u32 */
+#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
+#define IS_PRIMARY_GPIOPIN(minor)	((minor < AU1X00_MAX_PRIMARY_GPIO) ? 1 : 0)
+
+/*
+ * pin to minor mapping.
+ * GPIO0-GPIO31, minor=0-31.
+ * GPIO200-GPIO215, minor=32-47.
+ */
+typedef struct _au1x00_gpio_bit_ctl {
+	int direction;	// The direction of this GPIO pin. 0: IN, 1: OUT.
+	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
+} au1x00_gpio_bit_ctl;
+
+typedef struct _au1x00_gpio_driver {
+	const char	*driver_name;
+	const char	*name;
+	int		name_base;	/* offset of printed name */
+	short		major;		/* major device number */
+	short		minor_start;	/* start of minor device number*/
+	short		num;		/* number of devices */
+} au1x00_gpio_driver;
+
 #ifdef __KERNEL__
-extern u32 get_au1000_avail_gpio_mask(void);
-extern int au1000gpio_tristate(u32 data);
-extern int au1000gpio_in(u32 *data);
-extern int au1000gpio_set(u32 data);
-extern int au1000gpio_clear(u32 data);
-extern int au1000gpio_out(u32 data);
+extern u32 get_au1000_avail_gpio_mask(u32 *avail_gpio2);
+extern int au1000gpio_tristate(u32 minor, u32 data);
+extern int au1000gpio_in(u32 minor, u32 *data);
+extern int au1000gpio_set(u32 minor, u32 data);
+extern int au1000gpio_clear(u32 minor, u32 data);
+extern int au1000gpio_out(u32 minor, u32 data);
+extern int au1000gpio_bit_read(u32 minor, u32 *read_data);
+extern int au1000gpio_bit_set(u32 minor);
+extern int au1000gpio_bit_clear(u32 minor);
+extern int au1000gpio_bit_tristate(u32 minor);
+extern int check_minor_to_gpio(u32 minor);
+extern int au1000gpio_bit_init(u32 minor, au1x00_gpio_bit_ctl *bit_opt);
+extern int au1000gpio_bit_term(u32 minor, au1x00_gpio_bit_ctl *bit_opt);
+
+extern void gpio_register_devfs (au1x00_gpio_driver *driver, unsigned int flags, unsigned minor);
+extern void gpio_unregister_devfs (au1x00_gpio_driver *driver, unsigned minor);
+extern int gpio_register_driver(au1x00_gpio_driver *driver);
+extern int gpio_unregister_driver(au1x00_gpio_driver *driver);
 #endif
 
 #endif
diff -urN linux-2.4.30.old/include/asm-mips/au1000.h linux-2.4.30.dev/include/asm-mips/au1000.h
--- linux-2.4.30.old/include/asm-mips/au1000.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1000.h	2008-05-11 02:17:50.000000000 +0200
@@ -160,28 +160,356 @@
 #define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
 #endif
 
-/* SDRAM Controller */
+/*
+ * SDRAM Register Offsets
+ */
 #if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0                0xB4000000
-#define MEM_SDMODE1                0xB4000004
-#define MEM_SDMODE2                0xB4000008
-
-#define MEM_SDADDR0                0xB400000C
-#define MEM_SDADDR1                0xB4000010
-#define MEM_SDADDR2                0xB4000014
-
-#define MEM_SDREFCFG               0xB4000018
-#define MEM_SDPRECMD               0xB400001C
-#define MEM_SDAUTOREF              0xB4000020
-
-#define MEM_SDWRMD0                0xB4000024
-#define MEM_SDWRMD1                0xB4000028
-#define MEM_SDWRMD2                0xB400002C
+#define MEM_SDMODE0		(0x0000)
+#define MEM_SDMODE1		(0x0004)
+#define MEM_SDMODE2		(0x0008)
+#define MEM_SDADDR0		(0x000C)
+#define MEM_SDADDR1		(0x0010)
+#define MEM_SDADDR2		(0x0014)
+#define MEM_SDREFCFG	(0x0018)
+#define MEM_SDPRECMD	(0x001C)
+#define MEM_SDAUTOREF	(0x0020)
+#define MEM_SDWRMD0		(0x0024)
+#define MEM_SDWRMD1		(0x0028)
+#define MEM_SDWRMD2		(0x002C)
+#define MEM_SDSLEEP		(0x0030)
+#define MEM_SDSMCKE		(0x0034)
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 sdmode1;
+	uint32 sdmode2;
+	uint32 sdaddr0;
+	uint32 sdaddr1;
+	uint32 sdaddr2;
+	uint32 sdrefcfg;
+	uint32 sdautoref;
+	uint32 sdwrmd0;
+	uint32 sdwrmd1;
+	uint32 sdwrmd2;
+	uint32 sdsleep;
+	uint32 sdsmcke;
+
+} AU1X00_SDRAM;*/
+#endif
+
+/*
+ * MEM_SDMODE register content definitions
+ */
+#define MEM_SDMODE_F		(1<<22)
+#define MEM_SDMODE_SR		(1<<21)
+#define MEM_SDMODE_BS		(1<<20)
+#define MEM_SDMODE_RS		(3<<18)
+#define MEM_SDMODE_CS		(7<<15)
+#define MEM_SDMODE_TRAS		(15<<11)
+#define MEM_SDMODE_TMRD		(3<<9)
+#define MEM_SDMODE_TWR		(3<<7)
+#define MEM_SDMODE_TRP		(3<<5)
+#define MEM_SDMODE_TRCD		(3<<3)
+#define MEM_SDMODE_TCL		(7<<0)
+
+#define MEM_SDMODE_BS_2Bank	(0<<20)
+#define MEM_SDMODE_BS_4Bank	(1<<20)
+#define MEM_SDMODE_RS_11Row	(0<<18)
+#define MEM_SDMODE_RS_12Row	(1<<18)
+#define MEM_SDMODE_RS_13Row	(2<<18)
+#define MEM_SDMODE_RS_N(N)	((N)<<18)
+#define MEM_SDMODE_CS_7Col	(0<<15)
+#define MEM_SDMODE_CS_8Col	(1<<15)
+#define MEM_SDMODE_CS_9Col	(2<<15)
+#define MEM_SDMODE_CS_10Col	(3<<15)
+#define MEM_SDMODE_CS_11Col	(4<<15)
+#define MEM_SDMODE_CS_N(N)		((N)<<15)
+#define MEM_SDMODE_TRAS_N(N)	((N)<<11)
+#define MEM_SDMODE_TMRD_N(N)	((N)<<9)
+#define MEM_SDMODE_TWR_N(N)		((N)<<7)
+#define MEM_SDMODE_TRP_N(N)		((N)<<5)
+#define MEM_SDMODE_TRCD_N(N)	((N)<<3)
+#define MEM_SDMODE_TCL_N(N)		((N)<<0)
+
+/*
+ * MEM_SDADDR register contents definitions
+ */
+#define MEM_SDADDR_E			(1<<20)
+#define MEM_SDADDR_CSBA			(0x03FF<<10)
+#define MEM_SDADDR_CSMASK		(0x03FF<<0)
+#define MEM_SDADDR_CSBA_N(N)	((N)&(0x03FF<<22)>>12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF<<22)>>22)
+
+/*
+ * MEM_SDREFCFG register content definitions
+ */
+#define MEM_SDREFCFG_TRC		(15<<28)
+#define MEM_SDREFCFG_TRPM		(3<<26)
+#define MEM_SDREFCFG_E			(1<<25)
+#define MEM_SDREFCFG_RE			(0x1ffffff<<0)
+#define MEM_SDREFCFG_TRC_N(N)	((N)<<MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N)<<MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
+#endif
+
+/***********************************************************************/
+
+/*
+ * Au1550 SDRAM Register Offsets
+ */
+
+/***********************************************************************/
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_SDMODE0		(0x0800)
+#define MEM_SDMODE1		(0x0808)
+#define MEM_SDMODE2		(0x0810)
+#define MEM_SDADDR0		(0x0820)
+#define MEM_SDADDR1		(0x0828)
+#define MEM_SDADDR2		(0x0830)
+#define MEM_SDCONFIGA	(0x0840)
+#define MEM_SDCONFIGB	(0x0848)
+#define MEM_SDSTAT		(0x0850)
+#define MEM_SDERRADDR	(0x0858)
+#define MEM_SDSTRIDE0	(0x0860)
+#define MEM_SDSTRIDE1	(0x0868)
+#define MEM_SDSTRIDE2	(0x0870)
+#define MEM_SDWRMD0		(0x0880)
+#define MEM_SDWRMD1		(0x0888)
+#define MEM_SDWRMD2		(0x0890)
+#define MEM_SDPRECMD	(0x08C0)
+#define MEM_SDAUTOREF	(0x08C8)
+#define MEM_SDSREF		(0x08D0)
+#define MEM_SDSLEEP		MEM_SDSREF
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 reserved0;
+	uint32 sdmode1;
+	uint32 reserved1;
+	uint32 sdmode2;
+	uint32 reserved2[3];
+	uint32 sdaddr0;
+	uint32 reserved3;
+	uint32 sdaddr1;
+	uint32 reserved4;
+	uint32 sdaddr2;
+	uint32 reserved5[3];
+	uint32 sdconfiga;
+	uint32 reserved6;
+	uint32 sdconfigb;
+	uint32 reserved7;
+	uint32 sdstat;
+	uint32 reserved8;
+	uint32 sderraddr;
+	uint32 reserved9;
+	uint32 sdstride0;
+	uint32 reserved10;
+	uint32 sdstride1;
+	uint32 reserved11;
+	uint32 sdstride2;
+	uint32 reserved12[3];
+	uint32 sdwrmd0;
+	uint32 reserved13;
+	uint32 sdwrmd1;
+	uint32 reserved14;
+	uint32 sdwrmd2;
+	uint32 reserved15[11];
+	uint32 sdprecmd;
+	uint32 reserved16;
+	uint32 sdautoref;
+	uint32 reserved17;
+	uint32 sdsref;
+
+} AU1550_SDRAM;*/
+#endif
+#endif
+
+/*
+ * Physical base addresses for integrated peripherals
+ */
+
+#ifdef CONFIG_SOC_AU1000
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART2_PHYS_ADDR		0x11300000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/********************************************************************/
 
-#define MEM_SDSLEEP                0xB4000030
-#define MEM_SDSMCKE                0xB4000034
+#ifdef CONFIG_SOC_AU1500
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x11500000
+#define	MAC1_PHYS_ADDR		0x11510000
+#define	MACEN_PHYS_ADDR		0x11520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
 #endif
 
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1100
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define LCD_PHYS_ADDR		0x15000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1550
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	USBH_PHYS_ADDR		0x14020000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PE_PHYS_ADDR		0x14008000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PSC2_PHYS_ADDR	 	0x10A00000
+#define PSC3_PHYS_ADDR	 	0x10B00000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1200
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define AES_PHYS_ADDR		0x10300000
+#define CIM_PHYS_ADDR		0x14004000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define USBM_PHYS_ADDR		0x14020000
+#define	USBH_PHYS_ADDR		0x14020100
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define LCD_PHYS_ADDR		0x15000000
+#define SWCNT_PHYS_ADDR		0x1110010C
+#define MAEFE_PHYS_ADDR		0x14012000
+#define MAEBE_PHYS_ADDR		0x14010000
+#endif
+
+
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
 #define MEM_STTIME0                0xB4001004
@@ -367,7 +695,7 @@
 #define AU1000_MAC0_ENABLE       0xB0520000
 #define AU1000_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1000
+#endif /* CONFIG_SOC_AU1000 */
 
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
@@ -438,7 +766,7 @@
 #define AU1500_MAC0_ENABLE       0xB1520000
 #define AU1500_MAC1_ENABLE       0xB1520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1500
+#endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
@@ -483,6 +811,22 @@
 #define AU1000_GPIO_13            45
 #define AU1000_GPIO_14            46
 #define AU1000_GPIO_15            47
+#define AU1000_GPIO_16            48
+#define AU1000_GPIO_17            49
+#define AU1000_GPIO_18            50
+#define AU1000_GPIO_19            51
+#define AU1000_GPIO_20            52
+#define AU1000_GPIO_21            53
+#define AU1000_GPIO_22            54
+#define AU1000_GPIO_23            55
+#define AU1000_GPIO_24            56
+#define AU1000_GPIO_25            57
+#define AU1000_GPIO_26            58
+#define AU1000_GPIO_27            59
+#define AU1000_GPIO_28            60
+#define AU1000_GPIO_29            61
+#define AU1000_GPIO_30            62
+#define AU1000_GPIO_31            63
 
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
@@ -494,7 +838,7 @@
 #define AU1100_ETH0_BASE	  0xB0500000
 #define AU1100_MAC0_ENABLE       0xB0520000
 #define NUM_ETH_INTERFACES 1
-#endif // CONFIG_SOC_AU1100
+#endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
 #define AU1550_UART0_INT          0
@@ -511,14 +855,14 @@
 #define AU1550_PSC1_INT           11
 #define AU1550_PSC2_INT           12
 #define AU1550_PSC3_INT           13
-#define AU1550_TOY_INT			  14
-#define AU1550_TOY_MATCH0_INT     15
-#define AU1550_TOY_MATCH1_INT     16
-#define AU1550_TOY_MATCH2_INT     17
-#define AU1550_RTC_INT            18
-#define AU1550_RTC_MATCH0_INT     19
-#define AU1550_RTC_MATCH1_INT     20
-#define AU1550_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1550_NAND_INT           23
 #define AU1550_USB_DEV_REQ_INT    24
 #define AU1550_USB_DEV_SUS_INT    25
@@ -573,7 +917,7 @@
 #define AU1550_MAC0_ENABLE       0xB0520000
 #define AU1550_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1550
+#endif /* CONFIG_SOC_AU1550 */
 
 #ifdef CONFIG_SOC_AU1200
 #define AU1200_UART0_INT          0
@@ -590,14 +934,14 @@
 #define AU1200_PSC1_INT           11
 #define AU1200_AES_INT            12
 #define AU1200_CAMERA_INT         13
-#define AU1200_TOY_INT			  14
-#define AU1200_TOY_MATCH0_INT     15
-#define AU1200_TOY_MATCH1_INT     16
-#define AU1200_TOY_MATCH2_INT     17
-#define AU1200_RTC_INT            18
-#define AU1200_RTC_MATCH0_INT     19
-#define AU1200_RTC_MATCH1_INT     20
-#define AU1200_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1200_NAND_INT           23
 #define AU1200_GPIO_204           24
 #define AU1200_GPIO_205           25
@@ -605,6 +949,7 @@
 #define AU1200_GPIO_207           27
 #define AU1200_GPIO_208_215       28 // Logical OR of 208:215
 #define AU1200_USB_INT            29
+#define AU1000_USB_HOST_INT		  AU1200_USB_INT
 #define AU1200_LCD_INT            30
 #define AU1200_MAE_BOTH_INT       31
 #define AU1000_GPIO_0             32
@@ -643,21 +988,36 @@
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_UOC_BASE              0x14020020
+#define USB_UOC_LEN               0x20
+#define USB_OHCI_BASE             0x14020100
+#define USB_OHCI_LEN              0x100
+#define USB_EHCI_BASE             0x14020200
+#define USB_EHCI_LEN              0x100
+#define USB_UDC_BASE              0x14022000
+#define USB_UDC_LEN               0x2000
+#define USB_MSR_BASE			  0xB4020000
+#define USB_MSR_MCFG              4
+#define USBMSRMCFG_OMEMEN         0
+#define USBMSRMCFG_OBMEN          1
+#define USBMSRMCFG_EMEMEN         2
+#define USBMSRMCFG_EBMEN          3
+#define USBMSRMCFG_DMEMEN         4
+#define USBMSRMCFG_DBMEN          5
+#define USBMSRMCFG_GMEMEN         6
+#define USBMSRMCFG_OHCCLKEN       16
+#define USBMSRMCFG_EHCCLKEN       17
+#define USBMSRMCFG_UDCCLKEN       18
+#define USBMSRMCFG_PHYPLLEN       19
+#define USBMSRMCFG_RDCOMB         30
+#define USBMSRMCFG_PFEN           31
 
-// these are here for prototyping on au1550 (do not exist on au1200)
-#define AU1200_ETH0_BASE      0xB0500000
-#define AU1200_ETH1_BASE      0xB0510000
-#define AU1200_MAC0_ENABLE       0xB0520000
-#define AU1200_MAC1_ENABLE       0xB0520004
-#define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1200
+#endif /* CONFIG_SOC_AU1200 */
 
 #define AU1000_LAST_INTC0_INT     31
+#define AU1000_LAST_INTC1_INT     63
 #define AU1000_MAX_INTR           63
 
-
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE                   0xB1900000
 #define SYS_COUNTER_CNTRL          (SYS_BASE + 0x14)
@@ -728,6 +1088,8 @@
   #define I2S_CONTROL_D         (1<<1)
   #define I2S_CONTROL_CE        (1<<0)
 
+#ifndef CONFIG_SOC_AU1200
+
 /* USB Host Controller */
 #define USB_OHCI_LEN              0x00100000
 
@@ -773,6 +1135,8 @@
   #define USBDEV_ENABLE (1<<1)
   #define USBDEV_CE     (1<<0)
 
+#endif /* !CONFIG_SOC_AU1200 */
+
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
@@ -1171,6 +1535,37 @@
   #define SYS_PF_PSC1_S1		(1 << 1)
   #define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
 
+/* Au1200 Only */
+#ifdef CONFIG_SOC_AU1200
+#define SYS_PINFUNC_DMA		(1<<31)
+#define SYS_PINFUNC_S0A		(1<<30)
+#define SYS_PINFUNC_S1A		(1<<29)
+#define SYS_PINFUNC_LP0		(1<<28)
+#define SYS_PINFUNC_LP1		(1<<27)
+#define SYS_PINFUNC_LD16	(1<<26)
+#define SYS_PINFUNC_LD8		(1<<25)
+#define SYS_PINFUNC_LD1		(1<<24)
+#define SYS_PINFUNC_LD0		(1<<23)
+#define SYS_PINFUNC_P1A		(3<<21)
+#define SYS_PINFUNC_P1B		(1<<20)
+#define SYS_PINFUNC_FS3		(1<<19)
+#define SYS_PINFUNC_P0A		(3<<17)
+#define SYS_PINFUNC_CS		(1<<16)
+#define SYS_PINFUNC_CIM		(1<<15)
+#define SYS_PINFUNC_P1C		(1<<14)
+#define SYS_PINFUNC_U1T		(1<<12)
+#define SYS_PINFUNC_U1R		(1<<11)
+#define SYS_PINFUNC_EX1		(1<<10)
+#define SYS_PINFUNC_EX0		(1<<9)
+#define SYS_PINFUNC_U0R		(1<<8)
+#define SYS_PINFUNC_MC		(1<<7)
+#define SYS_PINFUNC_S0B		(1<<6)
+#define SYS_PINFUNC_S0C		(1<<5)
+#define SYS_PINFUNC_P0B		(1<<4)
+#define SYS_PINFUNC_U0T		(1<<3)
+#define SYS_PINFUNC_S1B		(1<<2)
+#endif
+
 #define SYS_TRIOUTRD              0xB1900100
 #define SYS_TRIOUTCLR             0xB1900100
 #define SYS_OUTPUTRD              0xB1900108
@@ -1298,7 +1693,6 @@
 #define SD1_XMIT_FIFO	0xB0680000
 #define SD1_RECV_FIFO	0xB0680004
 
-
 #if defined (CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
@@ -1388,9 +1782,60 @@
 
 #endif
 
+#ifndef _LANGUAGE_ASSEMBLY
+typedef volatile struct
+{
+	/* 0x0000 */ u32 toytrim;
+	/* 0x0004 */ u32 toywrite;
+	/* 0x0008 */ u32 toymatch0;
+	/* 0x000C */ u32 toymatch1;
+	/* 0x0010 */ u32 toymatch2;
+	/* 0x0014 */ u32 cntrctrl;
+	/* 0x0018 */ u32 scratch0;
+	/* 0x001C */ u32 scratch1;
+	/* 0x0020 */ u32 freqctrl0;
+	/* 0x0024 */ u32 freqctrl1;
+	/* 0x0028 */ u32 clksrc;
+	/* 0x002C */ u32 pinfunc;
+	/* 0x0030 */ u32 reserved0;
+	/* 0x0034 */ u32 wakemsk;
+	/* 0x0038 */ u32 endian;
+	/* 0x003C */ u32 powerctrl;
+	/* 0x0040 */ u32 toyread;
+	/* 0x0044 */ u32 rtctrim;
+	/* 0x0048 */ u32 rtcwrite;
+	/* 0x004C */ u32 rtcmatch0;
+	/* 0x0050 */ u32 rtcmatch1;
+	/* 0x0054 */ u32 rtcmatch2;
+	/* 0x0058 */ u32 rtcread;
+	/* 0x005C */ u32 wakesrc;
+	/* 0x0060 */ u32 cpupll;
+	/* 0x0064 */ u32 auxpll;
+	/* 0x0068 */ u32 reserved1;
+	/* 0x006C */ u32 reserved2;
+	/* 0x0070 */ u32 reserved3;
+	/* 0x0074 */ u32 reserved4;
+	/* 0x0078 */ u32 slppwr;
+	/* 0x007C */ u32 sleep;
+	/* 0x0080 */ u32 reserved5[32];
+	/* 0x0100 */ u32 trioutrd;
+#define trioutclr trioutrd
+	/* 0x0104 */ u32 reserved6;
+	/* 0x0108 */ u32 outputrd;
+#define outputset outputrd
+	/* 0x010C */ u32 outputclr;
+	/* 0x0110 */ u32 pinstaterd;
+#define pininputen pinstaterd
+
+} AU1X00_SYS;
+
+static AU1X00_SYS* const sys  = (AU1X00_SYS *)SYS_BASE;
+
+#endif
 /* Processor information base on prid.
  * Copied from PowerPC.
  */
+#ifndef _LANGUAGE_ASSEMBLY
 struct cpu_spec {
 	/* CPU is matched via (PRID & prid_mask) == prid_value */
 	unsigned int	prid_mask;
@@ -1404,3 +1849,6 @@
 extern struct cpu_spec		cpu_specs[];
 extern struct cpu_spec		*cur_cpu_spec[];
 #endif
+
+#endif
+
diff -urN linux-2.4.30.old/include/asm-mips/au1000_pcmcia.h linux-2.4.30.dev/include/asm-mips/au1000_pcmcia.h
--- linux-2.4.30.old/include/asm-mips/au1000_pcmcia.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1000_pcmcia.h	2008-05-11 02:17:50.000000000 +0200
@@ -38,16 +38,41 @@
 #define AU1X_SOCK0_PHYS_MEM  0xF80000000
 
 /* pcmcia socket 1 needs external glue logic so the memory map
- * differs from board to board.
+ * differs from board to board. the general rule is that
+ * static bus address bit 26 should be used to decode socket 0
+ * from socket 1. alas, some boards dont follow this...
+ * These really belong in a board-specific header file...
  */
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
-#define AU1X_SOCK1_IO        0xF08000000
-#define AU1X_SOCK1_PHYS_ATTR 0xF48000000
-#define AU1X_SOCK1_PHYS_MEM  0xF88000000
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_PB1550) || defined(CONFIG_MIPS_DB1550)
-#define AU1X_SOCK1_IO        0xF04000000
-#define AU1X_SOCK1_PHYS_ATTR 0xF44000000
-#define AU1X_SOCK1_PHYS_MEM  0xF84000000
+#ifdef CONFIG_MIPS_PB1000
+#define SOCK1_DECODE (1<<27)
+#endif
+#ifdef CONFIG_MIPS_DB1000
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1500
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1100
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1550
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1200
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_PB1550
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_PB1200
+#define SOCK1_DECODE (1<<26)
+#endif
+
+/* The board has a second PCMCIA socket */
+#ifdef SOCK1_DECODE
+#define AU1X_SOCK1_IO        (0xF00000000|SOCK1_DECODE)
+#define AU1X_SOCK1_PHYS_ATTR (0xF40000000|SOCK1_DECODE)
+#define AU1X_SOCK1_PHYS_MEM  (0xF80000000|SOCK1_DECODE)
 #endif
 
 struct pcmcia_state {
diff -urN linux-2.4.30.old/include/asm-mips/au1100_mmc.h linux-2.4.30.dev/include/asm-mips/au1100_mmc.h
--- linux-2.4.30.old/include/asm-mips/au1100_mmc.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/au1100_mmc.h	2008-05-11 02:17:50.000000000 +0200
@@ -39,16 +39,22 @@
 #define __ASM_AU1100_MMC_H
 
 
-#define NUM_AU1100_MMC_CONTROLLERS	2
-
-
-#define AU1100_SD_IRQ	2
-
+#if defined(CONFIG_SOC_AU1100)
+#define NUM_MMC_CONTROLLERS	2
+#define AU1X_MMC_INT AU1100_SD_INT
+#endif
+
+#if defined(CONFIG_SOC_AU1200)
+#define NUM_MMC_CONTROLLERS	2
+#define AU1X_MMC_INT AU1200_SD_INT
+#endif
 
 #define SD0_BASE	0xB0600000
 #define SD1_BASE	0xB0680000
 
 
+
+
 /*
  *  Register offsets.
  */
@@ -201,5 +207,12 @@
 #define SD_CMD_RT_1B	(0x00810000)
 
 
+/* support routines required on a platform-specific basis */
+extern void mmc_card_inserted(int _n_, int *_res_);
+extern void mmc_card_writable(int _n_, int *_res_);
+extern void mmc_power_on(int _n_);
+extern void mmc_power_off(int _n_);
+
+
 #endif /* __ASM_AU1100_MMC_H */
 
diff -urN linux-2.4.30.old/include/asm-mips/bootinfo.h linux-2.4.30.dev/include/asm-mips/bootinfo.h
--- linux-2.4.30.old/include/asm-mips/bootinfo.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/bootinfo.h	2008-05-11 02:17:54.000000000 +0200
@@ -37,6 +37,7 @@
 #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
 #define MACH_GROUP_LASAT       21
 #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
+#define MACH_GROUP_BRCM		   23 /* Broadcom */
 
 /*
  * Valid machtype values for group unknown (low order halfword of mips_machtype)
@@ -180,6 +181,9 @@
 #define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
 #define MACH_CSB250		8	/* Cogent Au1500 */
 #define MACH_PB1550     	9       /* Au1550-based eval board */
+#define MACH_PB1200     	10      /* Au1200-based eval board */
+#define MACH_DB1550     	11      /* Au1550-based eval board */
+#define MACH_DB1200     	12      /* Au1200-based eval board */
 
 /*
  * Valid machtype for group NEC_VR41XX
@@ -194,6 +198,15 @@
 #define MACH_TANBAC_TB0229	7	/* TANBAC TB0229 (VR4131DIMM) */
 
 /*
+ * Valid machtypes for group Broadcom
+ */
+#define MACH_BCM93725          0
+#define MACH_BCM93725_VJ       1
+#define MACH_BCM93730          2
+#define MACH_BCM947XX          3
+#define MACH_BCM933XX          4
+
+/*
  * Valid machtype for group TITAN
  */
 #define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
diff -urN linux-2.4.30.old/include/asm-mips/cpu.h linux-2.4.30.dev/include/asm-mips/cpu.h
--- linux-2.4.30.old/include/asm-mips/cpu.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/cpu.h	2008-05-11 02:17:54.000000000 +0200
@@ -22,6 +22,11 @@
    spec.
 */
 
+#define PRID_COPT_MASK         0xff000000
+#define PRID_COMP_MASK         0x00ff0000
+#define PRID_IMP_MASK          0x0000ff00
+#define PRID_REV_MASK          0x000000ff
+
 #define PRID_COMP_LEGACY       0x000000
 #define PRID_COMP_MIPS         0x010000
 #define PRID_COMP_BROADCOM     0x020000
@@ -58,6 +63,7 @@
 #define PRID_IMP_RM7000		0x2700
 #define PRID_IMP_NEVADA		0x2800		/* RM5260 ??? */
 #define PRID_IMP_RM9000		0x3400
+#define PRID_IMP_BCM4710	0x4000
 #define PRID_IMP_R5432		0x5400
 #define PRID_IMP_R5500		0x5500
 #define PRID_IMP_4KC		0x8000
@@ -66,10 +72,16 @@
 #define PRID_IMP_4KEC		0x8400
 #define PRID_IMP_4KSC		0x8600
 #define PRID_IMP_25KF		0x8800
+#define PRID_IMP_BCM3302	0x9000
+#define PRID_IMP_BCM3303	0x9100
 #define PRID_IMP_24K		0x9300
 
 #define PRID_IMP_UNKNOWN	0xff00
 
+#define       BCM330X(id) \
+	(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) \
+	|| ((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
+
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_SIBYTE
  */
@@ -174,7 +186,9 @@
 #define CPU_AU1550		57
 #define CPU_24K			58
 #define CPU_AU1200		59
-#define CPU_LAST		59
+#define CPU_BCM4710		60
+#define CPU_BCM3302		61
+#define CPU_LAST		61
 
 /*
  * ISA Level encodings
diff -urN linux-2.4.30.old/include/asm-mips/db1x00.h linux-2.4.30.dev/include/asm-mips/db1x00.h
--- linux-2.4.30.old/include/asm-mips/db1x00.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/db1x00.h	2008-05-11 02:17:50.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * AMD Alchemy DB1x00 Reference Boards
+ * AMD Alchemy DB1x00 Reference Boards (BUT NOT DB1200)
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
@@ -36,9 +36,18 @@
 #define AC97_PSC_BASE       PSC1_BASE_ADDR
 #define SMBUS_PSC_BASE      PSC2_BASE_ADDR
 #define I2S_PSC_BASE        PSC3_BASE_ADDR
+#define NAND_CS 1
+/* for drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT AU1000_GPIO_3
+#define BOARD_PC1_INT AU1000_GPIO_5
+#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
 
 #else
 #define BCSR_KSEG1_ADDR 0xAE000000
+/* for drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT AU1000_GPIO_2
+#define BOARD_PC1_INT AU1000_GPIO_5
+#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
 #endif
 
 /*
@@ -66,6 +75,7 @@
 
 } BCSR;
 
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 
 /*
  * Register/mask bit definitions for the BCSRs
@@ -130,14 +140,6 @@
 
 #define BCSR_SWRESET_RESET		0x0080
 
-/* PCMCIA Db1x00 specific defines */
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
-
-/* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
-
 /* MTD CONFIG OPTIONS */
 #if defined(CONFIG_MTD_DB1X00_BOOT) && defined(CONFIG_MTD_DB1X00_USER)
 #define DB1X00_BOTH_BANKS
@@ -147,48 +149,15 @@
 #define DB1X00_USER_ONLY
 #endif
 
-/* SD controller macros */
-/*
- * Detect card.
- */
-#define mmc_card_inserted(_n_, _res_) \
-	do { \
-		BCSR * const bcsr = (BCSR *)0xAE000000; \
-		unsigned long mmc_wp, board_specific; \
-		if ((_n_)) { \
-			mmc_wp = BCSR_BOARD_SD1_WP; \
-		} else { \
-			mmc_wp = BCSR_BOARD_SD0_WP; \
-		} \
-		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
-		if (!(board_specific & mmc_wp)) {/* low means card present */ \
-			*(int *)(_res_) = 1; \
-		} else { \
-			*(int *)(_res_) = 0; \
-		} \
-	} while (0)
-
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX) && defined(CONFIG_MIPS_DB1550)
 /*
- * Apply power to card slot(s).
+ * Daughter card information.
  */
-#define mmc_power_on(_n_) \
-	do { \
-		BCSR * const bcsr = (BCSR *)0xAE000000; \
-		unsigned long mmc_pwr, mmc_wp, board_specific; \
-		if ((_n_)) { \
-			mmc_pwr = BCSR_BOARD_SD1_PWR; \
-			mmc_wp = BCSR_BOARD_SD1_WP; \
-		} else { \
-			mmc_pwr = BCSR_BOARD_SD0_PWR; \
-			mmc_wp = BCSR_BOARD_SD0_WP; \
-		} \
-		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
-		if (!(board_specific & mmc_wp)) {/* low means card present */ \
-			board_specific |= mmc_pwr; \
-			au_writel(board_specific, (int)(&bcsr->specific)); \
-			au_sync(); \
-		} \
-	} while (0)
+#define DAUGHTER_CARD_IRQ		(AU1000_GPIO_8)
+/* DC_IDE */
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C000000)
+#define AU1XXX_ATA_REG_OFFSET		(5)	
+#endif /* CONFIG_MIPS_DB1550 */
 
 #endif /* __ASM_DB1X00_H */
 
diff -urN linux-2.4.30.old/include/asm-mips/db1200.h linux-2.4.30.dev/include/asm-mips/db1200.h
--- linux-2.4.30.old/include/asm-mips/db1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/db1200.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+ * AMD Alchemy DB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_DB1200_H
+#define __ASM_DB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xB9800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+#define BCSR_RESETS_TV		0x0010
+/* not resets but in the same register */
+#define BCSR_RESETS_PWMR1mUX 0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+
+#define BCSR_LEDS_DECIMALS	0x0003
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x19000300)
+#define AU1XXX_SMC91111_IRQ			DB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x18800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			DB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x20000000
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the DB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define DB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define DB1200_IDE_INT			(DB1200_INT_BEGIN + 0)
+#define DB1200_ETH_INT			(DB1200_INT_BEGIN + 1)
+#define DB1200_PC0_INT			(DB1200_INT_BEGIN + 2)
+#define DB1200_PC0_STSCHG_INT	(DB1200_INT_BEGIN + 3)
+#define DB1200_PC1_INT			(DB1200_INT_BEGIN + 4)
+#define DB1200_PC1_STSCHG_INT	(DB1200_INT_BEGIN + 5)
+#define DB1200_DC_INT			(DB1200_INT_BEGIN + 6)
+#define DB1200_FLASHBUSY_INT	(DB1200_INT_BEGIN + 7)
+#define DB1200_PC0_INSERT_INT	(DB1200_INT_BEGIN + 8)
+#define DB1200_PC0_EJECT_INT	(DB1200_INT_BEGIN + 9)
+#define DB1200_PC1_INSERT_INT	(DB1200_INT_BEGIN + 10)
+#define DB1200_PC1_EJECT_INT	(DB1200_INT_BEGIN + 11)
+#define DB1200_SD0_INSERT_INT	(DB1200_INT_BEGIN + 12)
+#define DB1200_SD0_EJECT_INT	(DB1200_INT_BEGIN + 13)
+
+#define DB1200_INT_END			(DB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT DB1200_PC0_INT
+#define BOARD_PC1_INT DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_DB1200_H */
+
diff -urN linux-2.4.30.old/include/asm-mips/ficmmp.h linux-2.4.30.dev/include/asm-mips/ficmmp.h
--- linux-2.4.30.old/include/asm-mips/ficmmp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/ficmmp.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ * FIC MMP
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_FICMMP_H
+#define __ASM_FICMMP_H
+
+#include <linux/types.h>
+#include <asm/au1000.h>
+#include <asm/au1xxx_gpio.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+
+/*
+ * SMSC LAN91C111
+ */
+#define AU1XXX_SMC91111_PHYS_ADDR	(0xAC000300)
+#define AU1XXX_SMC91111_IRQ			AU1000_GPIO_5
+
+/* DC_IDE and DC_ETHERNET */
+#define FICMMP_IDE_INT	AU1000_GPIO_4
+
+#define AU1XXX_ATA_PHYS_ADDR	(0x0C800000)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+/*
+#define AU1XXX_ATA_BASE		(0x0C800000)
+#define AU1XXX_ATA_END			(0x0CFFFFFF)
+#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
+
+#define AU1XXX_ATA_REG_OFFSET		(5)
+*/
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+	
+#define FICMMP_CONFIG_BASE		0xAD000000
+#define FICMMP_CONFIG_ENABLE	13
+
+#define FICMMP_CONFIG_I2SFREQ(N)	(N<<0)
+#define FICMMP_CONFIG_I2SXTAL0		(1<<0)
+#define FICMMP_CONFIG_I2SXTAL1		(1<<1)
+#define FICMMP_CONFIG_I2SXTAL2		(1<<2)
+#define FICMMP_CONFIG_I2SXTAL3		(1<<3)
+#define FICMMP_CONFIG_ADV1			(1<<4)
+#define FICMMP_CONFIG_IDERST		(1<<5)
+#define FICMMP_CONFIG_LCMEN			(1<<6)
+#define FICMMP_CONFIG_CAMPWDN		(1<<7)
+#define FICMMP_CONFIG_USBPWREN		(1<<8)
+#define FICMMP_CONFIG_LCMPWREN		(1<<9)
+#define FICMMP_CONFIG_TVOUTPWREN	(1<<10)
+#define FICMMP_CONFIG_RS232PWREN	(1<<11)
+#define FICMMP_CONFIG_LCMDATAOUT	(1<<12)
+#define FICMMP_CONFIG_TVODATAOUT	(1<<13)
+#define FICMMP_CONFIG_ADV3			(1<<14)
+#define FICMMP_CONFIG_ADV4			(1<<15)
+
+#define I2S_FREQ_8_192				(0x0)
+#define I2S_FREQ_11_2896			(0x1)
+#define I2S_FREQ_12_288				(0x2)
+#define I2S_FREQ_24_576				(0x3)
+//#define I2S_FREQ_12_288			(0x4)
+#define I2S_FREQ_16_9344			(0x5)
+#define I2S_FREQ_18_432				(0x6)
+#define I2S_FREQ_36_864				(0x7)
+#define I2S_FREQ_16_384				(0x8)
+#define I2S_FREQ_22_5792			(0x9)
+//#define I2S_FREQ_24_576			(0x10)
+#define I2S_FREQ_49_152				(0x11)
+//#define I2S_FREQ_24_576			(0x12)
+#define I2S_FREQ_33_8688			(0x13)
+//#define I2S_FREQ_36_864			(0x14)
+#define I2S_FREQ_73_728				(0x15)
+
+#define FICMMP_IDE_PWR				9
+#define FICMMP_FOCUS_RST			2
+
+static __inline void ficmmp_config_set(u16 bits)
+{
+	extern u16 ficmmp_config;
+	//printk("set_config: %X, Old: %X, New: %X\n", bits, ficmmp_config, ficmmp_config | bits);
+	ficmmp_config |= bits;
+	*((u16*)FICMMP_CONFIG_BASE) = ficmmp_config;
+}
+
+static __inline void ficmmp_config_clear(u16 bits)
+{
+	extern u16 ficmmp_config;
+//	printk("clear_config: %X, Old: %X, New: %X\n", bits, ficmmp_config, ficmmp_config & ~bits);
+	ficmmp_config &= ~bits;
+	*((u16*)FICMMP_CONFIG_BASE) = ficmmp_config;
+}
+
+static __inline void ficmmp_config_init(void)
+{
+	au1xxx_gpio_write(FICMMP_CONFIG_ENABLE, 0);	//Enable configuration latch
+	ficmmp_config_set(FICMMP_CONFIG_LCMDATAOUT | FICMMP_CONFIG_TVODATAOUT | FICMMP_CONFIG_IDERST);  //Disable display data buffers
+	ficmmp_config_set(FICMMP_CONFIG_I2SFREQ(I2S_FREQ_36_864));
+}
+
+static __inline u32 ficmmp_set_i2s_sample_rate(u32 rate)
+{
+	u32 freq;
+	
+	switch(rate)
+	{
+	case 88200: 
+	case 44100:
+	case  8018: freq = I2S_FREQ_11_2896; break;
+	case 48000:
+	case 32000: //freq = I2S_FREQ_18_432; break;
+	case  8000: freq = I2S_FREQ_12_288; break;
+	default:    freq = I2S_FREQ_12_288; rate = 8000; 
+	}
+	ficmmp_config_clear(FICMMP_CONFIG_I2SFREQ(0xF));
+	ficmmp_config_set(FICMMP_CONFIG_I2SFREQ(freq));
+	return rate;
+}
+
+#endif /* __ASM_FICMMP_H */
+
diff -urN linux-2.4.30.old/include/asm-mips/hazards.h linux-2.4.30.dev/include/asm-mips/hazards.h
--- linux-2.4.30.old/include/asm-mips/hazards.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/hazards.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle
+ * Copyright (C) 2003, 2004 Ralf Baechle
  */
 #ifndef _ASM_HAZARDS_H
 #define _ASM_HAZARDS_H
@@ -12,38 +12,185 @@
 
 #ifdef __ASSEMBLY__
 
+	.macro	_ssnop
+	sll	$0, $0, 1
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard						\
+
+#define mtc0_tlbw_hazard						\
+	.set	push;							\
+	.set	mips32;							\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
+#define tlbw_eret_hazard						\
 	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
 	.set	pop
+
 #else
-#define rm9000_tlb_hazard
+
+/*
+ * The taken branch will result in a two cycle penalty for the two killed
+ * instructions on R4000 / R4400.  Other processors only have a single cycle
+ * hazard so this is nice trick to have an optimal code for a range of
+ * processors.
+ */
+#define mtc0_tlbw_hazard						\
+	b	. + 8
+#define tlbw_eret_hazard
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+	.macro	ehb
+	sll	$0, $0, 3
+	.endm
+
+#define irq_enable_hazard						\
+	ehb		# irq_enable_hazard
+
+#define irq_disable_hazard						\
+	ehb		# irq_disable_hazard
+
 #else
 
+#define irq_enable_hazard
+#define irq_disable_hazard
+
+#endif
+
+#else /* __ASSEMBLY__ */
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard()						\
+
+#define mtc0_tlbw_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
+		".set\tmips0")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set\tmips32\n\t"					\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 #else
-#define rm9000_tlb_hazard() do { } while (0)
+
+/*
+ * Overkill warning ...
+ */
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+__asm__(
+	"	.macro	ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_enable_hazard")
+
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_disable_hazard")
+
+#elif defined(CONFIG_CPU_R10000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
+
+__asm__(
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()	do { } while (0)
+
+#else
+
+/*
+ * Default for classic MIPS processors.  Assume worst case hazards but don't
+ * care about the irq_enable_hazard - sooner or later the hardware will
+ * enable it and we don't care when exactly.
+ */
+
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	#						\n\t"
+	"	# There is a hazard but we do not care		\n\t"
+	"	#						\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	_ssnop; _ssnop; _ssnop				\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+
 #endif
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* _ASM_HAZARDS_H */
diff -urN linux-2.4.30.old/include/asm-mips/mipsregs.h linux-2.4.30.dev/include/asm-mips/mipsregs.h
--- linux-2.4.30.old/include/asm-mips/mipsregs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/mipsregs.h	2008-05-11 02:17:50.000000000 +0200
@@ -757,10 +757,18 @@
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
@@ -874,42 +882,34 @@
  */
 static inline void tlb_probe(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbp\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_read(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_indexed(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwi\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_random(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 /*
diff -urN linux-2.4.30.old/include/asm-mips/mmu_context.h linux-2.4.30.dev/include/asm-mips/mmu_context.h
--- linux-2.4.30.old/include/asm-mips/mmu_context.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/mmu_context.h	2008-05-11 02:17:50.000000000 +0200
@@ -27,7 +27,7 @@
 #define TLBMISS_HANDLER_SETUP_PGD(pgd) \
 	pgd_current[smp_processor_id()] = (unsigned long)(pgd)
 #define TLBMISS_HANDLER_SETUP() \
-	write_c0_context((unsigned long) smp_processor_id() << (23 + 3)); \
+	write_c0_context((unsigned long) smp_processor_id() << 23); \
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 extern unsigned long pgd_current[];
 
diff -urN linux-2.4.30.old/include/asm-mips/mv64340.h linux-2.4.30.dev/include/asm-mips/mv64340.h
--- linux-2.4.30.old/include/asm-mips/mv64340.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips/mv64340.h	2008-05-11 02:17:53.000000000 +0200
@@ -718,7 +718,7 @@
 #define MV64340_ETH_RX_FIFO_URGENT_THRESHOLD_REG(port)             (0x2470 + (port<<10))
 #define MV64340_ETH_TX_FIFO_URGENT_THRESHOLD_REG(port)             (0x2474 + (port<<10))
 #define MV64340_ETH_RX_MINIMAL_FRAME_SIZE_REG(port)                (0x247c + (port<<10))
-#define MV64340_ETH_RX_DISCARDED_FRAMES_COUNTER(port)              (0x2484 + (port<<10)
+#define MV64340_ETH_RX_DISCARDED_FRAMES_COUNTER(port)              (0x2484 + (port<<10))
 #define MV64340_ETH_PORT_DEBUG_0_REG(port)                         (0x248c + (port<<10))
 #define MV64340_ETH_PORT_DEBUG_1_REG(port)                         (0x2490 + (port<<10))
 #define MV64340_ETH_PORT_INTERNAL_ADDR_ERROR_REG(port)             (0x2494 + (port<<10))
diff -urN linux-2.4.30.old/include/asm-mips/page.h linux-2.4.30.dev/include/asm-mips/page.h
--- linux-2.4.30.old/include/asm-mips/page.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/page.h	2008-05-11 02:17:53.000000000 +0200
@@ -77,13 +77,16 @@
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
+    #define __pte(x)	({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
   #else
     typedef struct { unsigned long long pte_low; } pte_t;
     #define pte_val(x)    ((x).pte_low)
+    #define __pte(x)	((pte_t) { (x) } )
   #endif
 #else
 typedef struct { unsigned long pte_low; } pte_t;
 #define pte_val(x)    ((x).pte_low)
+#define __pte(x)	((pte_t) { (x) } )
 #endif
 
 typedef struct { unsigned long pmd; } pmd_t;
@@ -96,7 +99,6 @@
 
 #define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
 
-#define __pte(x)	((pte_t) { (x) } )
 #define __pmd(x)	((pmd_t) { (x) } )
 #define __pgd(x)	((pgd_t) { (x) } )
 #define __pgprot(x)	((pgprot_t) { (x) } )
diff -urN linux-2.4.30.old/include/asm-mips/param.h linux-2.4.30.dev/include/asm-mips/param.h
--- linux-2.4.30.old/include/asm-mips/param.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/param.h	2008-05-11 02:17:51.000000000 +0200
@@ -55,7 +55,7 @@
 #endif /* defined(__KERNEL__)  */
 #endif /* defined(HZ)  */
 
-#define EXEC_PAGESIZE	65536
+#define EXEC_PAGESIZE	4096
 
 #ifndef NGROUPS
 #define NGROUPS		32
diff -urN linux-2.4.30.old/include/asm-mips/pb1100.h linux-2.4.30.dev/include/asm-mips/pb1100.h
--- linux-2.4.30.old/include/asm-mips/pb1100.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips/pb1100.h	2008-05-11 02:17:50.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * Alchemy Semi PB1100 Referrence Board
+ * AMD Alchemy PB1100 Reference Boards
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
@@ -27,55 +27,108 @@
 #ifndef __ASM_PB1100_H
 #define __ASM_PB1100_H
 
-#define PB1100_IDENT          0xAE000000
-#define BOARD_STATUS_REG      0xAE000004
-  #define PB1100_ROM_SEL         (1<<15)
-  #define PB1100_ROM_SIZ         (1<<14)
-  #define PB1100_SWAP_BOOT       (1<<13)
-  #define PB1100_FLASH_WP        (1<<12)
-  #define PB1100_ROM_H_STS       (1<<11)
-  #define PB1100_ROM_L_STS       (1<<10)
-  #define PB1100_FLASH_H_STS      (1<<9)
-  #define PB1100_FLASH_L_STS      (1<<8)
-  #define PB1100_SRAM_SIZ         (1<<7)
-  #define PB1100_TSC_BUSY         (1<<6)
-  #define PB1100_PCMCIA_VS_MASK   (3<<4)
-  #define PB1100_RS232_CD         (1<<3)
-  #define PB1100_RS232_CTS        (1<<2)
-  #define PB1100_RS232_DSR        (1<<1)
-  #define PB1100_RS232_RI         (1<<0)
-
-#define PB1100_IRDA_RS232     0xAE00000C
-  #define PB1100_IRDA_FULL       (0<<14) /* full power */
-  #define PB1100_IRDA_SHUTDOWN   (1<<14)
-  #define PB1100_IRDA_TT         (2<<14) /* 2/3 power */
-  #define PB1100_IRDA_OT         (3<<14) /* 1/3 power */
-  #define PB1100_IRDA_FIR        (1<<13)
-
-#define PCMCIA_BOARD_REG     0xAE000010
-  #define PB1100_SD_WP1_RO       (1<<15) /* read only */
-  #define PB1100_SD_WP0_RO       (1<<14) /* read only */
-  #define PB1100_SD_PWR1         (1<<11) /* applies power to SD1 */
-  #define PB1100_SD_PWR0         (1<<10) /* applies power to SD0 */
-  #define PB1100_SEL_SD_CONN1     (1<<9)
-  #define PB1100_SEL_SD_CONN0     (1<<8)
-  #define PC_DEASSERT_RST         (1<<7)
-  #define PC_DRV_EN               (1<<4)
-
-#define PB1100_G_CONTROL      0xAE000014 /* graphics control */
-
-#define PB1100_RST_VDDI       0xAE00001C
-  #define PB1100_SOFT_RESET      (1<<15) /* clear to reset the board */
-  #define PB1100_VDDI_MASK        (0x1F)
+#define BCSR_KSEG1_ADDR 0xAE000000
+
+/*
+ * Overlay data structure of the Pb1100 board registers.
+ * Registers located at physical 0E0000xx, KSEG1 0xAE0000xx
+ */
+typedef volatile struct
+{
+	/*00*/	unsigned short whoami;
+			unsigned short reserved0;
+	/*04*/	unsigned short status;
+			unsigned short reserved1;
+	/*08*/	unsigned short switches;
+			unsigned short reserved2;
+	/*0C*/	unsigned short resets;
+			unsigned short reserved3;
+	/*10*/	unsigned short pcmcia;
+			unsigned short reserved4;
+	/*14*/	unsigned short graphics; 
+			unsigned short reserved5;
+	/*18*/	unsigned short leds;
+			unsigned short reserved6;
+	/*1C*/	unsigned short swreset;
+			unsigned short reserved7;
+
+} BCSR;
 
-#define PB1100_LEDS           0xAE000018
 
-/* 11:8 is 4 discreet LEDs. Clearing a bit illuminates the LED.
- * 7:0 is the LED Display's decimal points.
+/*
+ * Register/mask bit definitions for the BCSRs
  */
-#define PB1100_HEX_LED        0xAE000018
+#define BCSR_WHOAMI_DCID		0x000F	
+#define BCSR_WHOAMI_CPLD		0x00F0
+#define BCSR_WHOAMI_BOARD		0x0F00 
+
+#define BCSR_STATUS_RS232_RI	    	0x0001 
+#define BCSR_STATUS_RS232_DSR	 	0x0002 
+#define BCSR_STATUS_RS232_CTS    	0x0004	
+#define BCSR_STATUS_RS232_CD	   	0x0008	 
+#define BCSR_STATUS_PCMCIA_VS_MASK  	0x0030 
+#define BCSR_STATUS_TSC_BUSY        	0x0040 
+#define BCSR_STATUS_SRAM_SIZ		0x0080 
+#define BCSR_STATUS_FLASH_L_STS 	0x0100 
+#define BCSR_STATUS_FLASH_H_STS 	0x0200	
+#define BCSR_STATUS_ROM_H_STS   	0x0400 
+#define BCSR_STATUS_ROM_L_STS   	0x0800	
+#define BCSR_STATUS_FLASH_WP	    	0x1000 
+#define BCSR_STATUS_SWAP_BOOT		0x2000
+#define BCSR_STATUS_ROM_SIZ    		0x4000 
+#define BCSR_STATUS_ROM_SEL      	0x8000	
+
+#define BCSR_SWITCHES_DIP		0x00FF
+#define BCSR_SWITCHES_DIP_1		0x0080
+#define BCSR_SWITCHES_DIP_2		0x0040
+#define BCSR_SWITCHES_DIP_3		0x0020
+#define BCSR_SWITCHES_DIP_4		0x0010
+#define BCSR_SWITCHES_DIP_5		0x0008
+#define BCSR_SWITCHES_DIP_6		0x0004
+#define BCSR_SWITCHES_DIP_7		0x0002
+#define BCSR_SWITCHES_DIP_8		0x0001
+#define BCSR_SWITCHES_ROTARY    	0x0F00
+#define BCSR_SWITCHES_SDO_CL     	0x8000
+
+#define BCSR_RESETS_PHY0		0x0001
+#define BCSR_RESETS_PHY1		0x0002
+#define BCSR_RESETS_DC			0x0004
+#define BCSR_RESETS_RS232_RTS		0x0100
+#define BCSR_RESETS_RS232_DTR   	0x0200
+#define BCSR_RESETS_FIR_SEL		0x2000
+#define BCSR_RESETS_IRDA_MODE_MASK	0xC000
+#define BCSR_RESETS_IRDA_MODE_FULL	0x0000
+#define BCSR_RESETS_IRDA_MODE_OFF	0x4000
+#define BCSR_RESETS_IRDA_MODE_2_3	0x8000
+#define BCSR_RESETS_IRDA_MODE_1_3	0xC000
+
+#define BCSR_PCMCIA_PC0VPP		0x0003
+#define BCSR_PCMCIA_PC0VCC		0x000C
+#define BCSR_PCMCIA_PC0_DR_VEN		0x0010
+#define BCSR_PCMCIA_PC0RST		0x0080
+#define BCSR_PCMCIA_SEL_SD_CON0   	0x0100
+#define BCSR_PCMCIA_SEL_SD_CON1   	0x0200
+#define BCSR_PCMCIA_SD0_PWR		0x0400
+#define BCSR_PCMCIA_SD1_PWR		0x0800
+#define BCSR_PCMCIA_SD0_WP		0x4000
+#define BCSR_PCMCIA_SD1_WP		0x8000
+
+#define PB1100_G_CONTROL		0xAE000014
+#define BCSR_GRAPHICS_GPX_SMPASS    	0x0010
+#define BCSR_GRAPHICS_GPX_BIG_ENDIAN	0x0020
+#define BCSR_GRAPHICS_GPX_RST		0x0040
+
+#define BCSR_LEDS_DECIMALS		0x00FF
+#define BCSR_LEDS_LED0			0x0100
+#define BCSR_LEDS_LED1			0x0200
+#define BCSR_LEDS_LED2			0x0400
+#define BCSR_LEDS_LED3			0x0800
+
+#define BCSR_SWRESET_RESET		0x0080
+#define BCSR_VDDI_VDI			0x001F
 
-/* PCMCIA PB1100 specific defines */
+
+ /* PCMCIA Pb1x00 specific defines */
 #define PCMCIA_MAX_SOCK 0
 #define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
 
@@ -83,3 +136,4 @@
 #define SET_VCC_VPP(VCC, VPP) (((VCC)<<2) | ((VPP)<<0))
 
 #endif /* __ASM_PB1100_H */
+
diff -urN linux-2.4.30.old/include/asm-mips/pb1200.h linux-2.4.30.dev/include/asm-mips/pb1200.h
--- linux-2.4.30.old/include/asm-mips/pb1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/pb1200.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,244 @@
+/*
+ * AMD Alchemy PB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1200_H
+#define __ASM_PB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xAD800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_SD1WP		0x0800
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+/* not resets but in the same register */
+#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_SD1MUX  0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+#define BCSR_BOARD_SD1PWR	0x0080
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+#define BCSR_INT_SD1INSERT	0x4000
+#define BCSR_INT_SD1EJECT	0x8000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0D000300)
+#define AU1XXX_SMC91111_IRQ			PB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			PB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x1C000000
+
+/* Timing values as described in databook, * ns value stripped of
+ * lower 2 bits.
+ * These defines are here rather than an SOC1200 generic file because
+ * the parts chosen on another board may be different and may require
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the PB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define PB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define PB1200_IDE_INT			(PB1200_INT_BEGIN + 0)
+#define PB1200_ETH_INT			(PB1200_INT_BEGIN + 1)
+#define PB1200_PC0_INT			(PB1200_INT_BEGIN + 2)
+#define PB1200_PC0_STSCHG_INT	(PB1200_INT_BEGIN + 3)
+#define PB1200_PC1_INT			(PB1200_INT_BEGIN + 4)
+#define PB1200_PC1_STSCHG_INT	(PB1200_INT_BEGIN + 5)
+#define PB1200_DC_INT			(PB1200_INT_BEGIN + 6)
+#define PB1200_FLASHBUSY_INT	(PB1200_INT_BEGIN + 7)
+#define PB1200_PC0_INSERT_INT	(PB1200_INT_BEGIN + 8)
+#define PB1200_PC0_EJECT_INT	(PB1200_INT_BEGIN + 9)
+#define PB1200_PC1_INSERT_INT	(PB1200_INT_BEGIN + 10)
+#define PB1200_PC1_EJECT_INT	(PB1200_INT_BEGIN + 11)
+#define PB1200_SD0_INSERT_INT	(PB1200_INT_BEGIN + 12)
+#define PB1200_SD0_EJECT_INT	(PB1200_INT_BEGIN + 13)
+#define PB1200_SD1_INSERT_INT	(PB1200_INT_BEGIN + 14)
+#define PB1200_SD1_EJECT_INT	(PB1200_INT_BEGIN + 15)
+
+#define PB1200_INT_END			(PB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT PB1200_PC0_INT
+#define BOARD_PC1_INT PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_PB1200_H */
+
diff -urN linux-2.4.30.old/include/asm-mips/pb1550.h linux-2.4.30.dev/include/asm-mips/pb1550.h
--- linux-2.4.30.old/include/asm-mips/pb1550.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/pb1550.h	2008-05-11 02:17:50.000000000 +0200
@@ -30,13 +30,11 @@
 
 #define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
 #define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC3_TX
-#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC3_RX
-
 #define SPI_PSC_BASE        PSC0_BASE_ADDR
 #define AC97_PSC_BASE       PSC1_BASE_ADDR
 #define SMBUS_PSC_BASE      PSC2_BASE_ADDR
 #define I2S_PSC_BASE        PSC3_BASE_ADDR
+#define NAND_CS 1
 
 #define BCSR_PHYS_ADDR 0xAF000000
 
@@ -160,9 +158,23 @@
 #define NAND_T_SU_SHIFT		8
 #define NAND_T_WH_SHIFT		12
 
-#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
-			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
-			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
-			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+#define NAND_TIMING	((NAND_T_H   & 0xF) << NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF) << NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF) << NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF) << NAND_T_WH_SHIFT)
+
+/*
+ * Daughter card information.
+ */
+#define DAUGHTER_CARD_BASE		(0xAC000000)
+#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
+#define DAUGHTER_CARD_IRQ		(AU1000_GPIO_3)
+
+/* DC_IDE and DC_ETHERNET */
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C000000)
+#define AU1XXX_ATA_REG_OFFSET		(5)	
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0C000300)
+#define AU1XXX_SMC91111_IRQ		AU1000_GPIO_3
 
 #endif /* __ASM_PB1550_H */
diff -urN linux-2.4.30.old/include/asm-mips/ptrace.h linux-2.4.30.dev/include/asm-mips/ptrace.h
--- linux-2.4.30.old/include/asm-mips/ptrace.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/ptrace.h	2008-05-11 02:17:52.000000000 +0200
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 by Ralf Baechle
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  * Machine dependent structs and defines to help the user use
  * the ptrace system call.
@@ -64,12 +65,10 @@
         "sw\t$22,"__str(PT_R22)"($29)\n\t"                              \
         "sw\t$23,"__str(PT_R23)"($29)\n\t"                              \
         "sw\t$30,"__str(PT_R30)"($29)\n\t"                              \
+       "j\t_" #symbol "\n\t"                                           \
         ".end\t" #symbol "\n\t"                                         \
         ".size\t" #symbol",. - " #symbol)
 
-/* Used in declaration of save_static functions.  */
-#define static_unused static __attribute__((unused))
-
 #endif /* !__ASSEMBLY__ */
 
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
diff -urN linux-2.4.30.old/include/asm-mips/r4kcache.h linux-2.4.30.dev/include/asm-mips/r4kcache.h
--- linux-2.4.30.old/include/asm-mips/r4kcache.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/r4kcache.h	2008-05-11 02:17:54.000000000 +0200
@@ -15,6 +15,18 @@
 #include <asm/asm.h>
 #include <asm/cacheops.h>
 
+#ifdef CONFIG_BCM4710
+#define BCM4710_DUMMY_RREG() (((sbconfig_t *)(KSEG1ADDR(SB_ENUM_BASE + SBCONFIGOFF)))->sbimstate)
+
+#define BCM4710_FILL_TLB(addr) (*(volatile unsigned long *)(addr))
+#define BCM4710_PROTECTED_FILL_TLB(addr) ({ unsigned long x; get_dbe(x, (volatile unsigned long *)(addr)); })
+#else
+#define BCM4710_DUMMY_RREG()
+
+#define BCM4710_FILL_TLB(addr)
+#define BCM4710_PROTECTED_FILL_TLB(addr)
+#endif
+
 #define cache_op(op,addr)						\
 	__asm__ __volatile__(						\
 	"	.set	noreorder				\n"	\
@@ -27,12 +39,25 @@
 
 static inline void flush_icache_line_indexed(unsigned long addr)
 {
-	cache_op(Index_Invalidate_I, addr);
+	unsigned int way;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	
+	for (way = 0; way < current_cpu_data.dcache.ways; way++) {
+		cache_op(Index_Invalidate_I, addr);
+		addr += ws_inc;
+	}
 }
 
 static inline void flush_dcache_line_indexed(unsigned long addr)
 {
-	cache_op(Index_Writeback_Inv_D, addr);
+	unsigned int way;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	
+	for (way = 0; way < current_cpu_data.dcache.ways; way++) {
+		BCM4710_DUMMY_RREG();
+		cache_op(Index_Writeback_Inv_D, addr);
+		addr += ws_inc;
+	}
 }
 
 static inline void flush_scache_line_indexed(unsigned long addr)
@@ -47,6 +72,7 @@
 
 static inline void flush_dcache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	cache_op(Hit_Writeback_Inv_D, addr);
 }
 
@@ -91,6 +117,7 @@
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		".set mips3\n"
@@ -138,6 +165,62 @@
 		: "r" (base),						\
 		  "i" (op));
 
+#define cache_unroll(base,op)                   \
+	__asm__ __volatile__("                  \
+		.set noreorder;                 \
+		.set mips3;                     \
+		cache %1, (%0);                 \
+		.set mips0;                     \
+		.set reorder"                   \
+		:                               \
+		: "r" (base),                   \
+		  "i" (op));
+
+
+static inline void blast_dcache(void)
+{
+	unsigned long start = KSEG0;
+	unsigned long dcache_size = current_cpu_data.dcache.waysize * current_cpu_data.dcache.ways;
+	unsigned long end = (start + dcache_size);
+
+	while(start < end) {
+		BCM4710_DUMMY_RREG();
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += current_cpu_data.dcache.linesz;
+	}
+}
+
+static inline void blast_dcache_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+
+	BCM4710_FILL_TLB(start);
+	do {
+		BCM4710_DUMMY_RREG();
+		cache_unroll(start,Hit_Writeback_Inv_D);
+		start += current_cpu_data.dcache.linesz;
+	} while (start < end);
+}
+
+static inline void blast_dcache_page_indexed(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+
+	for (ws = 0; ws < ws_end; ws += ws_inc) {
+		start = page + ws;
+		for (addr = start; addr < end; addr += current_cpu_data.dcache.linesz) {
+			BCM4710_DUMMY_RREG();
+			cache_unroll(addr,Index_Writeback_Inv_D);
+		}
+	}	
+}
+
 static inline void blast_dcache16(void)
 {
 	unsigned long start = KSEG0;
@@ -148,8 +231,9 @@
 	unsigned long ws, addr;
 
 	for (ws = 0; ws < ws_end; ws += ws_inc) 
-		for (addr = start; addr < end; addr += 0x200)
+		for (addr = start; addr < end; addr += 0x200) {
 			cache16_unroll32(addr|ws,Index_Writeback_Inv_D);
+		}
 }
 
 static inline void blast_dcache16_page(unsigned long page)
@@ -173,8 +257,9 @@
 	unsigned long ws, addr;
 
 	for (ws = 0; ws < ws_end; ws += ws_inc) 
-		for (addr = start; addr < end; addr += 0x200) 
+		for (addr = start; addr < end; addr += 0x200) {
 			cache16_unroll32(addr|ws,Index_Writeback_Inv_D);
+		}
 }
 
 static inline void blast_icache16(void)
@@ -196,6 +281,7 @@
 	unsigned long start = page;
 	unsigned long end = start + PAGE_SIZE;
 
+	BCM4710_FILL_TLB(start);
 	do {
 		cache16_unroll32(start,Hit_Invalidate_I);
 		start += 0x200;
@@ -281,6 +367,7 @@
 		: "r" (base),						\
 		  "i" (op));
 
+
 static inline void blast_dcache32(void)
 {
 	unsigned long start = KSEG0;
@@ -291,8 +378,9 @@
 	unsigned long ws, addr;
 
 	for (ws = 0; ws < ws_end; ws += ws_inc) 
-		for (addr = start; addr < end; addr += 0x400) 
+		for (addr = start; addr < end; addr += 0x400) {
 			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+		}
 }
 
 static inline void blast_dcache32_page(unsigned long page)
@@ -316,8 +404,9 @@
 	unsigned long ws, addr;
 
 	for (ws = 0; ws < ws_end; ws += ws_inc) 
-		for (addr = start; addr < end; addr += 0x400) 
+		for (addr = start; addr < end; addr += 0x400) {
 			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+		}
 }
 
 static inline void blast_icache32(void)
@@ -339,6 +428,7 @@
 	unsigned long start = page;
 	unsigned long end = start + PAGE_SIZE;
 
+	BCM4710_FILL_TLB(start);
 	do {
 		cache32_unroll32(start,Hit_Invalidate_I);
 		start += 0x400;
@@ -443,6 +533,7 @@
 	unsigned long start = page;
 	unsigned long end = start + PAGE_SIZE;
 
+	BCM4710_FILL_TLB(start);
 	do {
 		cache64_unroll32(start,Hit_Invalidate_I);
 		start += 0x800;
@@ -567,4 +658,17 @@
 			cache128_unroll32(addr|ws,Index_Writeback_Inv_SD);
 }
 
+extern inline void fill_icache_line(unsigned long addr)
+{       
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".set mips3\n\t"
+		"cache %1, (%0)\n\t"
+		".set mips0\n\t"
+		".set reorder"
+		:
+		: "r" (addr),
+		"i" (Fill));
+}      
+
 #endif /* __ASM_R4KCACHE_H */
diff -urN linux-2.4.30.old/include/asm-mips/serial.h linux-2.4.30.dev/include/asm-mips/serial.h
--- linux-2.4.30.old/include/asm-mips/serial.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/serial.h	2008-05-11 02:17:54.000000000 +0200
@@ -223,6 +223,13 @@
 #define TXX927_SERIAL_PORT_DEFNS
 #endif
 
+#ifdef CONFIG_BCM947XX
+/* reserve 4 ports to be configured at runtime */
+#define BCM947XX_SERIAL_PORT_DEFNS { 0, }, { 0, }, { 0, }, { 0, },
+#else
+#define BCM947XX_SERIAL_PORT_DEFNS
+#endif
+
 #ifdef CONFIG_HAVE_STD_PC_SERIAL_PORT
 #define STD_SERIAL_PORT_DEFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
@@ -470,6 +477,7 @@
 #define SERIAL_PORT_DFNS			\
 	ATLAS_SERIAL_PORT_DEFNS			\
 	AU1000_SERIAL_PORT_DEFNS		\
+	BCM947XX_SERIAL_PORT_DEFNS		\
 	COBALT_SERIAL_PORT_DEFNS		\
 	DDB5477_SERIAL_PORT_DEFNS		\
 	EV96100_SERIAL_PORT_DEFNS		\
diff -urN linux-2.4.30.old/include/asm-mips/signal.h linux-2.4.30.dev/include/asm-mips/signal.h
--- linux-2.4.30.old/include/asm-mips/signal.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -111,6 +111,12 @@
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x02000000
 
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
+#endif
+
 #endif /* __KERNEL__ */
 
 #define SIG_BLOCK	1	/* for blocking signals */
diff -urN linux-2.4.30.old/include/asm-mips/stackframe.h linux-2.4.30.dev/include/asm-mips/stackframe.h
--- linux-2.4.30.old/include/asm-mips/stackframe.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/stackframe.h	2008-05-11 02:17:54.000000000 +0200
@@ -209,6 +209,20 @@
 
 #endif
 
+#if defined(CONFIG_BCM4710) || defined(CONFIG_BCM4704)
+
+#undef RESTORE_SP_AND_RET
+#define RESTORE_SP_AND_RET                               \
+		lw      sp,  PT_R29(sp);                 \
+		.set    mips3;                           \
+		nop;                                     \
+		nop;                                     \
+		eret;                                    \
+		.set    mips0
+
+#endif
+
+
 #define RESTORE_SP                                       \
 		lw	sp,  PT_R29(sp);                 \
 
diff -urN linux-2.4.30.old/include/asm-mips/timex.h linux-2.4.30.dev/include/asm-mips/timex.h
--- linux-2.4.30.old/include/asm-mips/timex.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips/timex.h	2008-05-11 02:17:54.000000000 +0200
@@ -31,6 +31,19 @@
 	return read_c0_count();
 }
 
+extern __u32 get_htscl(void);
+extern __u64 get_tscll(void);
+
+#define rdtsc(low, high) \
+		high = get_htscl(); \
+		low = read_c0_count();
+
+#define rdtscl(low) \
+		low = read_c0_count();
+
+#define rdtscll(val) \
+		val = get_tscll();
+
 #define vxtime_lock()		do {} while (0)
 #define vxtime_unlock()		do {} while (0)
 
diff -urN linux-2.4.30.old/include/asm-mips/tx4927/tx4927.h linux-2.4.30.dev/include/asm-mips/tx4927/tx4927.h
--- linux-2.4.30.old/include/asm-mips/tx4927/tx4927.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips/tx4927/tx4927.h	2008-05-11 02:17:50.000000000 +0200
@@ -88,8 +88,8 @@
 
 
 /* TX4927 Configuration registers (64-bit registers) */
-#define TX4927_CONFIG_BASE                       0xe300
-#define TX4927_CONFIG_CCFG                       0xe300
+#define TX4927_CONFIG_BASE                       0xe000
+#define TX4927_CONFIG_CCFG                       0xe000
 #define TX4927_CONFIG_CCFG_RESERVED_42_63                BM_63_42
 #define TX4927_CONFIG_CCFG_WDRST                         BM_41_41
 #define TX4927_CONFIG_CCFG_WDREXEN                       BM_40_40
@@ -124,14 +124,14 @@
 #define TX4927_CONFIG_CCFG_ENDIAN                        BM_02_02
 #define TX4927_CONFIG_CCFG_ARMODE                        BM_01_01
 #define TX4927_CONFIG_CCFG_ACEHOLD                       BM_00_00
-#define TX4927_CONFIG_REVID                      0xe308 
+#define TX4927_CONFIG_REVID                      0xe008 
 #define TX4927_CONFIG_REVID_RESERVED_32_63               BM_32_63
 #define TX4927_CONFIG_REVID_PCODE                        BM_16_31
 #define TX4927_CONFIG_REVID_MJERREV                      BM_12_15
 #define TX4927_CONFIG_REVID_MINEREV                      BM_08_11
 #define TX4927_CONFIG_REVID_MJREV                        BM_04_07
 #define TX4927_CONFIG_REVID_MINREV                       BM_00_03
-#define TX4927_CONFIG_PCFG                       0xe310 
+#define TX4927_CONFIG_PCFG                       0xe010 
 #define TX4927_CONFIG_PCFG_RESERVED_57_63                BM_57_63
 #define TX4927_CONFIG_PCFG_DRVDATA                       BM_56_56
 #define TX4927_CONFIG_PCFG_DRVCB                         BM_55_55
@@ -197,10 +197,10 @@
 #define TX4927_CONFIG_PCFG_DMASEL0_SIO1                  BM_00_00
 #define TX4927_CONFIG_PCFG_DMASEL0_ACLC0                 BM_01_01
 #define TX4927_CONFIG_PCFG_DMASEL0_ACLC2                 BM_00_01
-#define TX4927_CONFIG_TOEA                       0xe318 
+#define TX4927_CONFIG_TOEA                       0xe018 
 #define TX4927_CONFIG_TOEA_RESERVED_36_63                BM_36_63
 #define TX4927_CONFIG_TOEA_TOEA                          BM_00_35
-#define TX4927_CONFIG_CLKCTR                     0xe320 
+#define TX4927_CONFIG_CLKCTR                     0xe020 
 #define TX4927_CONFIG_CLKCTR_RESERVED_26_63              BM_26_63
 #define TX4927_CONFIG_CLKCTR_ACLCKD                      BM_25_25
 #define TX4927_CONFIG_CLKCTR_PIOCKD                      BM_24_24
@@ -223,7 +223,7 @@
 #define TX4927_CONFIG_CLKCTR_TM2RST                      BM_02_02
 #define TX4927_CONFIG_CLKCTR_SIO0RST                     BM_01_01
 #define TX4927_CONFIG_CLKCTR_SIO1RST                     BM_00_00
-#define TX4927_CONFIG_GARBC                      0xe330 
+#define TX4927_CONFIG_GARBC                      0xe030 
 #define TX4927_CONFIG_GARBC_RESERVED_10_63               BM_10_63
 #define TX4927_CONFIG_GARBC_SET_09                       BM_09_09
 #define TX4927_CONFIG_GARBC_ARBMD                        BM_08_08
@@ -243,7 +243,7 @@
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_PDMAC            BM_00_00
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_DMAC             BM_01_01
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_BAD_VALUE        BM_00_01
-#define TX4927_CONFIG_RAMP                       0xe348 
+#define TX4927_CONFIG_RAMP                       0xe048 
 #define TX4927_CONFIG_RAMP_RESERVED_20_63                BM_20_63
 #define TX4927_CONFIG_RAMP_RAMP                          BM_00_19
 #define TX4927_CONFIG_LIMIT                      0xefff
@@ -456,7 +456,7 @@
 #define TX4927_ACLC_ACINTSTS            0xf710
 #define TX4927_ACLC_ACINTMSTS           0xf714
 #define TX4927_ACLC_ACINTEN             0xf718
-#define TX4927_ACLC_ACINTDIS            0xfR71c
+#define TX4927_ACLC_ACINTDIS            0xf71c
 #define TX4927_ACLC_ACSEMAPH            0xf720
 #define TX4927_ACLC_ACGPIDAT            0xf740
 #define TX4927_ACLC_ACGPODAT            0xf744
diff -urN linux-2.4.30.old/include/asm-mips/uaccess.h linux-2.4.30.dev/include/asm-mips/uaccess.h
--- linux-2.4.30.old/include/asm-mips/uaccess.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/uaccess.h	2008-05-11 02:17:52.000000000 +0200
@@ -149,7 +149,7 @@
  * Returns zero on success, or -EFAULT on error.
  */
 #define put_user(x,ptr)	\
-	__put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__put_user_check((x),(ptr),sizeof(*(ptr)))
 
 /*
  * get_user: - Get a simple variable from user space.
@@ -169,7 +169,7 @@
  * On error, the variable @x is set to zero.
  */
 #define get_user(x,ptr) \
-	__get_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__get_user_check((x),(ptr),sizeof(*(ptr)))
 
 /*
  * __put_user: - Write a simple value into user space, with less checking.
@@ -191,7 +191,7 @@
  * Returns zero on success, or -EFAULT on error.
  */
 #define __put_user(x,ptr) \
-	__put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__put_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 /*
  * __get_user: - Get a simple variable from user space, with less checking.
@@ -214,7 +214,7 @@
  * On error, the variable @x is set to zero.
  */
 #define __get_user(x,ptr) \
-	__get_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 struct __large_struct { unsigned long buf[100]; };
 #define __m(x) (*(struct __large_struct *)(x))
@@ -232,7 +232,7 @@
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
 	long __gu_err = 0;						\
-	__typeof(*(ptr)) __gu_val = 0;					\
+	__typeof(*(ptr)) __gu_val = (__typeof(*(ptr))) 0;					\
 	long __gu_addr;							\
 	__gu_addr = (long) (ptr);					\
 	switch (size) {							\
diff -urN linux-2.4.30.old/include/asm-mips/unistd.h linux-2.4.30.dev/include/asm-mips/unistd.h
--- linux-2.4.30.old/include/asm-mips/unistd.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips/unistd.h	2008-05-11 02:17:50.000000000 +0200
@@ -760,7 +760,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 /*
@@ -788,7 +788,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall2(type,name,atype,a,btype,b) \
@@ -813,7 +813,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \
@@ -839,7 +839,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
@@ -865,7 +865,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #if (_MIPS_SIM == _MIPS_SIM_ABI32)
@@ -902,7 +902,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -935,7 +935,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
@@ -966,7 +966,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -995,7 +995,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
diff -urN linux-2.4.30.old/include/asm-mips64/hazards.h linux-2.4.30.dev/include/asm-mips64/hazards.h
--- linux-2.4.30.old/include/asm-mips64/hazards.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips64/hazards.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle
+ * Copyright (C) 2003, 2004 Ralf Baechle
  */
 #ifndef _ASM_HAZARDS_H
 #define _ASM_HAZARDS_H
@@ -12,37 +12,185 @@
 
 #ifdef __ASSEMBLY__
 
+	.macro	_ssnop
+	sll	$0, $0, 1
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard						\
+
+#define mtc0_tlbw_hazard						\
+	.set	push;							\
+	.set	mips32;							\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
+#define tlbw_eret_hazard						\
+	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
-	.set	mips0
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
 #else
-#define rm9000_tlb_hazard
+
+/*
+ * The taken branch will result in a two cycle penalty for the two killed
+ * instructions on R4000 / R4400.  Other processors only have a single cycle
+ * hazard so this is nice trick to have an optimal code for a range of
+ * processors.
+ */
+#define mtc0_tlbw_hazard						\
+	b	. + 8
+#define tlbw_eret_hazard
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+	.macro	ehb
+	sll	$0, $0, 3
+	.endm
+
+#define irq_enable_hazard						\
+	ehb		# irq_enable_hazard
+
+#define irq_disable_hazard						\
+	ehb		# irq_disable_hazard
+
 #else
 
+#define irq_enable_hazard
+#define irq_disable_hazard
+
+#endif
+
+#else /* __ASSEMBLY__ */
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard()						\
+
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set\tmips32\n\t"					\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
+		".set\tmips0")
+
+#define tlbw_use_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 #else
-#define rm9000_tlb_hazard() do { } while (0)
+
+/*
+ * Overkill warning ...
+ */
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+__asm__(
+	"	.macro	ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_enable_hazard")
+
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_disable_hazard")
+
+#elif defined(CONFIG_CPU_R10000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
+
+__asm__(
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()	do { } while (0)
+
+#else
+
+/*
+ * Default for classic MIPS processors.  Assume worst case hazards but don't
+ * care about the irq_enable_hazard - sooner or later the hardware will
+ * enable it and we don't care when exactly.
+ */
+
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	#						\n\t"
+	"	# There is a hazard but we do not care		\n\t"
+	"	#						\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	_ssnop; _ssnop; _ssnop				\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+
 #endif
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* _ASM_HAZARDS_H */
diff -urN linux-2.4.30.old/include/asm-mips64/mipsregs.h linux-2.4.30.dev/include/asm-mips64/mipsregs.h
--- linux-2.4.30.old/include/asm-mips64/mipsregs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips64/mipsregs.h	2008-05-11 02:17:50.000000000 +0200
@@ -757,10 +757,18 @@
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
@@ -856,42 +864,34 @@
  */
 static inline void tlb_probe(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbp\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_read(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_indexed(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwi\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_random(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 /*
diff -urN linux-2.4.30.old/include/asm-mips64/mv64340.h linux-2.4.30.dev/include/asm-mips64/mv64340.h
--- linux-2.4.30.old/include/asm-mips64/mv64340.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips64/mv64340.h	2008-05-11 02:17:53.000000000 +0200
@@ -718,7 +718,7 @@
 #define MV64340_ETH_RX_FIFO_URGENT_THRESHOLD_REG(port)             (0x2470 + (port<<10))
 #define MV64340_ETH_TX_FIFO_URGENT_THRESHOLD_REG(port)             (0x2474 + (port<<10))
 #define MV64340_ETH_RX_MINIMAL_FRAME_SIZE_REG(port)                (0x247c + (port<<10))
-#define MV64340_ETH_RX_DISCARDED_FRAMES_COUNTER(port)              (0x2484 + (port<<10)
+#define MV64340_ETH_RX_DISCARDED_FRAMES_COUNTER(port)              (0x2484 + (port<<10))
 #define MV64340_ETH_PORT_DEBUG_0_REG(port)                         (0x248c + (port<<10))
 #define MV64340_ETH_PORT_DEBUG_1_REG(port)                         (0x2490 + (port<<10))
 #define MV64340_ETH_PORT_INTERNAL_ADDR_ERROR_REG(port)             (0x2494 + (port<<10))
diff -urN linux-2.4.30.old/include/asm-mips64/ptrace.h linux-2.4.30.dev/include/asm-mips64/ptrace.h
--- linux-2.4.30.old/include/asm-mips64/ptrace.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips64/ptrace.h	2008-05-11 02:17:52.000000000 +0200
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef _ASM_PTRACE_H
 #define _ASM_PTRACE_H
@@ -61,12 +62,10 @@
         "sd\t$22,"__str(PT_R22)"($29)\n\t"                              \
         "sd\t$23,"__str(PT_R23)"($29)\n\t"                              \
         "sd\t$30,"__str(PT_R30)"($29)\n\t"                              \
+        "j\t_" #symbol "\n\t"                                           \
         ".end\t" #symbol "\n\t"                                         \
         ".size\t" #symbol",. - " #symbol)
 
-/* Used in declaration of save_static functions.  */
-#define static_unused static __attribute__((unused))
-
 #define abi64_no_regargs						\
 	unsigned long __dummy0,						\
 	unsigned long __dummy1,						\
diff -urN linux-2.4.30.old/include/asm-mips64/signal.h linux-2.4.30.dev/include/asm-mips64/signal.h
--- linux-2.4.30.old/include/asm-mips64/signal.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-mips64/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -119,6 +119,12 @@
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x02000000
 
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
+#endif
+
 #endif /* __KERNEL__ */
 
 #define SIG_BLOCK	1	/* for blocking signals */
diff -urN linux-2.4.30.old/include/asm-mips64/sn/klconfig.h linux-2.4.30.dev/include/asm-mips64/sn/klconfig.h
--- linux-2.4.30.old/include/asm-mips64/sn/klconfig.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips64/sn/klconfig.h	2008-05-11 02:17:53.000000000 +0200
@@ -196,7 +196,7 @@
 			((__psunsigned_t)_k + (_k->ch_malloc_hdr_off)))
 #else
 #define PTR_CH_MALLOC_HDR(_k)   ((klc_malloc_hdr_t *)\
-			(unsigned long)_k + (_k->ch_malloc_hdr_off)))
+			((unsigned long)_k + (_k->ch_malloc_hdr_off)))
 #endif
 
 #define KL_CONFIG_CH_MALLOC_HDR(_n)   PTR_CH_MALLOC_HDR(KL_CONFIG_HDR(_n))
diff -urN linux-2.4.30.old/include/asm-mips64/unistd.h linux-2.4.30.dev/include/asm-mips64/unistd.h
--- linux-2.4.30.old/include/asm-mips64/unistd.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-mips64/unistd.h	2008-05-11 02:17:50.000000000 +0200
@@ -760,7 +760,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 /*
@@ -788,7 +788,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall2(type,name,atype,a,btype,b) \
@@ -813,7 +813,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \
@@ -839,7 +839,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
@@ -865,7 +865,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #if (_MIPS_SIM == _MIPS_SIM_ABI32)
@@ -902,7 +902,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -935,7 +935,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
@@ -966,7 +966,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -995,7 +995,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
diff -urN linux-2.4.30.old/include/asm-m68k/param.h linux-2.4.30.dev/include/asm-m68k/param.h
--- linux-2.4.30.old/include/asm-m68k/param.h	2001-01-04 22:00:55.000000000 +0100
+++ linux-2.4.30.dev/include/asm-m68k/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -urN linux-2.4.30.old/include/asm-m68k/setup.h linux-2.4.30.dev/include/asm-m68k/setup.h
--- linux-2.4.30.old/include/asm-m68k/setup.h	2000-01-26 21:44:21.000000000 +0100
+++ linux-2.4.30.dev/include/asm-m68k/setup.h	2008-05-11 02:17:53.000000000 +0200
@@ -361,12 +361,13 @@
 #ifndef __ASSEMBLY__
 extern int m68k_num_memory;		/* # of memory blocks found (and used) */
 extern int m68k_realnum_memory;		/* real # of memory blocks found */
-extern struct mem_info m68k_memory[NUM_MEMINFO];/* memory description */
 
 struct mem_info {
 	unsigned long addr;		/* physical address of memory chunk */
 	unsigned long size;		/* length of memory chunk (in bytes) */
 };
+
+extern struct mem_info m68k_memory[NUM_MEMINFO];/* memory description */
 #endif
 
 #endif /* __KERNEL__ */
diff -urN linux-2.4.30.old/include/asm-m68k/signal.h linux-2.4.30.dev/include/asm-m68k/signal.h
--- linux-2.4.30.old/include/asm-m68k/signal.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-m68k/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -116,8 +116,15 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0	/* for blocking signals */
 #define SIG_UNBLOCK        1	/* for unblocking signals */
 #define SIG_SETMASK        2	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-parisc/pdc.h linux-2.4.30.dev/include/asm-parisc/pdc.h
--- linux-2.4.30.old/include/asm-parisc/pdc.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-parisc/pdc.h	2008-05-11 02:17:53.000000000 +0200
@@ -1000,7 +1000,7 @@
 #define PAT_GET_ENTITY(value)	(((value) >> 56) & 0xffUL)
 #define PAT_GET_DVI(value)	(((value) >> 48) & 0xffUL)
 #define PAT_GET_IOC(value)	(((value) >> 40) & 0xffUL)
-#define PAT_GET_MOD_PAGES(value)(((value) & 0xffffffUL)
+#define PAT_GET_MOD_PAGES(value) ((value) & 0xffffffUL)
 
 #else /* !__LP64__ */
 /* No PAT support for 32-bit kernels...sorry */
diff -urN linux-2.4.30.old/include/asm-parisc/signal.h linux-2.4.30.dev/include/asm-parisc/signal.h
--- linux-2.4.30.old/include/asm-parisc/signal.h	2000-12-05 21:29:39.000000000 +0100
+++ linux-2.4.30.dev/include/asm-parisc/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -100,6 +100,12 @@
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
 
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
+#endif
+
 #endif /* __KERNEL__ */
 
 #define SIG_BLOCK          0	/* for blocking signals */
diff -urN linux-2.4.30.old/include/asm-ppc/byteorder.h linux-2.4.30.dev/include/asm-ppc/byteorder.h
--- linux-2.4.30.old/include/asm-ppc/byteorder.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/byteorder.h	2008-05-11 02:17:53.000000000 +0200
@@ -2,6 +2,7 @@
 #define _PPC_BYTEORDER_H
 
 #include <asm/types.h>
+#include <linux/compiler.h>
 
 #ifdef __GNUC__
 #ifdef __KERNEL__
@@ -50,7 +51,7 @@
 	__asm__ __volatile__ ("stwbrx  %1,0,%2" : "=m" (*addr) : "r" (val), "r" (taddr+4));
 }
 
-static __inline__ __const__ __u16 ___arch__swab16(__u16 value)
+static __inline__ __attribute_const__ __u16 ___arch__swab16(__u16 value)
 {
 	__u16 result;
 
@@ -58,7 +59,7 @@
 	return result;
 }
 
-static __inline__ __const__ __u32 ___arch__swab32(__u32 value)
+static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 value)
 {
 	__u32 result;
 
diff -urN linux-2.4.30.old/include/asm-ppc/m48t35.h linux-2.4.30.dev/include/asm-ppc/m48t35.h
--- linux-2.4.30.old/include/asm-ppc/m48t35.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/m48t35.h	2008-05-11 02:17:53.000000000 +0200
@@ -39,7 +39,7 @@
 #define M48T35_RTC_WATCHDOG_RB         0x03
 #define M48T35_RTC_WATCHDOG_BMB        0x7c
 #define M48T35_RTC_WATCHDOG_WDS        0x80
-#define M48T35_RTC_WATCHDOG_ALL        (M48T35_RTC_WATCHDOG_RB|M48T35_RTC_WATCHDOG_BMB|M48T35_RTC_W
+#define M48T35_RTC_WATCHDOG_ALL        (M48T35_RTC_WATCHDOG_RB|M48T35_RTC_WATCHDOG_BMB|M48T35_RTC_W)
 
 #define M48T35_RTC_CONTROL_WRITE       0x80
 #define M48T35_RTC_CONTROL_READ        0x40
diff -urN linux-2.4.30.old/include/asm-ppc/param.h linux-2.4.30.dev/include/asm-ppc/param.h
--- linux-2.4.30.old/include/asm-ppc/param.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urN linux-2.4.30.old/include/asm-ppc/ppc4xx_dma.h linux-2.4.30.dev/include/asm-ppc/ppc4xx_dma.h
--- linux-2.4.30.old/include/asm-ppc/ppc4xx_dma.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/asm-ppc/ppc4xx_dma.h	2008-05-11 02:17:53.000000000 +0200
@@ -137,7 +137,7 @@
 #define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
 #define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
 
-#define DMA_DEC            (1<<(2)	/* Address Decrement */
+#define DMA_DEC            (1<<(2))	/* Address Decrement */
 #define SET_DMA_DEC(x)     (((x)&0x1)<<2)
 #define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
 
diff -urN linux-2.4.30.old/include/asm-ppc/signal.h linux-2.4.30.dev/include/asm-ppc/signal.h
--- linux-2.4.30.old/include/asm-ppc/signal.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -111,6 +111,13 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+ 
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM 0
+#endif
+  
 #endif /* __KERNEL__ */
 
 #define SIG_BLOCK          0	/* for blocking signals */
diff -urN linux-2.4.30.old/include/asm-ppc/spinlock.h linux-2.4.30.dev/include/asm-ppc/spinlock.h
--- linux-2.4.30.old/include/asm-ppc/spinlock.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/spinlock.h	2008-05-11 02:17:53.000000000 +0200
@@ -40,7 +40,6 @@
 extern void _spin_lock(spinlock_t *lock);
 extern void _spin_unlock(spinlock_t *lock);
 extern int spin_trylock(spinlock_t *lock);
-extern unsigned long __spin_trylock(volatile unsigned long *lock);
 
 #define spin_lock(lp)			_spin_lock(lp)
 #define spin_unlock(lp)			_spin_unlock(lp)
diff -urN linux-2.4.30.old/include/asm-ppc/time.h linux-2.4.30.dev/include/asm-ppc/time.h
--- linux-2.4.30.old/include/asm-ppc/time.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/asm-ppc/time.h	2008-05-11 02:17:53.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/config.h>
 #include <linux/mc146818rtc.h>
 #include <linux/threads.h>
+#include <linux/compiler.h>
 
 #include <asm/processor.h>
 
@@ -57,7 +58,7 @@
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
 #ifdef CONFIG_6xx
-extern __inline__ int const __USE_RTC(void) {
+extern __inline__ int __attribute_const__ __USE_RTC(void) {
 	return (mfspr(SPRN_PVR)>>16) == 1;
 }
 #else
diff -urN linux-2.4.30.old/include/asm-sh/param.h linux-2.4.30.dev/include/asm-sh/param.h
--- linux-2.4.30.old/include/asm-sh/param.h	2001-01-04 22:19:13.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sh/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urN linux-2.4.30.old/include/asm-sh/signal.h linux-2.4.30.dev/include/asm-sh/signal.h
--- linux-2.4.30.old/include/asm-sh/signal.h	1999-11-19 04:37:03.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sh/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -107,8 +107,15 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0	/* for blocking signals */
 #define SIG_UNBLOCK        1	/* for unblocking signals */
 #define SIG_SETMASK        2	/* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-sparc/mostek.h linux-2.4.30.dev/include/asm-sparc/mostek.h
--- linux-2.4.30.old/include/asm-sparc/mostek.h	2001-01-22 22:30:20.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc/mostek.h	2008-05-11 02:17:53.000000000 +0200
@@ -127,7 +127,6 @@
 	char offset[6*1024];         /* Magic things may be here, who knows? */
 	struct mostek48t02 regs;     /* Here is what we are interested in.   */
 };
-extern struct mostek48t08 *mstk48t08_regs;
 
 extern enum sparc_clock_type sp_clock_typ;
 
diff -urN linux-2.4.30.old/include/asm-sparc/param.h linux-2.4.30.dev/include/asm-sparc/param.h
--- linux-2.4.30.old/include/asm-sparc/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -urN linux-2.4.30.old/include/asm-sparc/signal.h linux-2.4.30.dev/include/asm-sparc/signal.h
--- linux-2.4.30.old/include/asm-sparc/signal.h	1999-09-08 20:14:32.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -176,8 +176,15 @@
 #define SA_PROBE SA_ONESHOT
 #define SA_SAMPLE_RANDOM SA_RESTART
 #define SA_STATIC_ALLOC		0x80
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 /* Type of a signal handler.  */
 #ifdef __KERNEL__
 typedef void (*__sighandler_t)(int, int, struct sigcontext *, char *);
diff -urN linux-2.4.30.old/include/asm-sparc64/atomic.h linux-2.4.30.dev/include/asm-sparc64/atomic.h
--- linux-2.4.30.old/include/asm-sparc64/atomic.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc64/atomic.h	2008-05-11 02:17:53.000000000 +0200
@@ -52,10 +52,10 @@
 
 /* Atomic operations are already serializing */
 #ifdef CONFIG_SMP
-#define smp_mb__before_atomic_dec()	membar("#StoreLoad | #LoadLoad")
-#define smp_mb__after_atomic_dec()	membar("#StoreLoad | #StoreStore")
-#define smp_mb__before_atomic_inc()	membar("#StoreLoad | #LoadLoad")
-#define smp_mb__after_atomic_inc()	membar("#StoreLoad | #StoreStore")
+#define smp_mb__before_atomic_dec()	membar_safe("#StoreLoad | #LoadLoad")
+#define smp_mb__after_atomic_dec()	membar_safe("#StoreLoad | #StoreStore")
+#define smp_mb__before_atomic_inc()	membar_safe("#StoreLoad | #LoadLoad")
+#define smp_mb__after_atomic_inc()	membar_safe("#StoreLoad | #StoreStore")
 #else
 #define smp_mb__before_atomic_dec()	barrier()
 #define smp_mb__after_atomic_dec()	barrier()
diff -urN linux-2.4.30.old/include/asm-sparc64/bitops.h linux-2.4.30.dev/include/asm-sparc64/bitops.h
--- linux-2.4.30.old/include/asm-sparc64/bitops.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc64/bitops.h	2008-05-11 02:17:53.000000000 +0200
@@ -75,8 +75,8 @@
 }
 
 #ifdef CONFIG_SMP
-#define smp_mb__before_clear_bit()	membar("#StoreLoad | #LoadLoad")
-#define smp_mb__after_clear_bit()	membar("#StoreLoad | #StoreStore")
+#define smp_mb__before_clear_bit()	membar_safe("#StoreLoad | #LoadLoad")
+#define smp_mb__after_clear_bit()	membar_safe("#StoreLoad | #StoreStore")
 #else
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
diff -urN linux-2.4.30.old/include/asm-sparc64/const.h linux-2.4.30.dev/include/asm-sparc64/const.h
--- linux-2.4.30.old/include/asm-sparc64/const.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/const.h	2008-05-11 02:17:53.000000000 +0200
@@ -0,0 +1,19 @@
+/* const.h: Macros for dealing with constants.  */
+
+#ifndef _SPARC64_CONST_H
+#define _SPARC64_CONST_H
+
+/* Some constant macros are used in both assembler and
+ * C code.  Therefore we cannot annotate them always with
+ * 'UL' and other type specificers unilaterally.  We
+ * use the following macros to deal with this.
+ */
+
+#ifdef __ASSEMBLY__
+#define _AC(X,Y)	X
+#else
+#define _AC(X,Y)	(X##Y)
+#endif
+
+
+#endif /* !(_SPARC64_CONST_H) */
diff -urN linux-2.4.30.old/include/asm-sparc64/dma.h linux-2.4.30.dev/include/asm-sparc64/dma.h
--- linux-2.4.30.old/include/asm-sparc64/dma.h	2000-02-01 08:37:19.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/dma.h	2008-05-11 02:17:53.000000000 +0200
@@ -153,9 +153,9 @@
 #define DMA_MAXEND(addr) (0x01000000UL-(((unsigned long)(addr))&0x00ffffffUL))
 
 /* Yes, I hack a lot of elisp in my spare time... */
-#define DMA_ERROR_P(regs)  (((sbus_readl((regs) + DMA_CSR) & DMA_HNDL_ERROR))
-#define DMA_IRQ_P(regs)    (((sbus_readl((regs) + DMA_CSR)) & (DMA_HNDL_INTR | DMA_HNDL_ERROR)))
-#define DMA_WRITE_P(regs)  (((sbus_readl((regs) + DMA_CSR) & DMA_ST_WRITE))
+#define DMA_ERROR_P(regs)  (sbus_readl((regs) + DMA_CSR) & DMA_HNDL_ERROR)
+#define DMA_IRQ_P(regs)    ((sbus_readl((regs) + DMA_CSR)) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))
+#define DMA_WRITE_P(regs)  (sbus_readl((regs) + DMA_CSR) & DMA_ST_WRITE)
 #define DMA_OFF(__regs)		\
 do {	u32 tmp = sbus_readl((__regs) + DMA_CSR); \
 	tmp &= ~DMA_ENABLE; \
diff -urN linux-2.4.30.old/include/asm-sparc64/mostek.h linux-2.4.30.dev/include/asm-sparc64/mostek.h
--- linux-2.4.30.old/include/asm-sparc64/mostek.h	2001-01-22 22:30:20.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/mostek.h	2008-05-11 02:17:53.000000000 +0200
@@ -134,13 +134,11 @@
  */
 #define MOSTEK_48T08_OFFSET	0x0000UL	/* Lower NVRAM portions */
 #define MOSTEK_48T08_48T02	0x1800UL	/* Offset to 48T02 chip */
-extern unsigned long mstk48t08_regs;
 
 /* SUN5 systems usually have 48t59 model clock chipsets.  But we keep the older
  * clock chip definitions around just in case.
  */
 #define MOSTEK_48T59_OFFSET	0x0000UL	/* Lower NVRAM portions */
 #define MOSTEK_48T59_48T02	0x1800UL	/* Offset to 48T02 chip */
-extern unsigned long mstk48t59_regs;
 
 #endif /* !(_SPARC64_MOSTEK_H) */
diff -urN linux-2.4.30.old/include/asm-sparc64/param.h linux-2.4.30.dev/include/asm-sparc64/param.h
--- linux-2.4.30.old/include/asm-sparc64/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -urN linux-2.4.30.old/include/asm-sparc64/sfafsr.h linux-2.4.30.dev/include/asm-sparc64/sfafsr.h
--- linux-2.4.30.old/include/asm-sparc64/sfafsr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/sfafsr.h	2008-05-11 02:17:53.000000000 +0200
@@ -0,0 +1,82 @@
+#ifndef _SPARC64_SFAFSR_H
+#define _SPARC64_SFAFSR_H
+
+#include <asm/const.h>
+
+/* Spitfire Asynchronous Fault Status register, ASI=0x4C VA<63:0>=0x0 */
+
+#define SFAFSR_ME		(_AC(1,UL) << SFAFSR_ME_SHIFT)
+#define SFAFSR_ME_SHIFT		32
+#define SFAFSR_PRIV		(_AC(1,UL) << SFAFSR_PRIV_SHIFT)
+#define SFAFSR_PRIV_SHIFT	31
+#define SFAFSR_ISAP		(_AC(1,UL) << SFAFSR_ISAP_SHIFT)
+#define SFAFSR_ISAP_SHIFT	30
+#define SFAFSR_ETP		(_AC(1,UL) << SFAFSR_ETP_SHIFT)
+#define SFAFSR_ETP_SHIFT	29
+#define SFAFSR_IVUE		(_AC(1,UL) << SFAFSR_IVUE_SHIFT)
+#define SFAFSR_IVUE_SHIFT	28
+#define SFAFSR_TO		(_AC(1,UL) << SFAFSR_TO_SHIFT)
+#define SFAFSR_TO_SHIFT		27
+#define SFAFSR_BERR		(_AC(1,UL) << SFAFSR_BERR_SHIFT)
+#define SFAFSR_BERR_SHIFT	26
+#define SFAFSR_LDP		(_AC(1,UL) << SFAFSR_LDP_SHIFT)
+#define SFAFSR_LDP_SHIFT	25
+#define SFAFSR_CP		(_AC(1,UL) << SFAFSR_CP_SHIFT)
+#define SFAFSR_CP_SHIFT		24
+#define SFAFSR_WP		(_AC(1,UL) << SFAFSR_WP_SHIFT)
+#define SFAFSR_WP_SHIFT		23
+#define SFAFSR_EDP		(_AC(1,UL) << SFAFSR_EDP_SHIFT)
+#define SFAFSR_EDP_SHIFT	22
+#define SFAFSR_UE		(_AC(1,UL) << SFAFSR_UE_SHIFT)
+#define SFAFSR_UE_SHIFT		21
+#define SFAFSR_CE		(_AC(1,UL) << SFAFSR_CE_SHIFT)
+#define SFAFSR_CE_SHIFT		20
+#define SFAFSR_ETS		(_AC(0xf,UL) << SFAFSR_ETS_SHIFT)
+#define SFAFSR_ETS_SHIFT	16
+#define SFAFSR_PSYND		(_AC(0xffff,UL) << SFAFSR_PSYND_SHIFT)
+#define SFAFSR_PSYND_SHIFT	0
+
+/* UDB Error Register, ASI=0x7f VA<63:0>=0x0(High),0x18(Low) for read
+ *                     ASI=0x77 VA<63:0>=0x0(High),0x18(Low) for write
+ */
+
+#define UDBE_UE			(_AC(1,UL) << 9)
+#define UDBE_CE			(_AC(1,UL) << 8)
+#define UDBE_E_SYNDR		(_AC(0xff,UL) << 0)
+
+/* The trap handlers for asynchronous errors encode the AFSR and
+ * other pieces of information into a 64-bit argument for C code
+ * encoded as follows:
+ *
+ * -----------------------------------------------
+ * |  UDB_H  |  UDB_L  | TL>1  |  TT  |   AFSR   |
+ * -----------------------------------------------
+ *  63     54 53     44    42   41  33 32       0
+ *
+ * The AFAR is passed in unchanged.
+ */
+#define SFSTAT_UDBH_MASK	(_AC(0x3ff,UL) << SFSTAT_UDBH_SHIFT)
+#define SFSTAT_UDBH_SHIFT	54
+#define SFSTAT_UDBL_MASK	(_AC(0x3ff,UL) << SFSTAT_UDBH_SHIFT)
+#define SFSTAT_UDBL_SHIFT	44
+#define SFSTAT_TL_GT_ONE	(_AC(1,UL) << SFSTAT_TL_GT_ONE_SHIFT)
+#define SFSTAT_TL_GT_ONE_SHIFT	42
+#define SFSTAT_TRAP_TYPE	(_AC(0x1FF,UL) << SFSTAT_TRAP_TYPE_SHIFT)
+#define SFSTAT_TRAP_TYPE_SHIFT	33
+#define SFSTAT_AFSR_MASK	(_AC(0x1ffffffff,UL) << SFSTAT_AFSR_SHIFT)
+#define SFSTAT_AFSR_SHIFT	0
+
+/* ESTATE Error Enable Register, ASI=0x4b VA<63:0>=0x0 */
+#define ESTATE_ERR_CE		0x1 /* Correctable errors                    */
+#define ESTATE_ERR_NCE		0x2 /* TO, BERR, LDP, ETP, EDP, WP, UE, IVUE */
+#define ESTATE_ERR_ISAP		0x4 /* System address parity error           */
+#define ESTATE_ERR_ALL		(ESTATE_ERR_CE | \
+				 ESTATE_ERR_NCE | \
+				 ESTATE_ERR_ISAP)
+
+/* The various trap types that report using the above state. */
+#define TRAP_TYPE_IAE		0x09 /* Instruction Access Error             */
+#define TRAP_TYPE_DAE		0x32 /* Data Access Error                    */
+#define TRAP_TYPE_CEE		0x63 /* Correctable ECC Error                */
+
+#endif /* _SPARC64_SFAFSR_H */
diff -urN linux-2.4.30.old/include/asm-sparc64/signal.h linux-2.4.30.dev/include/asm-sparc64/signal.h
--- linux-2.4.30.old/include/asm-sparc64/signal.h	1999-09-08 20:14:32.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc64/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -192,8 +192,15 @@
 #define SA_PROBE SA_ONESHOT
 #define SA_SAMPLE_RANDOM SA_RESTART
 #define SA_STATIC_ALLOC		0x80
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM	SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM	0
 #endif
 
+#endif /* __KERNEL__ */
+
 /* Type of a signal handler.  */
 #ifdef __KERNEL__
 typedef void (*__sighandler_t)(int, struct sigcontext *);
diff -urN linux-2.4.30.old/include/asm-sparc64/smp.h linux-2.4.30.dev/include/asm-sparc64/smp.h
--- linux-2.4.30.old/include/asm-sparc64/smp.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/smp.h	2008-05-11 02:17:53.000000000 +0200
@@ -60,7 +60,6 @@
  *	Private routines/data
  */
  
-extern unsigned char boot_cpu_id;
 extern unsigned long cpu_present_map;
 #define cpu_online_map cpu_present_map
 
diff -urN linux-2.4.30.old/include/asm-sparc64/softirq.h linux-2.4.30.dev/include/asm-sparc64/softirq.h
--- linux-2.4.30.old/include/asm-sparc64/softirq.h	2001-09-08 21:02:32.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc64/softirq.h	2008-05-11 02:17:53.000000000 +0200
@@ -8,7 +8,7 @@
 
 #include <asm/atomic.h>
 #include <asm/hardirq.h>
-#include <asm/system.h>		/* for membar() */
+#include <asm/system.h>		/* for membar_safe() */
 
 #define local_bh_disable()	(local_bh_count(smp_processor_id())++)
 #define __local_bh_enable()	(local_bh_count(smp_processor_id())--)
diff -urN linux-2.4.30.old/include/asm-sparc64/spinlock.h linux-2.4.30.dev/include/asm-sparc64/spinlock.h
--- linux-2.4.30.old/include/asm-sparc64/spinlock.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/spinlock.h	2008-05-11 02:17:53.000000000 +0200
@@ -37,7 +37,7 @@
 #define spin_is_locked(lock)	(*((volatile unsigned char *)(lock)) != 0)
 
 #define spin_unlock_wait(lock)	\
-do {	membar("#LoadLoad");	\
+do {	rmb();			\
 } while(*((volatile unsigned char *)lock))
 
 extern __inline__ void spin_lock(spinlock_t *lock)
@@ -92,7 +92,7 @@
 #define spin_is_locked(__lock)	(*((volatile unsigned char *)(&((__lock)->lock))) != 0)
 #define spin_unlock_wait(__lock)	\
 do { \
-	membar("#LoadLoad"); \
+	rmb(); \
 } while(*((volatile unsigned char *)(&((__lock)->lock))))
 
 extern void _do_spin_lock (spinlock_t *lock, char *str);
diff -urN linux-2.4.30.old/include/asm-sparc64/system.h linux-2.4.30.dev/include/asm-sparc64/system.h
--- linux-2.4.30.old/include/asm-sparc64/system.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/asm-sparc64/system.h	2008-05-11 02:17:53.000000000 +0200
@@ -106,15 +106,47 @@
 
 #define nop() 		__asm__ __volatile__ ("nop")
 
-#define membar(type)	__asm__ __volatile__ ("membar " type : : : "memory")
+/* These are here in an effort to more fully work around Spitfire Errata
+ * #51.  Essentially, if a memory barrier occurs soon after a mispredicted
+ * branch, the chip can stop executing instructions until a trap occurs.
+ * Therefore, if interrupts are disabled, the chip can hang forever.
+ *
+ * It used to be believed that the memory barrier had to be right in the
+ * delay slot, but a case has been traced recently wherein the memory barrier
+ * was one instruction after the branch delay slot and the chip still hung.
+ * The offending sequence was the following in sym_wakeup_done() of the
+ * sym53c8xx_2 driver:
+ *
+ *	call	sym_ccb_from_dsa, 0
+ *	 movge	%icc, 0, %l0
+ *	brz,pn	%o0, .LL1303
+ *	 mov	%o0, %l2
+ *	membar	#LoadLoad
+ *
+ * The branch has to be mispredicted for the bug to occur.  Therefore, we put
+ * the memory barrier explicitly into a "branch always, predicted taken"
+ * delay slot to avoid the problem case.
+ */
+#define membar_safe(type) \
+do {	__asm__ __volatile__("ba,pt	%%xcc, 1f\n\t" \
+			     " membar	" type "\n" \
+			     "1:\n" \
+			     : : : "memory"); \
+} while (0)
 #define mb()		\
-	membar("#LoadLoad | #LoadStore | #StoreStore | #StoreLoad")
-#define rmb()		membar("#LoadLoad")
-#define wmb()		membar("#StoreStore")
+	membar_safe("#LoadLoad | #LoadStore | #StoreStore | #StoreLoad")
+#define rmb()		\
+	membar_safe("#LoadLoad")
+#define wmb()		\
+	membar_safe("#StoreStore")
 #define set_mb(__var, __value) \
-	do { __var = __value; membar("#StoreLoad | #StoreStore"); } while(0)
+do {	__var = __value; \
+	membar_safe("#StoreLoad | #StoreStore"); \
+} while(0)
 #define set_wmb(__var, __value) \
-	do { __var = __value; membar("#StoreStore"); } while(0)
+do {	__var = __value; \
+	membar_safe("#StoreStore"); \
+} while(0)
 
 #ifdef CONFIG_SMP
 #define smp_mb()	mb()
diff -urN linux-2.4.30.old/include/asm-sparc64/uaccess.h linux-2.4.30.dev/include/asm-sparc64/uaccess.h
--- linux-2.4.30.old/include/asm-sparc64/uaccess.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/asm-sparc64/uaccess.h	2008-05-11 02:17:53.000000000 +0200
@@ -294,10 +294,10 @@
 }
 #define __copy_in_user copy_in_user
 
+extern __kernel_size_t __bzero_noasi(void *addr, __kernel_size_t size);
+	
 extern __inline__ __kernel_size_t __clear_user(void *addr, __kernel_size_t size)
 {
-	extern __kernel_size_t __bzero_noasi(void *addr, __kernel_size_t size);
-	
 	return __bzero_noasi(addr, size);
 }
 
diff -urN linux-2.4.30.old/include/asm-s390/param.h linux-2.4.30.dev/include/asm-s390/param.h
--- linux-2.4.30.old/include/asm-s390/param.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.30.dev/include/asm-s390/param.h	2008-05-11 02:17:50.000000000 +0200
@@ -11,6 +11,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urN linux-2.4.30.old/include/asm-s390/signal.h linux-2.4.30.dev/include/asm-s390/signal.h
--- linux-2.4.30.old/include/asm-s390/signal.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-s390/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -129,8 +129,15 @@
 #define SA_SHIRQ                0x04000000
 #define SA_DOPATHGROUP          0x00100000
 #define SA_FORCE                0x00200000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM		SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM		0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0    /* for blocking signals */
 #define SIG_UNBLOCK        1    /* for unblocking signals */
 #define SIG_SETMASK        2    /* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-s390x/signal.h linux-2.4.30.dev/include/asm-s390x/signal.h
--- linux-2.4.30.old/include/asm-s390x/signal.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/asm-s390x/signal.h	2008-05-11 02:17:51.000000000 +0200
@@ -129,8 +129,15 @@
 #define SA_SHIRQ                0x04000000
 #define SA_DOPATHGROUP          0x00100000
 #define SA_FORCE                0x00200000
+
+#ifdef CONFIG_NET_RANDOM
+#define SA_NET_RANDOM		SA_SAMPLE_RANDOM
+#else
+#define SA_NET_RANDOM		0
 #endif
 
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK          0    /* for blocking signals */
 #define SIG_UNBLOCK        1    /* for unblocking signals */
 #define SIG_SETMASK        2    /* for setting the signal mask */
diff -urN linux-2.4.30.old/include/asm-x86_64/apic.h linux-2.4.30.dev/include/asm-x86_64/apic.h
--- linux-2.4.30.old/include/asm-x86_64/apic.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/asm-x86_64/apic.h	2008-05-11 02:17:53.000000000 +0200
@@ -28,7 +28,7 @@
 
 static __inline void apic_write_atomic(unsigned long reg, unsigned int v)
 {
-	xchg((volatile unsigned int *)(APIC_BASE+reg), v);
+	(void) xchg((volatile unsigned int *)(APIC_BASE+reg), v);
 }
 
 static __inline unsigned int apic_read(unsigned long reg)
diff -urN linux-2.4.30.old/include/asm-x86_64/bitops.h linux-2.4.30.dev/include/asm-x86_64/bitops.h
--- linux-2.4.30.old/include/asm-x86_64/bitops.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/bitops.h	2008-05-11 02:17:53.000000000 +0200
@@ -38,7 +38,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btsq %1,%0"
 		:"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 }
 
 /**
@@ -55,7 +55,7 @@
 	__asm__(
 		"btsq %1,%0"
 		:"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 }
 
 /**
@@ -73,7 +73,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btrq %1,%0"
 		:"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 }
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
@@ -92,7 +92,7 @@
 	__asm__ __volatile__(
 		"btcq %1,%0"
 		:"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 }
 
 /**
@@ -109,7 +109,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btcq %1,%0"
 		:"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 }
 
 /**
@@ -127,7 +127,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btsq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr) : "memory");
+		:"dIr" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -147,7 +147,7 @@
 	__asm__(
 		"btsq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 	return oldbit;
 }
 
@@ -166,7 +166,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btrq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr) : "memory");
+		:"dIr" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -186,7 +186,7 @@
 	__asm__(
 		"btrq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr));
+		:"dIr" (nr), "m" (ADDR));
 	return oldbit;
 }
 
@@ -198,7 +198,7 @@
 	__asm__ __volatile__(
 		"btcq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr) : "memory");
+		:"dIr" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
@@ -217,7 +217,7 @@
 	__asm__ __volatile__( LOCK_PREFIX
 		"btcq %2,%1\n\tsbbq %0,%0"
 		:"=r" (oldbit),"=m" (ADDR)
-		:"dIr" (nr) : "memory");
+		:"dIr" (nr), "m" (ADDR) : "memory");
 	return oldbit;
 }
 
diff -urN linux-2.4.30.old/include/asm-x86_64/byteorder.h linux-2.4.30.dev/include/asm-x86_64/byteorder.h
--- linux-2.4.30.old/include/asm-x86_64/byteorder.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/asm-x86_64/byteorder.h	2008-05-11 02:17:53.000000000 +0200
@@ -2,16 +2,17 @@
 #define _X86_64_BYTEORDER_H
 
 #include <asm/types.h>
+#include <linux/compiler.h>
 
 #ifdef __GNUC__
 
-static __inline__ __const__ __u64 ___arch__swab64(__u64 x)
+static __inline__ __attribute_const__ __u64 ___arch__swab64(__u64 x)
 {
 	__asm__("bswapq %0" : "=r" (x) : "0" (x));
 	return x;
 }
 
-static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
+static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 x)
 {
 	__asm__("bswapl %0" : "=r" (x) : "0" (x));
 	return x;
diff -urN linux-2.4.30.old/include/asm-x86_64/desc.h linux-2.4.30.dev/include/asm-x86_64/desc.h
--- linux-2.4.30.old/include/asm-x86_64/desc.h	2004-08-08 01:26:06.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/desc.h	2008-05-11 02:17:53.000000000 +0200
@@ -128,7 +128,7 @@
 
 static inline void set_tss_desc(unsigned n, void *addr)
 { 
-	set_tssldt_descriptor((void *)&gdt_table + __CPU_DESC_INDEX(n,tss), (unsigned long)addr, DESC_TSS, sizeof(struct tss_struct)); 
+	set_tssldt_descriptor((void *)&gdt_table + __CPU_DESC_INDEX(n,tss), (unsigned long)addr, DESC_TSS, IO_BITMAP_OFFSET + IO_BITMAP_BYTES + 7); 
 } 
 
 static inline void set_ldt_desc(unsigned n, void *addr, int size)
diff -urN linux-2.4.30.old/include/asm-x86_64/i387.h linux-2.4.30.dev/include/asm-x86_64/i387.h
--- linux-2.4.30.old/include/asm-x86_64/i387.h	2004-08-08 01:26:06.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/i387.h	2008-05-11 02:17:53.000000000 +0200
@@ -125,8 +125,12 @@
 
 static inline void save_init_fpu( struct task_struct *tsk )
 {
-	asm volatile( "fxsave %0 ; fnclex"
+	asm volatile( "fxsave %0"
 		      : "=m" (tsk->thread.i387.fxsave));
+	if (tsk->thread.i387.fxsave.swd & (1<<7))
+		asm volatile("fnclex");
+	/* AMD CPUs leak F?P through FXSAVE. Clear it here */
+	asm volatile("ffree %st(7) ; fildl %gs:0");
 	tsk->flags &= ~PF_USEDFPU;
 	stts();
 }
diff -urN linux-2.4.30.old/include/asm-x86_64/mmu_context.h linux-2.4.30.dev/include/asm-x86_64/mmu_context.h
--- linux-2.4.30.old/include/asm-x86_64/mmu_context.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/asm-x86_64/mmu_context.h	2008-05-11 02:17:53.000000000 +0200
@@ -60,9 +60,11 @@
 			out_of_line_bug();
 		if(!test_and_set_bit(cpu, &next->cpu_vm_mask)) {
 			/* We were in lazy tlb mode and leave_mm disabled 
-			 * tlb flush IPI delivery. We must flush our tlb.
+			 * tlb flush IPI delivery. We must reload the page 
+			 * table.
 			 */
-			local_flush_tlb();
+			*read_pda(level4_pgt) = __pa(next->pgd) | _PAGE_TABLE;
+			__flush_tlb();
 		}
 		if (!test_and_set_bit(cpu, &next->context.cpuvalid))
 			load_LDT(next);
diff -urN linux-2.4.30.old/include/asm-x86_64/mpspec.h linux-2.4.30.dev/include/asm-x86_64/mpspec.h
--- linux-2.4.30.old/include/asm-x86_64/mpspec.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/mpspec.h	2008-05-11 02:17:53.000000000 +0200
@@ -76,7 +76,7 @@
 {
 	unsigned char mpc_type;
 	unsigned char mpc_busid;
-	unsigned char mpc_bustype[6] __attribute((packed));
+	unsigned char mpc_bustype[6];
 };
 
 /* List of Bus Type string values, Intel MP Spec. */
diff -urN linux-2.4.30.old/include/asm-x86_64/pci.h linux-2.4.30.dev/include/asm-x86_64/pci.h
--- linux-2.4.30.old/include/asm-x86_64/pci.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/pci.h	2008-05-11 02:17:53.000000000 +0200
@@ -65,8 +65,9 @@
 extern void pci_free_consistent(struct pci_dev *hwdev, size_t size,
 				void *vaddr, dma_addr_t dma_handle);
 
-#ifdef CONFIG_SWIOTLB
 extern int swiotlb; 
+
+#ifdef CONFIG_SWIOTLB
 extern dma_addr_t swiotlb_map_single (struct pci_dev *hwdev, void *ptr, size_t size, 
                                      int dir);
 extern void swiotlb_unmap_single (struct pci_dev *hwdev, dma_addr_t dev_addr,
diff -urN linux-2.4.30.old/include/asm-x86_64/processor.h linux-2.4.30.dev/include/asm-x86_64/processor.h
--- linux-2.4.30.old/include/asm-x86_64/processor.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30.dev/include/asm-x86_64/processor.h	2008-05-11 02:17:53.000000000 +0200
@@ -68,7 +68,6 @@
 #define X86_VENDOR_UNKNOWN 0xff
 
 extern struct cpuinfo_x86 boot_cpu_data;
-extern struct tss_struct init_tss[NR_CPUS];
 
 #ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
@@ -260,6 +259,7 @@
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
  */
 #define IO_BITMAP_SIZE	32
+#define IO_BITMAP_BYTES (IO_BITMAP_SIZE * sizeof(u32))
 #define IO_BITMAP_OFFSET offsetof(struct tss_struct,io_bitmap)
 #define INVALID_IO_BITMAP_OFFSET 0x8000
 
@@ -299,6 +299,8 @@
 	u32 io_bitmap[IO_BITMAP_SIZE];
 } __attribute__((packed)) ____cacheline_aligned;
 
+extern struct tss_struct init_tss[NR_CPUS];
+
 struct thread_struct {
 	unsigned long	rsp0;
 	unsigned long	rip;
@@ -325,10 +327,9 @@
 #define INIT_MMAP \
 { &init_mm, 0, 0, NULL, PAGE_SHARED, VM_READ | VM_WRITE | VM_EXEC, 1, NULL, NULL }
 
-#define STACKFAULT_STACK 1
-#define DOUBLEFAULT_STACK 2 
-#define NMI_STACK 3 
-#define N_EXCEPTION_STACKS 3  /* hw limit: 7 */
+#define DOUBLEFAULT_STACK 1
+#define NMI_STACK 2
+#define N_EXCEPTION_STACKS 2  /* hw limit: 7 */
 #define EXCEPTION_STKSZ PAGE_SIZE
 #define EXCEPTION_STK_ORDER 0
 
diff -urN linux-2.4.30.old/include/asm-x86_64/system.h linux-2.4.30.dev/include/asm-x86_64/system.h
--- linux-2.4.30.old/include/asm-x86_64/system.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/asm-x86_64/system.h	2008-05-11 02:17:53.000000000 +0200
@@ -251,7 +251,7 @@
 #define mb() 	asm volatile("mfence":::"memory")
 #define rmb()	asm volatile("lfence":::"memory")
 #define wmb()	asm volatile("sfence":::"memory")
-#define set_mb(var, value) do { xchg(&var, value); } while (0)
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
 #define set_wmb(var, value) do { var = value; wmb(); } while (0)
 
 #define warn_if_not_ulong(x) do { unsigned long foo; (void) (&(x) == &foo); } while (0)
diff -urN linux-2.4.30.old/include/asm-x86_64/unistd.h linux-2.4.30.dev/include/asm-x86_64/unistd.h
--- linux-2.4.30.old/include/asm-x86_64/unistd.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/asm-x86_64/unistd.h	2008-05-11 02:17:53.000000000 +0200
@@ -673,7 +673,7 @@
 }
 
 extern long sys_exit(int) __attribute__((noreturn));
-static inline void exit(int error_code)
+extern inline void exit(int error_code)
 {
 	sys_exit(error_code);
 }
diff -urN linux-2.4.30.old/include/linux/ata.h linux-2.4.30.dev/include/linux/ata.h
--- linux-2.4.30.old/include/linux/ata.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/ata.h	2008-05-11 02:17:53.000000000 +0200
@@ -1,24 +1,29 @@
 
 /*
-   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
-   Copyright 2003-2004 Jeff Garzik
-
-   The contents of this file are subject to the Open
-   Software License version 1.1 that can be found at
-   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
-   by reference.
-
-   Alternatively, the contents of this file may be used under the terms
-   of the GNU General Public License version 2 (the "GPL") as distributed
-   in the kernel source COPYING file, in which case the provisions of
-   the GPL are applicable instead of the above.  If you wish to allow
-   the use of your version of this file only under the terms of the
-   GPL and not to allow others to use your version of this file under
-   the OSL, indicate your decision by deleting the provisions above and
-   replace them with the notice and other provisions required by the GPL.
-   If you do not delete the provisions above, a recipient may use your
-   version of this file under either the OSL or the GPL.
-
+ *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
+ *  Copyright 2003-2004 Jeff Garzik
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
+ *  Hardware documentation available from http://www.t13.org/
+ *
  */
 
 #ifndef __LINUX_ATA_H__
@@ -37,13 +42,18 @@
 	ATA_SECT_SIZE		= 512,
 
 	ATA_ID_WORDS		= 256,
-	ATA_ID_PROD_OFS		= 27,
-	ATA_ID_FW_REV_OFS	= 23,
 	ATA_ID_SERNO_OFS	= 10,
-	ATA_ID_MAJOR_VER	= 80,
-	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_FW_REV_OFS	= 23,
+	ATA_ID_PROD_OFS		= 27,
+	ATA_ID_OLD_PIO_MODES	= 51,
+	ATA_ID_FIELD_VALID	= 53,
 	ATA_ID_MWDMA_MODES	= 63,
+	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_EIDE_DMA_MIN	= 65,
+	ATA_ID_EIDE_PIO		= 67,
+	ATA_ID_EIDE_PIO_IORDY	= 68,
 	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_MAJOR_VER	= 80,
 	ATA_ID_PIO4		= (1 << 1),
 
 	ATA_PCI_CTL_OFS		= 2,
@@ -108,6 +118,8 @@
 
 	/* ATA device commands */
 	ATA_CMD_CHK_POWER	= 0xE5, /* check power mode */
+	ATA_CMD_STANDBY		= 0xE2, /* place in standby power mode */
+	ATA_CMD_IDLE		= 0xE3, /* place in idle power mode */
 	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
 	ATA_CMD_FLUSH		= 0xE7,
 	ATA_CMD_FLUSH_EXT	= 0xEA,
@@ -121,10 +133,15 @@
 	ATA_CMD_PIO_READ_EXT	= 0x24,
 	ATA_CMD_PIO_WRITE	= 0x30,
 	ATA_CMD_PIO_WRITE_EXT	= 0x34,
+	ATA_CMD_READ_MULTI	= 0xC4,
+	ATA_CMD_READ_MULTI_EXT	= 0x29,
+	ATA_CMD_WRITE_MULTI	= 0xC5,
+	ATA_CMD_WRITE_MULTI_EXT	= 0x39,
 	ATA_CMD_SET_FEATURES	= 0xEF,
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
+	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
@@ -139,14 +156,14 @@
 	XFER_MW_DMA_2		= 0x22,
 	XFER_MW_DMA_1		= 0x21,
 	XFER_MW_DMA_0		= 0x20,
+	XFER_SW_DMA_2		= 0x12,
+	XFER_SW_DMA_1		= 0x11,
+	XFER_SW_DMA_0		= 0x10,
 	XFER_PIO_4		= 0x0C,
 	XFER_PIO_3		= 0x0B,
 	XFER_PIO_2		= 0x0A,
 	XFER_PIO_1		= 0x09,
 	XFER_PIO_0		= 0x08,
-	XFER_SW_DMA_2		= 0x12,
-	XFER_SW_DMA_1		= 0x11,
-	XFER_SW_DMA_0		= 0x10,
 	XFER_PIO_SLOW		= 0x00,
 
 	/* ATAPI stuff */
@@ -174,6 +191,7 @@
 	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
 	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
 	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
+	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
 };
 
 enum ata_tf_protocols {
@@ -224,6 +242,7 @@
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
+#define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
 #define ata_id_has_flush(id) ((id)[83] & (1 << 12))
@@ -242,7 +261,19 @@
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
-static inline int atapi_cdb_len(u16 *dev_id)
+static inline int ata_id_current_chs_valid(const u16 *id)
+{
+	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command 
+	   has not been issued to the device then the values of 
+	   id[54] to id[56] are vendor specific. */
+	return (id[53] & 0x01) && /* Current translation valid */
+		id[54] &&  /* cylinders in current translation */
+		id[55] &&  /* heads in current translation */
+		id[55] <= 16 &&
+		id[56];    /* sectors in current translation */
+}
+
+static inline int atapi_cdb_len(const u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;
 	switch (tmp) {
@@ -252,7 +283,7 @@
 	}
 }
 
-static inline int is_atapi_taskfile(struct ata_taskfile *tf)
+static inline int is_atapi_taskfile(const struct ata_taskfile *tf)
 {
 	return (tf->protocol == ATA_PROT_ATAPI) ||
 	       (tf->protocol == ATA_PROT_ATAPI_NODATA) ||
diff -urN linux-2.4.30.old/include/linux/atalk.h linux-2.4.30.dev/include/linux/atalk.h
--- linux-2.4.30.old/include/linux/atalk.h	2001-11-22 20:47:11.000000000 +0100
+++ linux-2.4.30.dev/include/linux/atalk.h	2008-05-11 02:17:53.000000000 +0200
@@ -137,14 +137,14 @@
 #define AARP_REQUEST			1
 #define AARP_REPLY			2
 #define AARP_PROBE			3
-	__u8	hw_src[ETH_ALEN]	__attribute__ ((packed));
-	__u8	pa_src_zero		__attribute__ ((packed));
+	__u8	hw_src[ETH_ALEN];
+	__u8	pa_src_zero;
 	__u16	pa_src_net		__attribute__ ((packed));
-	__u8	pa_src_node		__attribute__ ((packed));
-	__u8	hw_dst[ETH_ALEN]	__attribute__ ((packed));
-	__u8	pa_dst_zero		__attribute__ ((packed));
+	__u8	pa_src_node;
+	__u8	hw_dst[ETH_ALEN];
+	__u8	pa_dst_zero;
 	__u16	pa_dst_net		__attribute__ ((packed));
-	__u8	pa_dst_node		__attribute__ ((packed));	
+	__u8	pa_dst_node;	
 };
 
 #define AARP_EXPIRY_TIME	(5*60*HZ)	/* Not specified - how long till we drop a resolved entry */
diff -urN linux-2.4.30.old/include/linux/blkdev.h linux-2.4.30.dev/include/linux/blkdev.h
--- linux-2.4.30.old/include/linux/blkdev.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/blkdev.h	2008-05-11 02:17:53.000000000 +0200
@@ -46,6 +46,7 @@
 	struct buffer_head * bh;
 	struct buffer_head * bhtail;
 	request_queue_t *q;
+	char io_account;
 };
 
 #include <linux/elevator.h>
diff -urN linux-2.4.30.old/include/linux/byteorder/swab.h linux-2.4.30.dev/include/linux/byteorder/swab.h
--- linux-2.4.30.old/include/linux/byteorder/swab.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/linux/byteorder/swab.h	2008-05-11 02:17:53.000000000 +0200
@@ -15,6 +15,8 @@
  *
  */
 
+#include <linux/compiler.h>
+
 /* casts are necessary for constants, because we never know how for sure
  * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.
  */
@@ -66,7 +68,7 @@
 #define ___constant_swab24(x) \
 	((__u32)( \
 		(((__u32)(x) & (__u32)0x000000ffU) << 16) | \
-		(((__u32)(x) & (__u32)0x0000ff00U)	  | \
+		(((__u32)(x) & (__u32)0x0000ff00U))	  | \
 		(((__u32)(x) & (__u32)0x00ff0000U) >> 16) ))
 #define ___constant_swab32(x) \
 	((__u32)( \
@@ -156,7 +158,7 @@
 #endif /* OPTIMIZE */
 
 
-static __inline__ __const__ __u16 __fswab16(__u16 x)
+static __inline__ __attribute_const__ __u16 __fswab16(__u16 x)
 {
 	return __arch__swab16(x);
 }
@@ -169,7 +171,7 @@
 	__arch__swab16s(addr);
 }
 
-static __inline__ __const__ __u32 __fswab24(__u32 x)
+static __inline__ __attribute_const__ __u32 __fswab24(__u32 x)
 {
 	return __arch__swab24(x);
 }
@@ -182,7 +184,7 @@
 	__arch__swab24s(addr);
 }
 
-static __inline__ __const__ __u32 __fswab32(__u32 x)
+static __inline__ __attribute_const__ __u32 __fswab32(__u32 x)
 {
 	return __arch__swab32(x);
 }
@@ -196,7 +198,7 @@
 }
 
 #ifdef __BYTEORDER_HAS_U64__
-static __inline__ __const__ __u64 __fswab64(__u64 x)
+static __inline__ __attribute_const__ __u64 __fswab64(__u64 x)
 {
 #  ifdef __SWAB_64_THRU_32__
 	__u32 h = x >> 32;
diff -urN linux-2.4.30.old/include/linux/b1lli.h linux-2.4.30.dev/include/linux/b1lli.h
--- linux-2.4.30.old/include/linux/b1lli.h	2001-10-11 18:47:33.000000000 +0200
+++ linux-2.4.30.dev/include/linux/b1lli.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: b1lli.h,v 1.8.8.3 2001/09/23 22:25:05 kai Exp $
+/* $Id$
  *
  * ISDN lowlevel-module for AVM B1-card.
  *
diff -urN linux-2.4.30.old/include/linux/b1pcmcia.h linux-2.4.30.dev/include/linux/b1pcmcia.h
--- linux-2.4.30.old/include/linux/b1pcmcia.h	2001-10-11 18:47:33.000000000 +0200
+++ linux-2.4.30.dev/include/linux/b1pcmcia.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: b1pcmcia.h,v 1.1.8.2 2001/09/23 22:25:05 kai Exp $
+/* $Id$
  *
  * Exported functions of module b1pcmcia to be called by
  * avm_cs card services module.
diff -urN linux-2.4.30.old/include/linux/capi.h linux-2.4.30.dev/include/linux/capi.h
--- linux-2.4.30.old/include/linux/capi.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.30.dev/include/linux/capi.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: capi.h,v 1.1.4.1 2001/11/20 14:19:38 kai Exp $
+/* $Id$
  * 
  * CAPI 2.0 Interface for Linux
  * 
diff -urN linux-2.4.30.old/include/linux/compiler.h linux-2.4.30.dev/include/linux/compiler.h
--- linux-2.4.30.old/include/linux/compiler.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/compiler.h	2008-05-11 02:17:53.000000000 +0200
@@ -27,6 +27,12 @@
 #define __attribute_used__	/* not implemented */
 #endif /* __GNUC__ */
 
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+#define __attribute_const__	__attribute__((__const__))
+#else
+#define __attribute_const__	/* unimplemented */
+#endif
+
 #if __GNUC__ == 3
 #if __GNUC_MINOR__ >= 1
 # define inline         __inline__ __attribute__((always_inline))
@@ -35,6 +41,16 @@
 #endif
 #endif
 
+#ifdef __KERNEL__
+#if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 2
+#error "GCC >= 4.2 miscompiles kernel 2.4, do not use it!"
+#error "While the resulting kernel may boot, you will encounter random bugs"
+#error "at runtime. Only versions 2.95.3 to 4.1 are known to work reliably."
+#error "To build with another version, for instance 3.3, please do"
+#error "   make bzImage CC=gcc-3.3 "
+#endif
+#endif
+
 /* no checker support, so we unconditionally define this as (null) */
 #define __user
 #define __iomem
diff -urN linux-2.4.30.old/include/linux/concap.h linux-2.4.30.dev/include/linux/concap.h
--- linux-2.4.30.old/include/linux/concap.h	2001-09-30 21:26:42.000000000 +0200
+++ linux-2.4.30.dev/include/linux/concap.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: concap.h,v 1.2.8.1 2001/09/23 22:25:05 kai Exp $
+/* $Id: concap.h,v 1.3 2001/09/24 13:23:13 kai Exp $
  *
  * Copyright 1997 by Henner Eisen <eis@baty.hanse.de>
  *
@@ -11,6 +11,7 @@
 #ifdef __KERNEL__
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
+#include <linux/isdn_compat.h>
 
 /* Stuff to support encapsulation protocols genericly. The encapsulation
    protocol is processed at the uppermost layer of the network interface.
diff -urN linux-2.4.30.old/include/linux/delay.h linux-2.4.30.dev/include/linux/delay.h
--- linux-2.4.30.old/include/linux/delay.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/delay.h	2008-05-11 02:17:53.000000000 +0200
@@ -14,6 +14,24 @@
 #include <asm/delay.h>
 
 /*
+ * We define MAX_MSEC_OFFSET as the maximal value that can be accepted by
+ * msecs_to_jiffies() without risking a multiply overflow. This function
+ * returns MAX_JIFFY_OFFSET for arguments above those values.
+ */
+
+#if HZ <= 1000 && !(1000 % HZ)
+#  define MAX_MSEC_OFFSET \
+	(ULONG_MAX - (1000 / HZ) + 1)
+#elif HZ > 1000 && !(HZ % 1000)
+#  define MAX_MSEC_OFFSET \
+	(ULONG_MAX / (HZ / 1000))
+#else
+#  define MAX_MSEC_OFFSET \
+	((ULONG_MAX - 999) / HZ)
+#endif
+
+
+/*
  * Convert jiffies to milliseconds and back.
  *
  * Avoid unnecessary multiplications/divisions in the
@@ -43,14 +61,14 @@
 
 static inline unsigned long msecs_to_jiffies(const unsigned int m)
 {
-	if (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))
+	if (MAX_MSEC_OFFSET < UINT_MAX && m > (unsigned int)MAX_MSEC_OFFSET)
 		return MAX_JIFFY_OFFSET;
 #if HZ <= 1000 && !(1000 % HZ)
-	return (m + (1000 / HZ) - 1) / (1000 / HZ);
+	return ((unsigned long)m + (1000 / HZ) - 1) / (1000 / HZ);
 #elif HZ > 1000 && !(HZ % 1000)
-	return m * (HZ / 1000);
+	return (unsigned long)m * (HZ / 1000);
 #else
-	return (m * HZ + 999) / 1000;
+	return ((unsigned long)m * HZ + 999) / 1000;
 #endif
 }
 
diff -urN linux-2.4.30.old/include/linux/fsfilter.h linux-2.4.30.dev/include/linux/fsfilter.h
--- linux-2.4.30.old/include/linux/fsfilter.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/fsfilter.h	2008-05-11 02:17:53.000000000 +0200
@@ -70,7 +70,6 @@
 #define FILTER_FS_XFS 3
 #define FILTER_FS_OBDFS 4
 #define FILTER_FS_TMPFS 5
-extern struct filter_fs filter_oppar[FILTER_FS_TYPES];
 
 struct filter_fs *filter_get_filter_fs(const char *cache_type);
 void filter_setup_journal_ops(struct filter_fs *ops, char *cache_type);
diff -urN linux-2.4.30.old/include/linux/fs.h linux-2.4.30.dev/include/linux/fs.h
--- linux-2.4.30.old/include/linux/fs.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -324,6 +324,7 @@
 #include <linux/usbdev_fs_i.h>
 #include <linux/jffs2_fs_i.h>
 #include <linux/cramfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -519,6 +520,7 @@
 		struct socket			socket_i;
 		struct usbdev_inode_info        usbdev_i;
 		struct jffs2_inode_info		jffs2_i;
+		struct squashfs_inode_info	squashfs_i;
 		void				*generic_ip;
 	} u;
 };
@@ -658,10 +660,12 @@
 #include <linux/fcntl.h>
 
 extern int fcntl_getlk(unsigned int, struct flock *);
-extern int fcntl_setlk(unsigned int, unsigned int, struct flock *);
+extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
+			struct flock *);
 
 extern int fcntl_getlk64(unsigned int, struct flock64 *);
-extern int fcntl_setlk64(unsigned int, unsigned int, struct flock64 *);
+extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
+			struct flock64 *);
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
@@ -734,6 +738,7 @@
 #include <linux/usbdev_fs_sb.h>
 #include <linux/cramfs_fs_sb.h>
 #include <linux/jffs2_fs_sb.h>
+#include <linux/squashfs_fs_sb.h>
 
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
@@ -793,6 +798,7 @@
 		struct usbdev_sb_info   usbdevfs_sb;
 		struct jffs2_sb_info	jffs2_sb;
 		struct cramfs_sb_info	cramfs_sb;
+		struct squashfs_sb_info	squashfs_sb;
 		void			*generic_sbp;
 	} u;
 	/*
@@ -1559,7 +1565,6 @@
 unsigned long generate_cluster(kdev_t, int b[], int);
 unsigned long generate_cluster_swab32(kdev_t, int b[], int);
 extern kdev_t ROOT_DEV;
-extern char root_device_name[];
 
 
 extern void show_buffers(void);
diff -urN linux-2.4.30.old/include/linux/generic_serial.h linux-2.4.30.dev/include/linux/generic_serial.h
--- linux-2.4.30.old/include/linux/generic_serial.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.30.dev/include/linux/generic_serial.h	2008-05-11 02:17:53.000000000 +0200
@@ -98,6 +98,4 @@
 int  gs_getserial(struct gs_port *port, struct serial_struct *sp);
 void gs_got_break(struct gs_port *port);
 
-extern int gs_debug;
-
 #endif
diff -urN linux-2.4.30.old/include/linux/hysdn_if.h linux-2.4.30.dev/include/linux/hysdn_if.h
--- linux-2.4.30.old/include/linux/hysdn_if.h	2001-09-30 21:26:42.000000000 +0200
+++ linux-2.4.30.dev/include/linux/hysdn_if.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: hysdn_if.h,v 1.1.8.3 2001/09/23 22:25:05 kai Exp $
+/* $Id$
  *
  * Linux driver for HYSDN cards
  * ioctl definitions shared by hynetmgr and driver.
diff -urN linux-2.4.30.old/include/linux/ide.h linux-2.4.30.dev/include/linux/ide.h
--- linux-2.4.30.old/include/linux/ide.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/ide.h	2008-05-11 02:17:53.000000000 +0200
@@ -1691,6 +1691,7 @@
 extern ide_startstop_t ide_dma_intr(ide_drive_t *);
 extern int ide_release_dma(ide_hwif_t *);
 extern void ide_setup_dma(ide_hwif_t *, unsigned long, unsigned int);
+extern void ide_setup_no_dma(ide_hwif_t *);
 
 extern int __ide_dma_host_off(ide_drive_t *);
 extern int __ide_dma_off_quietly(ide_drive_t *);
@@ -1713,6 +1714,7 @@
 #else
 static inline void ide_setup_dma(ide_hwif_t *x, unsigned long y, unsigned int z) {;}
 static inline void ide_release_dma(ide_hwif_t *x) {;}
+static inline void ide_setup_no_dma(ide_hwif_t *x) {;}
 #endif
 
 extern void hwif_unregister(ide_hwif_t *);
diff -urN linux-2.4.30.old/include/linux/if_bridge.h linux-2.4.30.dev/include/linux/if_bridge.h
--- linux-2.4.30.old/include/linux/if_bridge.h	2001-11-22 20:47:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/if_bridge.h	2008-05-11 02:17:52.000000000 +0200
@@ -102,7 +102,8 @@
 struct net_bridge_port;
 
 extern int (*br_ioctl_hook)(unsigned long arg);
-extern void (*br_handle_frame_hook)(struct sk_buff *skb);
+extern int (*br_handle_frame_hook)(struct sk_buff *skb);
+extern int (*br_should_route_hook)(struct sk_buff **pskb);
 
 #endif
 
diff -urN linux-2.4.30.old/include/linux/if_frad.h linux-2.4.30.dev/include/linux/if_frad.h
--- linux-2.4.30.old/include/linux/if_frad.h	2001-03-07 04:28:33.000000000 +0100
+++ linux-2.4.30.dev/include/linux/if_frad.h	2008-05-11 02:17:53.000000000 +0200
@@ -131,13 +131,13 @@
 /* these are the fields of an RFC 1490 header */
 struct frhdr
 {
-   unsigned char  control	__attribute__((packed));
+   unsigned char  control;
 
    /* for IP packets, this can be the NLPID */
-   unsigned char  pad		__attribute__((packed)); 
+   unsigned char  pad	; 
 
-   unsigned char  NLPID		__attribute__((packed));
-   unsigned char  OUI[3]	__attribute__((packed));
+   unsigned char  NLPID	;
+   unsigned char  OUI[3];
    unsigned short PID		__attribute__((packed));
 
 #define IP_NLPID pad 
diff -urN linux-2.4.30.old/include/linux/imq.h linux-2.4.30.dev/include/linux/imq.h
--- linux-2.4.30.old/include/linux/imq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/imq.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef _IMQ_H
+#define _IMQ_H
+
+#define IMQ_MAX_DEVS	16
+
+#define IMQ_F_IFMASK	0x7f
+#define IMQ_F_ENQUEUE	0x80
+
+#endif /* _IMQ_H */
diff -urN linux-2.4.30.old/include/linux/intermezzo_fs.h linux-2.4.30.dev/include/linux/intermezzo_fs.h
--- linux-2.4.30.old/include/linux/intermezzo_fs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/intermezzo_fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -321,7 +321,6 @@
 int presto_ispresto(struct inode *);
 
 /* super.c */
-extern struct file_system_type presto_fs_type;
 extern int init_intermezzo_fs(void);
 
 /* fileset.c */
diff -urN linux-2.4.30.old/include/linux/isdn/tpam.h linux-2.4.30.dev/include/linux/isdn/tpam.h
--- linux-2.4.30.old/include/linux/isdn/tpam.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn/tpam.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: tpam.h,v 1.1.2.1 2001/11/20 14:19:38 kai Exp $
+/* $Id$
  *
  * Turbo PAM ISDN driver for Linux. (Kernel Driver)
  *
diff -urN linux-2.4.30.old/include/linux/isdn_compat.h linux-2.4.30.dev/include/linux/isdn_compat.h
--- linux-2.4.30.old/include/linux/isdn_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn_compat.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,261 @@
+/* $Id: isdn_compat.h,v 1.53 2001/09/24 13:23:13 kai Exp $
+ *
+ * Linux ISDN subsystem
+ * Compatibility for various Linux kernel versions
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef _LINUX_ISDN_COMPAT_H
+#define _LINUX_ISDN_COMPAT_H
+
+#ifdef __KERNEL__
+
+#ifndef ISDN_COMPAT_NOT_GENERIC
+/* when using std2kern -u, this part is left out and instead provided
+   by the .ctrl files */
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
+
+#define set_current_state(sta) (current->state = sta)
+#define module_init(x)	int init_module(void) { return x(); }
+#define module_exit(x)	void cleanup_module(void) { x(); }
+#define BUG() do { printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); *(int *)0 = 0; } while (0)
+#define init_MUTEX(x)				*(x)=MUTEX
+#define init_MUTEX_LOCKED(x)			*(x)=MUTEX_LOCKED
+#define __devinit
+#define __devinitdata
+
+#else /* 2.2.18 and later */
+
+#define COMPAT_HAS_NEW_SETUP
+#define COMPAT_HAS_NEW_WAITQ
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+
+#define dev_kfree_skb_irq(a) dev_kfree_skb(a)
+#define dev_kfree_skb_any(a) dev_kfree_skb(a)
+#define COMPAT_HAS_2_2_PCI
+#define get_pcibase(ps, nr) ps->base_address[nr]
+#define pci_resource_start_io(pdev, nr) ((pdev)->base_address[nr] & PCI_BASE_ADDRESS_IO_MASK)
+#define pci_resource_start_mem(pdev, nr) ((pdev)->base_address[nr] & PCI_BASE_ADDRESS_MEM_MASK)
+#define pci_get_sub_vendor(pdev, id)	pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &id)
+#define pci_get_sub_system(pdev, id)	pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &id)
+
+#define __exit
+#define __devinit
+#define __devinitdata
+
+#define net_device device
+#define COMPAT_NO_SOFTNET
+#define netif_running(d) test_bit(LINK_STATE_START, &d->state)
+#define COMPAT_NEED_MPPP_DEFS
+#define spin_lock_bh(lock)
+#define spin_unlock_bh(lock)
+#define COMPAT_NEED_SPIN_LOCK_BH
+#define i_count_read(ic) ic
+#define i_count_inc(ic)  ic++
+#define COMPAT_USE_MODCOUNT_LOCK
+#define devfs_register_chrdev(m,n,f) register_chrdev(m,n,f)
+#define devfs_unregister_chrdev(m,n) unregister_chrdev(m,n)
+#define COMPAT_NEED_PCI_IDS
+#define in_irq() (local_irq_count[smp_processor_id()] != 0)
+
+#else /* 2.4.0 and later */
+
+#define pci_resource_start_io(pdev, nr) pci_resource_start(pdev, nr)
+#define pci_resource_start_mem(pdev, nr) pci_resource_start(pdev, nr)
+#define get_pcibase(ps, nr) ps->resource[nr].start
+#define pci_get_sub_system(pdev, id)	id = pdev->subsystem_device
+#define pci_get_sub_vendor(pdev, id)	id = pdev->subsystem_vendor
+
+#define BIG_PHONE_NUMBERS
+#define COMPAT_HAS_ISA_IOREMAP
+#define i_count_read(ic) atomic_read(&ic)
+#define i_count_inc(ic)  atomic_inc(&ic)
+#define COMPAT_HAS_FILEOP_OWNER
+#define COMPAT_HAVE_NEW_FILLDIR
+#define COMPAT_has_fileops_in_inode
+#define COMPAT_HAS_init_special_inode
+#define COMPAT_d_alloc_root_one_parameter
+#define HAVE_DEVFS_FS
+#define COMPAT_HAS_SCHEDULE_TASK
+#define COMPAT_HAS_USB_IDTAB
+
+#endif
+
+#endif /* ISDN_COMPAT_GENERIC */
+
+#ifdef COMPAT_HAS_2_2_PCI 
+#include <linux/pci.h>
+#ifdef __powerpc__
+static inline int pci_enable_device(struct pci_dev *dev)
+{
+	u16 cmd;
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_IO | PCI_COMMAND_SERR;
+	cmd &= ~PCI_COMMAND_FAST_BACK;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+	return(0);
+}
+#else
+static inline int pci_enable_device(struct pci_dev *dev)
+{
+	return 0;
+}
+#endif /* __powerpc__ */
+
+#define PCI_ANY_ID (~0)
+
+/* as this is included multiple times, we make it inline */
+
+static inline struct pci_dev * pci_find_subsys(unsigned int vendor, unsigned int device,
+					unsigned int ss_vendor, unsigned int ss_device,
+					struct pci_dev *from)
+{
+	unsigned short subsystem_vendor, subsystem_device;
+
+	while ((from = pci_find_device(vendor, device, from))) {
+		pci_read_config_word(from, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
+		pci_read_config_word(from, PCI_SUBSYSTEM_ID, &subsystem_device);
+		if ((ss_vendor == PCI_ANY_ID || subsystem_vendor == ss_vendor) &&
+		    (ss_device == PCI_ANY_ID || subsystem_device == ss_device))
+			return from;
+	}
+	return NULL;
+}
+#endif
+
+#ifdef COMPAT_NO_SOFTNET
+#include <linux/netdevice.h>
+
+/*
+ * Tell upper layers that the network device is ready to xmit more frames.
+ */
+static void __inline__ netif_wake_queue(struct net_device * dev)
+{
+	dev->tbusy = 0;
+	mark_bh(NET_BH);
+}
+
+/*
+ * called during net_device open()
+ */
+static void __inline__ netif_start_queue(struct net_device * dev)
+{
+	dev->tbusy = 0;
+	/* actually, we never use the interrupt flag at all */
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+/*
+ * Ask upper layers to temporarily cease passing us more xmit frames.
+ */
+static void __inline__ netif_stop_queue(struct net_device * dev)
+{
+	dev->tbusy = 1;
+}
+
+#endif /* COMPAT_NO_SOFTNET */
+
+#ifndef COMPAT_HAS_NEW_WAITQ
+typedef struct wait_queue wait_queue_t;
+typedef struct wait_queue *wait_queue_head_t;
+
+#define DECLARE_WAITQUEUE(wait, current)	struct wait_queue wait = { current, NULL }
+#define DECLARE_WAIT_QUEUE_HEAD(wait)		wait_queue_head_t wait
+#define init_waitqueue_head(x)			*(x)=NULL
+#define init_waitqueue_entry(q,p)		((q)->task)=(p)
+#endif /* COMPAT_HAS_NEW_WAITQ */
+
+#ifdef COMPAT_NEED_PCI_IDS
+
+#define PCI_ANY_ID (~0)
+
+#define PCI_VENDOR_ID_DYNALINK          0x0675
+#define PCI_DEVICE_ID_DYNALINK_IS64PH   0x1702
+
+#define PCI_DEVICE_ID_WINBOND2_6692	0x6692
+
+#define PCI_DEVICE_ID_PLX_R685		0x1030
+#define PCI_DEVICE_ID_PLX_DJINN_ITOO    0x1151
+#define PCI_DEVICE_ID_PLX_R753          0x1152
+
+#define PCI_VENDOR_ID_ELSA		0x1048
+#define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+#define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+
+#define PCI_VENDOR_ID_EICON		0x1133
+#define PCI_DEVICE_ID_EICON_DIVA20PRO	0xe001
+#define PCI_DEVICE_ID_EICON_DIVA20	0xe002
+#define PCI_DEVICE_ID_EICON_DIVA20PRO_U	0xe003
+#define PCI_DEVICE_ID_EICON_DIVA20_U	0xe004
+#define PCI_DEVICE_ID_EICON_DIVA201	0xe005
+#define PCI_DEVICE_ID_EICON_MAESTRA	0xe010
+#define PCI_DEVICE_ID_EICON_MAESTRAQ	0xe012
+#define PCI_DEVICE_ID_EICON_MAESTRAQ_U	0xe013
+#define PCI_DEVICE_ID_EICON_MAESTRAP	0xe014
+ 
+#define PCI_VENDOR_ID_CCD		0x1397
+#define PCI_DEVICE_ID_CCD_2BD0	        0x2BD0
+#define PCI_DEVICE_ID_CCD_B000	        0xB000
+#define PCI_DEVICE_ID_CCD_B006	        0xB006
+#define PCI_DEVICE_ID_CCD_B007	        0xB007
+#define PCI_DEVICE_ID_CCD_B008	        0xB008
+#define PCI_DEVICE_ID_CCD_B009	        0xB009
+#define PCI_DEVICE_ID_CCD_B00A	        0xB00A
+#define PCI_DEVICE_ID_CCD_B00B	        0xB00B
+#define PCI_DEVICE_ID_CCD_B00C	        0xB00C
+#define PCI_DEVICE_ID_CCD_B100	        0xB100
+
+#define PCI_VENDOR_ID_ASUSTEK           0x1043   
+#define PCI_DEVICE_ID_ASUSTEK_0675      0x0675
+
+#define PCI_VENDOR_ID_BERKOM		        0x0871
+#define PCI_DEVICE_ID_BERKOM_A1T	        0xFFA1
+#define PCI_DEVICE_ID_BERKOM_T_CONCEPT          0xFFA2
+#define PCI_DEVICE_ID_BERKOM_A4T	        0xFFA4
+#define PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO      0xFFA8
+
+#define PCI_DEVICE_ID_SATSAGEM_NICCY	0x1016
+
+#define PCI_DEVICE_ID_TIGERJET_100	0x0002
+
+#define PCI_VENDOR_ID_ANIGMA		0x1051
+#define PCI_DEVICE_ID_ANIGMA_MC145575	0x0100
+
+#define PCI_VENDOR_ID_ZOLTRIX		0x15b0
+#define PCI_DEVICE_ID_ZOLTRIX_2BD0	0x2BD0
+
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_E	0x0070
+#define PCI_DEVICE_ID_DIGI_DF_M_E	0x0071
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_A	0x0072
+#define PCI_DEVICE_ID_DIGI_DF_M_A	0x0073
+
+#define PCI_DEVICE_ID_AVM_B1		0x0700
+#define PCI_DEVICE_ID_AVM_C4		0x0800
+#define PCI_DEVICE_ID_AVM_C2		0x1100
+#define PCI_DEVICE_ID_AVM_T1		0x1200
+
+#define PCI_VENDOR_ID_HYPERCOPE		0x1365
+#define PCI_DEVICE_ID_HYPERCOPE_PLX	0x9050
+#define PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO     0x0104
+#define PCI_SUBDEVICE_ID_HYPERCOPE_ERGO         0x0106
+#define PCI_SUBDEVICE_ID_HYPERCOPE_METRO        0x0107
+#define PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2       0x0108
+#define PCI_SUBDEVICE_ID_HYPERCOPE_PLEXUS       0x0109
+
+#define PCI_VENDOR_ID_ABOCOM            0x13D1
+#define PCI_DEVICE_ID_ABOCOM_2BD1       0x2BD1
+
+#endif /* COMPAT_NEED_PCI_IDS */
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_ISDN_COMPAT_H */
diff -urN linux-2.4.30.old/include/linux/isdn_divertif.h linux-2.4.30.dev/include/linux/isdn_divertif.h
--- linux-2.4.30.old/include/linux/isdn_divertif.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn_divertif.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: isdn_divertif.h,v 1.1.4.1 2001/11/20 14:19:38 kai Exp $
+/* $Id$
  *
  * Header for the diversion supplementary interface for i4l.
  *
@@ -14,7 +14,7 @@
 /***********************************************************/
 /* magic value is also used to control version information */
 /***********************************************************/
-#define DIVERT_IF_MAGIC 0x25873401
+#define DIVERT_IF_MAGIC 0x25873402
 #define DIVERT_CMD_REG  0x00  /* register command */
 #define DIVERT_CMD_REL  0x01  /* release command */
 #define DIVERT_NO_ERR   0x00  /* return value no error */
@@ -34,6 +34,7 @@
     int (*ll_cmd)(isdn_ctrl *); /* supplied by hl on return */
     char * (*drv_to_name)(int); /* map a driver id to name, supplied by hl */
     int (*name_to_drv)(char *); /* map a driver id to name, supplied by hl */
+    int (*dial_net_name)(char *); /* force dial of a ll net interface  */
   } isdn_divert_if;
 
 /*********************/
diff -urN linux-2.4.30.old/include/linux/isdn_dwabc.h linux-2.4.30.dev/include/linux/isdn_dwabc.h
--- linux-2.4.30.old/include/linux/isdn_dwabc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn_dwabc.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,84 @@
+/* $Id: isdn_dwabc.h,v 1.9 2001/09/26 20:32:08 detabc Exp $
+ *
+ * Header for the Linux ISDN abc-extension.
+ *
+ * Copyright           by abc GmbH
+ *                     written by Detlef Wengorz <detlefw@isdn4linux.de>
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef ISDN_DWABC_H
+#define ISDN_DWABC_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+
+typedef struct ISDN_DWSPINLOCK {
+
+	spinlock_t 	spin;
+	short  		owner;
+	short		my_flags;
+	ulong 		irq_flags;
+
+} ISDN_DWSPINLOCK;
+
+#define ISDN_DWSPIN_UNLOCKED				\
+	(ISDN_DWSPINLOCK) {						\
+		spin: 		SPIN_LOCK_UNLOCKED,		\
+		owner:		-1,						\
+		my_flags:	0,						\
+		irq_flags:	0,						\
+	}
+
+#define ISDN_DWSPIN_INIT(x)			\
+			do { *(x) = ISDN_DWSPIN_UNLOCKED; } while(0);
+
+static __inline__ int isdn_dwspin_trylock(ISDN_DWSPINLOCK *spin)
+{
+	if(!spin_trylock(&spin->spin)) {
+
+		if(spin->owner == smp_processor_id())
+			return(-EAGAIN);
+
+		spin_lock(&spin->spin);
+	}
+
+	spin->owner = smp_processor_id();
+	return(0);
+}
+
+static __inline__ void isdn_dwspin_unlock(ISDN_DWSPINLOCK *spin)
+{
+	spin->owner = -1;
+	spin_unlock(&spin->spin);
+}
+
+
+#else
+#include <sys/types.h>
+#endif
+
+#define DWABC_LCR_FLG_NEWNUMBER		0x00000001L
+#define DWABC_LCR_FLG_DISABLE		0x00000002L
+#define DWABC_LCR_FLG_NEWHUPTIME	0x00000004L
+
+
+struct ISDN_DWABC_LCR_IOCTL {
+
+	int 	lcr_ioctl_sizeof;	/* mustbe sizeof(ISDN_DWABC_LCR_IOCTL)	*/
+	u_short lcr_ioctl_onhtime;	/* new hanguptime						*/
+	u_long 	lcr_ioctl_callid;	/* callid from lcr-subsystem			*/
+	u_long 	lcr_ioctl_flags;	/* see above							*/
+	char 	lcr_ioctl_nr[32];	/* new destination phonenumber			*/
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/isdn.h linux-2.4.30.dev/include/linux/isdn.h
--- linux-2.4.30.old/include/linux/isdn.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: isdn.h,v 1.1.4.1 2001/11/20 14:19:38 kai Exp $
+/* $Id: isdn.h,v 1.125 2001/12/01 23:18:21 detabc Exp $
  *
  * Main header for the Linux ISDN subsystem (linklevel).
  *
@@ -14,6 +14,7 @@
 #ifndef __ISDN_H__
 #define __ISDN_H__
 
+#include <linux/isdn_compat.h>
 #include <linux/ioctl.h>
 
 #ifdef CONFIG_COBALT_MICRO_SERVER
@@ -93,9 +94,15 @@
 #define ISDN_LMSNLEN         255 /* Length of tty's Listen-MSN string */
 #define ISDN_CMSGLEN	     50	 /* Length of CONNECT-Message to add for Modem */
 
+#ifdef BIG_PHONE_NUMBERS
 #define ISDN_MSNLEN          32
 #define NET_DV 0x06  /* Data version for isdn_net_ioctl_cfg   */
 #define TTY_DV 0x06  /* Data version for iprofd etc.          */
+#else
+#define ISDN_MSNLEN          20
+#define NET_DV 0x05  /* Data version for isdn_net_ioctl_cfg   */
+#define TTY_DV 0x05  /* Data version for iprofd etc.          */
+#endif
 
 #define INF_DV 0x01  /* Data version for /dev/isdninfo        */
 
@@ -187,6 +194,61 @@
 #define ISDN_MINOR_PPPMAX   (128 + (ISDN_MAX_CHANNELS-1))
 #define ISDN_MINOR_STATUS   255
 
+#ifndef CONFIG_ISDN_WITH_ABC
+#undef CONFIG_ISDN_WITH_ABC_CALLB
+#undef CONFIG_ISDN_WITH_ABC_UDP_CHECK
+#undef CONFIG_ISDN_WITH_ABC_UDP_CHECK_HANGUP
+#undef CONFIG_ISDN_WITH_ABC_UDP_CHECK_DIAL
+#undef CONFIG_ISDN_WITH_ABC_OUTGOING_EAZ
+#undef CONFIG_ISDN_WITH_ABC_LCR_SUPPORT
+#undef CONFIG_ISDN_WITH_ABC_RCV_NO_HUPTIMER
+#undef CONFIG_ISDN_WITH_ABC_CH_EXTINUSE
+#undef CONFIG_ISDN_WITH_ABC_CONN_ERROR
+#undef CONFIG_ISDN_WITH_ABC_RAWIPCOMPRESS
+#else /* CONFIG_ISDN_WITH_ABC */
+#include <linux/isdn_dwabc.h>
+
+
+typedef struct DWABCJIFFIES {
+
+	u_long	msec_1000;
+	u_long  msec_500;
+	u_long	msec_400;
+	u_long	msec_200;
+	u_long	msec_100;
+
+} DWABCJIFFIES;
+
+
+#ifdef CONFIG_ISDN_WITH_ABC_NEED_DWSJIFFIES
+DWABCJIFFIES isdn_dwabc_jiffies;
+#else
+extern DWABCJIFFIES isdn_dwabc_jiffies;
+#endif
+#define dwsjiffies (isdn_dwabc_jiffies.msec_1000)
+
+#define ISDN_DW_ABC_FLAG_UNUSED00001		0x00000001L
+#define ISDN_DW_ABC_FLAG_NO_UDP_CHECK		0x00000002L
+#define ISDN_DW_ABC_FLAG_NO_UDP_HANGUP		0x00000004L
+#define ISDN_DW_ABC_FLAG_NO_UDP_DIAL		0x00000008L
+#define ISDN_DW_ABC_FLAG_UNUSED00010		0x00000010L
+#define ISDN_DW_ABC_FLAG_RCV_NO_HUPTIMER	0x00000020L
+#define ISDN_DW_ABC_FLAG_NO_CH_EXTINUSE		0x00000040L
+#define ISDN_DW_ABC_FLAG_NO_CONN_ERROR		0x00000080L
+#define ISDN_DW_ABC_FLAG_BSD_COMPRESS		0x00000100L
+#define ISDN_DW_ABC_FLAG_NO_LCR				0x00000200L
+#define ISDN_DW_ABC_FLAG_LEASED_LINE		0x00001000L
+
+#define ISDN_DW_ABC_IFFLAG_NODCHAN			0x00000001L
+#define ISDN_DW_ABC_IFFLAG_BSDAKTIV			0x00000002L
+
+#define ISDN_DW_ABC_BITLOCK_SEND			0
+#define ISDN_DW_ABC_BITLOCK_RECEIVE			1
+
+#endif /* CONFIG_ISDN_WITH_ABC */
+
+
+
 #ifdef CONFIG_ISDN_PPP
 
 #ifdef CONFIG_ISDN_PPP_VJ
@@ -204,9 +266,11 @@
 #  include <linux/concap.h>
 #endif
 
+#ifdef HAVE_DEVFS_FS
 #ifdef CONFIG_DEVFS_FS
 #  include <linux/devfs_fs_kernel.h>
 #endif
+#endif /* HAVE_DEVFS_FS */
 
 #include <linux/isdnif.h>
 
@@ -272,6 +336,12 @@
 #define ISDN_NET_CALLBACK   0x04       /* activate callback                 */
 #define ISDN_NET_CBHUP      0x08       /* hangup before callback            */
 #define ISDN_NET_CBOUT      0x10       /* remote machine does callback      */
+#if 0
+/* Unused??? */
+#define ISDN_NET_CLONE      0x08       /* clone a tmp interface when called */
+#define ISDN_NET_TMP        0x10       /* tmp interface until getting an IP */
+#define ISDN_NET_DYNAMIC    0x20       /* this link is dynamically allocated */
+#endif
 
 #define ISDN_NET_MAGIC      0x49344C02 /* for paranoia-checking             */
 
@@ -386,6 +456,38 @@
   char cisco_debserint;			/* debugging flag of cisco hdlc with slarp */
   struct timer_list cisco_timer;
   struct tq_struct tqueue;
+#ifdef CONFIG_ISDN_WITH_ABC
+  ulong 	dw_abc_flags;
+  ulong 	dw_abc_if_flags;
+  int   	dw_abc_inuse_secure;
+  ulong 	dw_abc_dialstart;
+  int   	dw_abc_old_onhtime;
+  int 		dw_abc_remote_version;
+  int		dw_abc_bitlocks;
+#ifdef CONFIG_ISDN_WITH_ABC_OUTGOING_EAZ
+  char	dw_out_msn[ISDN_MSNLEN]; /* eaz for outgoing call if *out_msn != 0 */
+#endif
+#ifdef CONFIG_ISDN_WITH_ABC_LCR_SUPPORT
+  ulong 				dw_abc_lcr_callid;
+  ulong 				dw_abc_lcr_start_request;
+  ulong 				dw_abc_lcr_end_request;
+  isdn_ctrl 			*dw_abc_lcr_cmd;
+  struct ISDN_DWABC_LCR_IOCTL	*dw_abc_lcr_io;
+#endif
+  ulong dw_abc_bchan_last_connect;
+#ifdef CONFIG_ISDN_WITH_ABC_CONN_ERROR
+  short dw_abc_bchan_errcnt;
+#endif
+#ifdef CONFIG_ISDN_WITH_ABC_RAWIPCOMPRESS
+  void *dw_abc_bsd_compressor;
+  void *dw_abc_bsd_stat_rx;
+  void *dw_abc_bsd_stat_tx;
+#endif
+  ulong	dw_abc_bsd_snd;
+  ulong	dw_abc_bsd_bsd_snd;
+  ulong	dw_abc_bsd_rcv;
+  ulong	dw_abc_bsd_bsd_rcv;
+#endif
 } isdn_net_local;
 
 /* the interface itself */
@@ -608,12 +710,13 @@
 	int               tflags;                    /* Timer-Flags:               */
 	/*  see ISDN_TIMER_..defines  */
 	int               global_flags;
-	infostruct        *infochain;                /* List of open info-devs.    */
-	wait_queue_head_t info_waitq;               /* Wait-Queue for isdninfo    */
 	struct timer_list timer;		       /* Misc.-function Timer       */
 	int               chanmap[ISDN_MAX_CHANNELS];/* Map minor->device-channel  */
 	int               drvmap[ISDN_MAX_CHANNELS]; /* Map minor->driver-index    */
 	int               usage[ISDN_MAX_CHANNELS];  /* Used by tty/ip/voice       */
+#ifdef CONFIG_ISDN_WITH_ABC_CH_EXTINUSE
+	ulong			  dwabc_chan_external_inuse[ISDN_MAX_CHANNELS];
+#endif
 	char              num[ISDN_MAX_CHANNELS][ISDN_MSNLEN];
 	/* Remote number of active ch.*/
 	int               m_idx[ISDN_MAX_CHANNELS];  /* Index for mdm....          */
@@ -631,6 +734,7 @@
 	isdn_v110_stream  *v110[ISDN_MAX_CHANNELS];  /* V.110 private data         */
 	struct semaphore  sem;                       /* serialize list access*/
 	unsigned long     global_features;
+#ifdef HAVE_DEVFS_FS
 #ifdef CONFIG_DEVFS_FS
 	devfs_handle_t devfs_handle_isdninfo;
 	devfs_handle_t devfs_handle_isdnctrl;
@@ -640,10 +744,41 @@
 	devfs_handle_t devfs_handle_ipppX[ISDN_MAX_CHANNELS];
 #endif
 #endif /* CONFIG_DEVFS_FS */
+#endif /* HAVE_DEVFS_FS */
 } isdn_dev;
 
 extern isdn_dev *dev;
 
+#ifdef CONFIG_ISDN_WITH_ABC
+extern int isdn_auto_dial_helper(isdn_net_local *,struct sk_buff *,int);
+extern void dwisdn_nfw_send(isdn_net_local *lp,int drop_only);
+extern void isdn_net_unreachable(struct net_device *,struct sk_buff *,char *);
+extern void isdn_net_log_skb_dwabc(struct sk_buff *,isdn_net_local *,char *);
+extern void isdn_net_hangup(struct net_device *d);
+extern void isdn_dw_clear_if(ulong pm,isdn_net_local *);
+extern void isdn_dwabc_test_phone(isdn_net_local *);
+extern void isdn_dw_abc_init_func(void);
+extern void isdn_dw_abc_release_func(void);
+extern int isdn_dw_abc_reset_interface(isdn_net_local *,int);
+extern int dwabc_bsd_init(isdn_net_local *lp);
+extern void dwabc_bsd_free(isdn_net_local *lp);
+extern struct sk_buff *dwabc_bsd_compress(isdn_net_local *,struct sk_buff *,struct net_device *);
+extern void dwabc_bsd_first_gen(isdn_net_local *);
+extern struct sk_buff *dwabc_bsd_rx_pkt(isdn_net_local *,struct sk_buff *,struct net_device *);
+#ifdef CONFIG_ISDN_WITH_ABC_LCR_SUPPORT
+extern size_t isdn_dw_abc_lcr_readstat(char *,size_t);
+extern ulong isdn_dw_abc_lcr_call_number(isdn_net_local *,isdn_ctrl *);
+extern void isdn_dw_abc_lcr_open(void);
+extern void isdn_dw_abc_lcr_close(void);
+extern int isdn_dw_abc_lcr_ioctl(ulong);
+extern void isdn_dw_abc_lcr_clear(isdn_net_local *);
+extern int isdn_dw_abc_lcr_lock(void);
+extern void isdn_dw_abc_lcr_ulock(void);
+#endif
+#ifdef CONFIG_ISDN_WITH_ABC_UDP_CHECK
+extern int dw_abc_udp_test(struct sk_buff *skb,struct net_device *ndev); 
+#endif
+#endif
 
 #endif /* __KERNEL__ */
 
diff -urN linux-2.4.30.old/include/linux/isdnif.h linux-2.4.30.dev/include/linux/isdnif.h
--- linux-2.4.30.old/include/linux/isdnif.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdnif.h	2008-05-11 02:17:53.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: isdnif.h,v 1.1.4.1 2001/11/20 14:19:38 kai Exp $
+/* $Id: isdnif.h,v 1.43 2002/02/09 21:19:11 keil Exp $
  *
  * Linux ISDN subsystem
  * Definition of the interface between the subsystem and its low-level drivers.
@@ -14,6 +14,7 @@
 #ifndef __ISDNIF_H__
 #define __ISDNIF_H__
 
+#include <linux/isdn_compat.h>
 
 /*
  * Values for general protocol-selection
@@ -213,6 +214,8 @@
 #define ISDN_STAT_FAXIND  276    /* FAX indications from HL-driver        */
 #define ISDN_STAT_AUDIO   277    /* DTMF, DSP indications                 */
 #define ISDN_STAT_DISCH   278    /* Disable/Enable channel usage          */
+#define ISDN_STAT_ALERT   279    /* Signal alerting                       */
+#define ISDN_STAT_PROCEED 280    /* Signal proceeding                     */
 
 /*
  * Audio commands
@@ -282,42 +285,42 @@
 
 typedef struct T30_s {
 	/* session parameters */
-	__u8 resolution		__attribute__ ((packed));
-	__u8 rate		__attribute__ ((packed));
-	__u8 width		__attribute__ ((packed));
-	__u8 length		__attribute__ ((packed));
-	__u8 compression	__attribute__ ((packed));
-	__u8 ecm		__attribute__ ((packed));
-	__u8 binary		__attribute__ ((packed));
-	__u8 scantime		__attribute__ ((packed));
-	__u8 id[FAXIDLEN]	__attribute__ ((packed));
+	__u8 resolution;
+	__u8 rate;
+	__u8 width;
+	__u8 length;
+	__u8 compression;
+	__u8 ecm;
+	__u8 binary;
+	__u8 scantime;
+	__u8 id[FAXIDLEN];
 	/* additional parameters */
-	__u8 phase		__attribute__ ((packed));
-	__u8 direction		__attribute__ ((packed));
-	__u8 code		__attribute__ ((packed));
-	__u8 badlin		__attribute__ ((packed));
-	__u8 badmul		__attribute__ ((packed));
-	__u8 bor		__attribute__ ((packed));
-	__u8 fet		__attribute__ ((packed));
-	__u8 pollid[FAXIDLEN]	__attribute__ ((packed));
-	__u8 cq			__attribute__ ((packed));
-	__u8 cr			__attribute__ ((packed));
-	__u8 ctcrty		__attribute__ ((packed));
-	__u8 minsp		__attribute__ ((packed));
-	__u8 phcto		__attribute__ ((packed));
-	__u8 rel		__attribute__ ((packed));
-	__u8 nbc		__attribute__ ((packed));
+	__u8 phase;
+	__u8 direction;
+	__u8 code;
+	__u8 badlin;
+	__u8 badmul;
+	__u8 bor;
+	__u8 fet;
+	__u8 pollid[FAXIDLEN];
+	__u8 cq;
+	__u8 cr;
+	__u8 ctcrty;
+	__u8 minsp;
+	__u8 phcto;
+	__u8 rel;
+	__u8 nbc;
 	/* remote station parameters */
-	__u8 r_resolution	__attribute__ ((packed));
-	__u8 r_rate		__attribute__ ((packed));
-	__u8 r_width		__attribute__ ((packed));
-	__u8 r_length		__attribute__ ((packed));
-	__u8 r_compression	__attribute__ ((packed));
-	__u8 r_ecm		__attribute__ ((packed));
-	__u8 r_binary		__attribute__ ((packed));
-	__u8 r_scantime		__attribute__ ((packed));
-	__u8 r_id[FAXIDLEN]	__attribute__ ((packed));
-	__u8 r_code		__attribute__ ((packed));
+	__u8 r_resolution;
+	__u8 r_rate;
+	__u8 r_width;
+	__u8 r_length;
+	__u8 r_compression;
+	__u8 r_ecm;
+	__u8 r_binary;
+	__u8 r_scantime;
+	__u8 r_id[FAXIDLEN];
+	__u8 r_code;
 } T30_s;
 
 #define ISDN_TTY_FAX_CONN_IN	0
diff -urN linux-2.4.30.old/include/linux/isdn_lzscomp.h linux-2.4.30.dev/include/linux/isdn_lzscomp.h
--- linux-2.4.30.old/include/linux/isdn_lzscomp.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.30.dev/include/linux/isdn_lzscomp.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: isdn_lzscomp.h,v 1.1.4.1 2001/11/20 14:19:38 kai Exp $
+/* $Id$
  *
  * Header for isdn_lzscomp.c
  * Concentrated here to not mess up half a dozen kernel headers with code
diff -urN linux-2.4.30.old/include/linux/isdn_ppp.h linux-2.4.30.dev/include/linux/isdn_ppp.h
--- linux-2.4.30.old/include/linux/isdn_ppp.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/linux/isdn_ppp.h	2008-05-11 02:17:52.000000000 +0200
@@ -8,6 +8,7 @@
 #ifndef _LINUX_ISDN_PPP_H
 #define _LINUX_ISDN_PPP_H
 
+#include <linux/isdn_compat.h>
 
 #define CALLTYPE_INCOMING 0x1
 #define CALLTYPE_OUTGOING 0x2
@@ -33,6 +34,11 @@
 #define PPPIOCSCOMPRESSOR _IOW('t',135,int)
 #define PPPIOCGIFNAME      _IOR('t',136, char [IFNAMSIZ] )
 
+#ifdef COMPAT_NEED_MPPP_DEFS
+#define PPP_MP          0x003d
+#define PPP_COMPFRAG    0x00fb
+#define PPP_CCPFRAG     0x80fb
+#endif
 
 #define SC_MP_PROT       0x00000200
 #define SC_REJ_MP_PROT   0x00000400
@@ -65,9 +71,6 @@
 
 #include <linux/config.h>
 
-#ifdef CONFIG_IPPP_FILTER
-#include <linux/filter.h>
-#endif
 
 #define DECOMP_ERR_NOMEM	(-10)
 
@@ -226,10 +229,6 @@
   unsigned char *cbuf;
   struct slcompress *slcomp;
 #endif
-#ifdef CONFIG_IPPP_FILTER
-  struct sock_fprog pass_filter;	/* filter for packets to pass */
-  struct sock_fprog active_filter;	/* filter for pkts to reset idle */
-#endif
   unsigned long debug;
   struct isdn_ppp_compressor *compressor,*decompressor;
   struct isdn_ppp_compressor *link_compressor,*link_decompressor;
diff -urN linux-2.4.30.old/include/linux/i2c-algo-au1550.h linux-2.4.30.dev/include/linux/i2c-algo-au1550.h
--- linux-2.4.30.old/include/linux/i2c-algo-au1550.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/i2c-algo-au1550.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef I2C_ALGO_AU1550_H
+#define I2C_ALGO_AU1550_H 1
+
+struct i2c_algo_au1550_data {
+	u32	psc_base;
+	int	xfer_timeout;
+	int	ack_timeout;
+};
+
+int i2c_au1550_add_bus(struct i2c_adapter *);
+int i2c_au1550_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_ALGO_AU1550_H */
diff -urN linux-2.4.30.old/include/linux/i2c-algo-bit.h linux-2.4.30.dev/include/linux/i2c-algo-bit.h
--- linux-2.4.30.old/include/linux/i2c-algo-bit.h	2000-12-11 22:15:41.000000000 +0100
+++ linux-2.4.30.dev/include/linux/i2c-algo-bit.h	2008-05-11 02:17:53.000000000 +0200
@@ -42,13 +42,12 @@
 	int  (*getscl) (void *data);
 
 	/* local settings */
-	int udelay;
-	int mdelay;
-	int timeout;
+	int udelay;		/* half-clock-cycle time in microsecs */
+				/* i.e. clock is (500 / udelay) KHz */
+	int mdelay;		/* in millisecs, unused */
+	int timeout;		/* in jiffies */
 };
 
-#define I2C_BIT_ADAP_MAX	16
-
 int i2c_bit_add_bus(struct i2c_adapter *);
 int i2c_bit_del_bus(struct i2c_adapter *);
 
diff -urN linux-2.4.30.old/include/linux/i2c-algo-pcf.h linux-2.4.30.dev/include/linux/i2c-algo-pcf.h
--- linux-2.4.30.old/include/linux/i2c-algo-pcf.h	2000-12-11 22:22:34.000000000 +0100
+++ linux-2.4.30.dev/include/linux/i2c-algo-pcf.h	2008-05-11 02:17:53.000000000 +0200
@@ -44,8 +44,6 @@
 	int timeout;
 };
 
-#define I2C_PCF_ADAP_MAX	16
-
 int i2c_pcf_add_bus(struct i2c_adapter *);
 int i2c_pcf_del_bus(struct i2c_adapter *);
 
diff -urN linux-2.4.30.old/include/linux/i2c.h linux-2.4.30.dev/include/linux/i2c.h
--- linux-2.4.30.old/include/linux/i2c.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/i2c.h	2008-05-11 02:17:53.000000000 +0200
@@ -70,15 +70,7 @@
 
 /* Transfer num messages.
  */
-extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],int num);
-
-/*
- * Some adapter types (i.e. PCF 8584 based ones) may support slave behaviuor. 
- * This is not tested/implemented yet and will change in the future.
- */
-extern int i2c_slave_send(struct i2c_client *,char*,int);
-extern int i2c_slave_recv(struct i2c_client *,char*,int);
-
+extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msg,int num);
 
 
 /* This is the very generalized SMBus access routine. You probably do not
@@ -147,14 +139,14 @@
 	 */
 	int (*command)(struct i2c_client *client,unsigned int cmd, void *arg);
 	
-	/* These two are mainly used for bookkeeping & dynamic unloading of 
+	/* These two are used for bookkeeping & dynamic unloading of
 	 * kernel modules. inc_use tells the driver that a client is being  
 	 * used by another module & that it should increase its ref. counter.
 	 * dec_use is the inverse operation.
 	 * NB: Make sure you have no circular dependencies, or else you get a 
 	 * deadlock when trying to unload the modules.
-	* You should use the i2c_{inc,dec}_use_client functions instead of
-	* calling this function directly.
+	 * You should use the i2c_{inc,dec}_use_client functions instead of
+	 * calling this function directly.
 	 */
 	void (*inc_use)(struct i2c_client *client);
 	void (*dec_use)(struct i2c_client *client);
@@ -193,11 +185,11 @@
 	char name[32];				/* textual description 	*/
 	unsigned int id;
 
-	/* If an adapter algorithm can't to I2C-level access, set master_xfer
+	/* If an adapter algorithm can't do I2C-level access, set master_xfer
 	   to NULL. If an adapter algorithm can do SMBus access, set 
 	   smbus_xfer. If set to NULL, the SMBus protocol is simulated
 	   using common I2C messages */
-	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg msgs[], 
+	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, 
 	                   int num);
 	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, 
 	                   unsigned short flags, char read_write,
@@ -390,23 +382,23 @@
 #define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* New I2C-like block */
 #define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* transfer */
 
-#define I2C_FUNC_SMBUS_BYTE I2C_FUNC_SMBUS_READ_BYTE | \
-                            I2C_FUNC_SMBUS_WRITE_BYTE
-#define I2C_FUNC_SMBUS_BYTE_DATA I2C_FUNC_SMBUS_READ_BYTE_DATA | \
-                                 I2C_FUNC_SMBUS_WRITE_BYTE_DATA
-#define I2C_FUNC_SMBUS_WORD_DATA I2C_FUNC_SMBUS_READ_WORD_DATA | \
-                                 I2C_FUNC_SMBUS_WRITE_WORD_DATA
-#define I2C_FUNC_SMBUS_BLOCK_DATA I2C_FUNC_SMBUS_READ_BLOCK_DATA | \
-                                  I2C_FUNC_SMBUS_WRITE_BLOCK_DATA
-#define I2C_FUNC_SMBUS_I2C_BLOCK I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
-                                  I2C_FUNC_SMBUS_WRITE_I2C_BLOCK
-
-#define I2C_FUNC_SMBUS_EMUL I2C_FUNC_SMBUS_QUICK | \
-                            I2C_FUNC_SMBUS_BYTE | \
-                            I2C_FUNC_SMBUS_BYTE_DATA | \
-                            I2C_FUNC_SMBUS_WORD_DATA | \
-                            I2C_FUNC_SMBUS_PROC_CALL | \
-                            I2C_FUNC_SMBUS_WRITE_BLOCK_DATA
+#define I2C_FUNC_SMBUS_BYTE (I2C_FUNC_SMBUS_READ_BYTE | \
+                             I2C_FUNC_SMBUS_WRITE_BYTE)
+#define I2C_FUNC_SMBUS_BYTE_DATA (I2C_FUNC_SMBUS_READ_BYTE_DATA | \
+                                  I2C_FUNC_SMBUS_WRITE_BYTE_DATA)
+#define I2C_FUNC_SMBUS_WORD_DATA (I2C_FUNC_SMBUS_READ_WORD_DATA | \
+                                  I2C_FUNC_SMBUS_WRITE_WORD_DATA)
+#define I2C_FUNC_SMBUS_BLOCK_DATA (I2C_FUNC_SMBUS_READ_BLOCK_DATA | \
+                                   I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)
+#define I2C_FUNC_SMBUS_I2C_BLOCK (I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
+                                  I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)
+
+#define I2C_FUNC_SMBUS_EMUL (I2C_FUNC_SMBUS_QUICK | \
+                             I2C_FUNC_SMBUS_BYTE | \
+                             I2C_FUNC_SMBUS_BYTE_DATA | \
+                             I2C_FUNC_SMBUS_WORD_DATA | \
+                             I2C_FUNC_SMBUS_PROC_CALL | \
+                             I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)
 
 /* 
  * Data for SMBus Messages 
@@ -458,17 +450,9 @@
 
 #define I2C_FUNCS	0x0705	/* Get the adapter functionality */
 #define I2C_RDWR	0x0707	/* Combined R/W transfer (one stop only)*/
-#if 0
-#define I2C_ACK_TEST	0x0710	/* See if a slave is at a specific address */
-#endif
 
 #define I2C_SMBUS	0x0720	/* SMBus-level access */
 
-/* ... algo-bit.c recognizes */
-#define I2C_UDELAY	0x0705	/* set delay in microsecs between each	*/
-				/* written byte (except address)	*/
-#define I2C_MDELAY	0x0706	/* millisec delay between written bytes */
-
 /* ----- I2C-DEV: char device interface stuff ------------------------- */
 
 #define I2C_MAJOR	89		/* Device major number		*/
diff -urN linux-2.4.30.old/include/linux/i2c-id.h linux-2.4.30.dev/include/linux/i2c-id.h
--- linux-2.4.30.old/include/linux/i2c-id.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/linux/i2c-id.h	2008-05-11 02:17:53.000000000 +0200
@@ -91,9 +91,9 @@
 #define I2C_DRIVERID_SP5055	44     /* Satellite tuner		*/
 #define I2C_DRIVERID_STV0030	45     /* Multipurpose switch		*/
 #define I2C_DRIVERID_ADV7175	48     /* ADV 7175/7176 video encoder	*/
-#define I2C_DRIVERID_MAX1617	56     /* temp sensor			*/
-#define I2C_DRIVERID_SAA7191	57     /* video decoder                 */
-#define I2C_DRIVERID_INDYCAM	58     /* SGI IndyCam			*/
+#define I2C_DRIVERID_MAX1617	56	/* temp sensor			*/
+#define I2C_DRIVERID_SAA7191	57	/* video decoder		*/
+#define I2C_DRIVERID_INDYCAM	58	/* SGI IndyCam			*/
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
 #define I2C_DRIVERID_EXP1	0xF1
@@ -152,9 +152,10 @@
 
 #define I2C_ALGO_MPC8XX 0x110000	/* MPC8xx PowerPC I2C algorithm */
 
-#define I2C_ALGO_SIBYTE 0x120000	/* Broadcom SiByte SOCs		*/
+#define I2C_ALGO_SIBYTE 0x150000	/* Broadcom SiByte SOCs		*/
+#define I2C_ALGO_SGI	0x160000	/* SGI algorithm		*/
 
-#define I2C_ALGO_SGI	0x130000	/* SGI algorithm		*/
+#define I2C_ALGO_AU1550	0x140000	/* Alchemy Au1550 PSC		*/
 
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
@@ -204,6 +205,9 @@
 #define I2C_HW_SGI_VINO	0x00
 #define I2C_HW_SGI_MACE	0x01
 
+/* --- Au1550 PSC adapters						*/
+#define I2C_HW_AU1550_PSC	0x00
+
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
 #define I2C_HW_SMBUS_ALI15X3	0x01
diff -urN linux-2.4.30.old/include/linux/i2c-proc.h linux-2.4.30.dev/include/linux/i2c-proc.h
--- linux-2.4.30.old/include/linux/i2c-proc.h	2001-10-11 17:05:47.000000000 +0200
+++ linux-2.4.30.dev/include/linux/i2c-proc.h	2008-05-11 02:17:53.000000000 +0200
@@ -1,6 +1,7 @@
 /*
-    sensors.h - Part of lm_sensors, Linux kernel modules for hardware
-                monitoring
+    i2c-proc.h - Part of the i2c package
+    was originally sensors.h - Part of lm_sensors, Linux kernel modules
+                               for hardware monitoring
     Copyright (c) 1998, 1999  Frodo Looijaard <frodol@dds.nl>
 
     This program is free software; you can redistribute it and/or modify
@@ -23,9 +24,6 @@
 
 #ifdef __KERNEL__
 
-/* Next two must be included before sysctl.h can be included, in 2.0 kernels */
-#include <linux/types.h>
-#include <linux/fs.h>
 #include <linux/sysctl.h>
 
 /* The type of callback functions used in sensors_{proc,sysctl}_real */
@@ -362,7 +360,7 @@
 
 /* This macro is used to scale user-input to sensible values in almost all
    chip drivers. */
-extern inline int SENSORS_LIMIT(long value, long low, long high)
+static inline int SENSORS_LIMIT(long value, long low, long high)
 {
 	if (value < low)
 		return low;
diff -urN linux-2.4.30.old/include/linux/kernelcapi.h linux-2.4.30.dev/include/linux/kernelcapi.h
--- linux-2.4.30.old/include/linux/kernelcapi.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.30.dev/include/linux/kernelcapi.h	2008-05-11 02:17:52.000000000 +0200
@@ -1,12 +1,10 @@
-/* $Id: kernelcapi.h,v 1.1.4.2 2002/01/28 18:25:10 kai Exp $
+/*
+ * $Id: kernelcapi.h,v 1.9 2000/11/28 09:34:02 kai Exp $
  * 
  * Kernel CAPI 2.0 Interface for Linux
  * 
  * (c) Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
  * 
- * This software may be used and distributed according to the terms
- * of the GNU General Public License, incorporated herein by reference.
- *
  */
 
 #ifndef __KERNELCAPI_H__
diff -urN linux-2.4.30.old/include/linux/libata-compat.h linux-2.4.30.dev/include/linux/libata-compat.h
--- linux-2.4.30.old/include/linux/libata-compat.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/libata-compat.h	2008-05-11 02:17:53.000000000 +0200
@@ -12,8 +12,25 @@
 #define DMA_64BIT_MASK 0xffffffffffffffffULL
 #define DMA_32BIT_MASK 0x00000000ffffffffULL
 
+/* These definitions mirror those in pci.h, so they can be used
+ * interchangeably with their PCI_ counterparts */
+enum dma_data_direction {
+	DMA_BIDIRECTIONAL = 0,
+	DMA_TO_DEVICE = 1,
+	DMA_FROM_DEVICE = 2,
+	DMA_NONE = 3,
+};
+
+#define offset_in_page(p)	((unsigned long)(p) & ~PAGE_MASK)
+
 #define MODULE_VERSION(ver_str)
 
+/* remaps usage of KM_IRQ0 onto KM_SOFTIRQ0. KM_IRQ0 only exists on ia64 in
+ * 2.4. Warning: this will also remap KM_IRQ0 on ia64, so be careful about
+ * the files included after this file. */
+
+#define KM_IRQ0	KM_SOFTIRQ0
+
 struct device {
 	struct pci_dev pdev;
 };
@@ -23,9 +40,24 @@
 	return (struct pci_dev *) dev;
 }
 
-#define pci_set_consistent_dma_mask(pdev,mask) (0)
+#define pdev_printk(lvl, pdev, fmt, args...)			\
+	do {							\
+		printk("%s%s(%s): ", lvl,			\
+			(pdev)->driver && (pdev)->driver->name ? \
+				(pdev)->driver->name : "PCI",	\
+			pci_name(pdev));			\
+		printk(fmt, ## args);				\
+	} while (0)
+
+static inline int pci_enable_msi(struct pci_dev *dev) { return -1; }
+static inline void pci_disable_msi(struct pci_dev *dev) {}
 
-#define DMA_FROM_DEVICE PCI_DMA_FROMDEVICE
+static inline int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (mask == (u64)dev->dma_mask)
+		return 0;
+	return -EIO;
+}
 
 /* NOTE: dangerous! we ignore the 'gfp' argument */
 #define dma_alloc_coherent(dev,sz,dma,gfp) \
@@ -59,4 +91,77 @@
 	return mem;
 }
 
+static inline void *kzalloc(size_t size, int flags)
+{
+	return kcalloc(1, size, flags);
+}
+
+static inline void pci_iounmap(struct pci_dev *pdev, void *mem)
+{
+	iounmap(mem);
+}
+
+/**
+ * pci_intx - enables/disables PCI INTx for device dev
+ * @pdev: the PCI device to operate on
+ * @enable: boolean: whether to enable or disable PCI INTx
+ *
+ * Enables/disables PCI INTx for device dev
+ */
+static inline void
+pci_intx(struct pci_dev *pdev, int enable)
+{
+	u16 pci_command, new;
+
+	pci_read_config_word(pdev, PCI_COMMAND, &pci_command);
+
+	if (enable) {
+		new = pci_command & ~PCI_COMMAND_INTX_DISABLE;
+	} else {
+		new = pci_command | PCI_COMMAND_INTX_DISABLE;
+	}
+
+	if (new != pci_command) {
+		pci_write_config_word(pdev, PCI_COMMAND, new);
+	}
+}
+
+static inline void __iomem *
+pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
+{
+	unsigned long start = pci_resource_start(dev, bar);
+	unsigned long len = pci_resource_len(dev, bar);
+	unsigned long flags = pci_resource_flags(dev, bar);
+
+	if (!len || !start)
+		return NULL;
+	if (maxlen && len > maxlen)
+		len = maxlen;
+	if (flags & IORESOURCE_IO) {
+		BUG();
+	}
+	if (flags & IORESOURCE_MEM) {
+		if (flags & IORESOURCE_CACHEABLE)
+			return ioremap(start, len);
+		return ioremap_nocache(start, len);
+	}
+	/* What? */
+	return NULL;
+}
+
+static inline void sg_set_buf(struct scatterlist *sg, void *buf,
+			      unsigned int buflen)
+{
+	sg->page = virt_to_page(buf);
+	sg->offset = offset_in_page(buf);
+	sg->length = buflen;
+}
+
+static inline void sg_init_one(struct scatterlist *sg, void *buf,
+			       unsigned int buflen)
+{
+	memset(sg, 0, sizeof(*sg));
+	sg_set_buf(sg, buf, buflen);
+}
+
 #endif /* __LIBATA_COMPAT_H__ */
diff -urN linux-2.4.30.old/include/linux/libata.h linux-2.4.30.dev/include/linux/libata.h
--- linux-2.4.30.old/include/linux/libata.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/libata.h	2008-05-11 02:17:53.000000000 +0200
@@ -1,23 +1,26 @@
 /*
-   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
-   Copyright 2003-2004 Jeff Garzik
-
-   The contents of this file are subject to the Open
-   Software License version 1.1 that can be found at
-   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
-   by reference.
-
-   Alternatively, the contents of this file may be used under the terms
-   of the GNU General Public License version 2 (the "GPL") as distributed
-   in the kernel source COPYING file, in which case the provisions of
-   the GPL are applicable instead of the above.  If you wish to allow
-   the use of your version of this file only under the terms of the
-   GPL and not to allow others to use your version of this file under
-   the OSL, indicate your decision by deleting the provisions above and
-   replace them with the notice and other provisions required by the GPL.
-   If you do not delete the provisions above, a recipient may use your
-   version of this file under either the OSL or the GPL.
-
+ *  Copyright 2003-2005 Red Hat, Inc.  All rights reserved.
+ *  Copyright 2003-2005 Jeff Garzik
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
  */
 
 #ifndef __LINUX_LIBATA_H__
@@ -38,7 +41,6 @@
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
-#undef ATA_ENABLE_ATAPI		/* define to enable ATAPI support */
 #undef ATA_ENABLE_PATA		/* define to enable PATA support in some
 				 * low-level drivers */
 #undef ATAPI_ENABLE_DMADIR	/* enables ATAPI DMADIR bridge support */
@@ -57,6 +59,8 @@
 #define VPRINTK(fmt, args...)
 #endif	/* ATA_DEBUG */
 
+#define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+
 #ifdef ATA_NDEBUG
 #define assert(expr)
 #else
@@ -90,12 +94,13 @@
 	ATA_SHT_NEW_EH_CODE	= 0, /* IORL hack, part one */
 	ATA_SHT_CMD_PER_LUN	= 1,
 	ATA_SHT_THIS_ID		= -1,
-	ATA_SHT_USE_CLUSTERING	= 0,
+	ATA_SHT_USE_CLUSTERING	= 1,
 
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
 	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
 	ATA_DFLAG_LOCK_SECTORS	= (1 << 2), /* don't adjust max_sectors */
+	ATA_DFLAG_LBA		= (1 << 3), /* device supports LBA */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -114,6 +119,9 @@
 	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
 	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
+	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
+					     * proper HSM is in place. */
+	ATA_FLAG_DEBUGMSG	= (1 << 10),
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
@@ -151,17 +159,32 @@
 	ATA_SHIFT_UDMA		= 0,
 	ATA_SHIFT_MWDMA		= 8,
 	ATA_SHIFT_PIO		= 11,
-};
 
-enum pio_task_states {
-	PIO_ST_UNKNOWN,
-	PIO_ST_IDLE,
-	PIO_ST_POLL,
-	PIO_ST_TMOUT,
-	PIO_ST,
-	PIO_ST_LAST,
-	PIO_ST_LAST_POLL,
-	PIO_ST_ERR,
+	/* size of buffer to pad xfers ending on unaligned boundaries */
+	ATA_DMA_PAD_SZ		= 4,
+	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
+	
+	/* Masks for port functions */
+	ATA_PORT_PRIMARY	= (1 << 0),
+	ATA_PORT_SECONDARY	= (1 << 1),
+};
+
+enum hsm_task_states {
+	HSM_ST_UNKNOWN,
+	HSM_ST_IDLE,
+	HSM_ST_POLL,
+	HSM_ST_TMOUT,
+	HSM_ST,
+	HSM_ST_LAST,
+	HSM_ST_LAST_POLL,
+	HSM_ST_ERR,
+};
+
+enum ata_completion_errors {
+	AC_ERR_OTHER		= (1 << 0),
+	AC_ERR_DEV		= (1 << 1),
+	AC_ERR_ATA_BUS		= (1 << 2),
+	AC_ERR_HOST_BUS		= (1 << 3),
 };
 
 /* forward declarations */
@@ -171,7 +194,7 @@
 struct ata_queued_cmd;
 
 /* typedefs */
-typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, u8 drv_stat);
+typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, unsigned int err_mask);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;
@@ -194,7 +217,7 @@
 struct ata_probe_ent {
 	struct list_head	node;
 	struct device 		*dev;
-	struct ata_port_operations	*port_ops;
+	const struct ata_port_operations *port_ops;
 	Scsi_Host_Template	*sht;
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
@@ -217,7 +240,7 @@
 	void __iomem		*mmio_base;
 	unsigned int		n_ports;
 	void			*private_data;
-	struct ata_port_operations *ops;
+	const struct ata_port_operations *ops;
 	struct ata_port *	ports[0];
 };
 
@@ -234,9 +257,12 @@
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
+	unsigned int		orig_n_elem;
 
 	int			dma_dir;
 
+	unsigned int		pad_len;
+
 	unsigned int		nsect;
 	unsigned int		cursect;
 
@@ -247,9 +273,11 @@
 	unsigned int		cursg_ofs;
 
 	struct scatterlist	sgent;
+	struct scatterlist	pad_sgent;
 	void			*buf_virt;
 
-	struct scatterlist	*sg;
+	/* DO NOT iterate over __sg manually, use ata_for_each_sg() */
+	struct scatterlist	*__sg;
 
 	ata_qc_cb_t		complete_fn;
 
@@ -275,15 +303,18 @@
 	u8			xfer_mode;
 	unsigned int		xfer_shift;	/* ATA_SHIFT_xxx */
 
-	/* cache info about current transfer mode */
-	u8			xfer_protocol;	/* taskfile xfer protocol */
-	u8			read_cmd;	/* opcode to use on read */
-	u8			write_cmd;	/* opcode to use on write */
+	unsigned int		multi_count;	/* sectors count for
+						   READ/WRITE MULTIPLE */
+
+	/* for CHS addressing */
+	u16			cylinders;	/* Number of cylinders */
+	u16			heads;		/* Number of heads */
+	u16			sectors;	/* Number of sectors per track */
 };
 
 struct ata_port {
 	struct Scsi_Host	*host;	/* our co-allocated scsi host */
-	struct ata_port_operations	*ops;
+	const struct ata_port_operations *ops;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
 	unsigned int		id;	/* unique id req'd by scsi midlyr */
 	unsigned int		port_no; /* unique port #; from zero */
@@ -292,6 +323,9 @@
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */
 
+	void			*pad;	/* array of DMA pad buffers */
+	dma_addr_t		pad_dma;
+
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 
 	u8			ctl;	/* cache of ATA control register */
@@ -316,7 +350,7 @@
 	struct tq_struct	packet_task;
 
 	struct tq_struct	pio_task;
-	unsigned int		pio_task_state;
+	unsigned int		hsm_task_state;
 	unsigned long		pio_task_timeout;
 
 	void			*private_data;
@@ -330,13 +364,12 @@
 	void (*set_piomode) (struct ata_port *, struct ata_device *);
 	void (*set_dmamode) (struct ata_port *, struct ata_device *);
 
-	void (*tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
+	void (*tf_load) (struct ata_port *ap, const struct ata_taskfile *tf);
 	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
 
-	void (*exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
+	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
 	u8   (*check_status)(struct ata_port *ap);
 	u8   (*check_altstatus)(struct ata_port *ap);
-	u8   (*check_err)(struct ata_port *ap);
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
 	void (*phy_reset) (struct ata_port *ap);
@@ -364,7 +397,7 @@
 
 	void (*host_stop) (struct ata_host_set *host_set);
 
-	void (*bmdma_stop) (struct ata_port *ap);
+	void (*bmdma_stop) (struct ata_queued_cmd *qc);
 	u8   (*bmdma_status) (struct ata_port *ap);
 };
 
@@ -374,9 +407,23 @@
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
-	struct ata_port_operations	*port_ops;
+	const struct ata_port_operations *port_ops;
+	void 			*private_data;
 };
 
+struct ata_timing {
+	unsigned short mode;		/* ATA mode */
+	unsigned short setup;		/* t1 */
+	unsigned short act8b;		/* t2 for 8-bit I/O */
+	unsigned short rec8b;		/* t2i for 8-bit I/O */
+	unsigned short cyc8b;		/* t0 for 8-bit I/O */
+	unsigned short active;		/* t2 or tD */
+	unsigned short recover;		/* t2i or tK */
+	unsigned short cycle;		/* t0 */
+	unsigned short udma;		/* t2CYCTYP/2 */
+};
+
+#define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
 
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
@@ -389,28 +436,31 @@
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
-extern int ata_device_add(struct ata_probe_ent *ent);
+extern int ata_device_add(const struct ata_probe_ent *ent);
+extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(Scsi_Host_Template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_error(struct Scsi_Host *host);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+extern int ata_ratelimit(void);
+
 /*
  * Default driver ops implementations
  */
-extern void ata_tf_load(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
-extern void ata_tf_to_fis(struct ata_taskfile *tf, u8 *fis, u8 pmp);
-extern void ata_tf_from_fis(u8 *fis, struct ata_taskfile *tf);
+extern void ata_tf_to_fis(const struct ata_taskfile *tf, u8 *fis, u8 pmp);
+extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
-extern u8 ata_chk_err(struct ata_port *ap);
-extern void ata_exec_command(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
+extern void ata_host_stop (struct ata_host_set *host_set);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern int ata_qc_issue_prot(struct ata_queued_cmd *qc);
@@ -418,21 +468,48 @@
 		unsigned int buflen);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
-extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
-extern void ata_dev_id_string(u16 *id, unsigned char *s,
+extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
+extern void ata_dev_id_string(const u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
+extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
-extern void ata_bmdma_stop(struct ata_port *ap);
+extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern void ata_qc_complete(struct ata_queued_cmd *qc, u8 drv_stat);
+extern void ata_qc_complete(struct ata_queued_cmd *qc, unsigned int err_mask);
 extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_scsi_simulate(u16 *id, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern void ata_add_to_probe_list (struct ata_probe_ent *probe_ent);
 extern int ata_std_bios_param(Disk * disk, kdev_t dev, int *ip);
 
+/*
+ * Timing helpers
+ */
+extern int ata_timing_compute(struct ata_device *, unsigned short,
+			      struct ata_timing *, int, int);
+extern void ata_timing_merge(const struct ata_timing *,
+			     const struct ata_timing *, struct ata_timing *,
+			     unsigned int);
+
+enum {
+	ATA_TIMING_SETUP	= (1 << 0),
+	ATA_TIMING_ACT8B	= (1 << 1),
+	ATA_TIMING_REC8B	= (1 << 2),
+	ATA_TIMING_CYC8B	= (1 << 3),
+	ATA_TIMING_8BIT		= ATA_TIMING_ACT8B | ATA_TIMING_REC8B |
+				  ATA_TIMING_CYC8B,
+	ATA_TIMING_ACTIVE	= (1 << 4),
+	ATA_TIMING_RECOVER	= (1 << 5),
+	ATA_TIMING_CYCLE	= (1 << 6),
+	ATA_TIMING_UDMA		= (1 << 7),
+	ATA_TIMING_ALL		= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |
+				  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |
+				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
+				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
+};
+
 
 #ifdef CONFIG_PCI
 struct pci_bits {
@@ -442,19 +519,45 @@
 	unsigned long		val;
 };
 
+extern void ata_pci_host_stop (struct ata_host_set *host_set);
 extern struct ata_probe_ent *
-ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port);
-extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
+ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
+extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 
 #endif /* CONFIG_PCI */
 
 
+static inline int
+ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
+{
+	if (sg == &qc->pad_sgent)
+		return 1;
+	if (qc->pad_len)
+		return 0;
+	if (((sg - qc->__sg) + 1) == qc->n_elem)
+		return 1;
+	return 0;
+}
+
+static inline struct scatterlist *
+ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
+{
+	if (sg == &qc->pad_sgent)
+		return NULL;
+	if (++sg - qc->__sg < qc->n_elem)
+		return sg;
+	return qc->pad_len ? &qc->pad_sgent : NULL;
+}
+
+#define ata_for_each_sg(sg, qc) \
+	for (sg = qc->__sg; sg; sg = ata_qc_next_sg(sg, qc))
+
 static inline unsigned int ata_tag_valid(unsigned int tag)
 {
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
-static inline unsigned int ata_dev_present(struct ata_device *dev)
+static inline unsigned int ata_dev_present(const struct ata_device *dev)
 {
 	return ((dev->class == ATA_DEV_ATA) ||
 		(dev->class == ATA_DEV_ATAPI));
@@ -465,12 +568,34 @@
 	return ap->ops->check_status(ap);
 }
 
+
+/**
+ *	ata_pause - Flush writes and pause 400 nanoseconds.
+ *	@ap: Port to wait for.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline void ata_pause(struct ata_port *ap)
 {
 	ata_altstatus(ap);
 	ndelay(400);
 }
 
+
+/**
+ *	ata_busy_wait - Wait for a port status register
+ *	@ap: Port to wait for.
+ *
+ *	Waits up to max*10 microseconds for the selected bits in the port's
+ *	status register to be cleared.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
 			       unsigned int max)
 {
@@ -485,6 +610,18 @@
 	return status;
 }
 
+
+/**
+ *	ata_wait_idle - Wait for a port to be idle.
+ *	@ap: Port to wait for.
+ *
+ *	Waits up to 10ms for port's BUSY and DRQ signals to clear.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_wait_idle(struct ata_port *ap)
 {
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
@@ -523,6 +660,29 @@
 		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
 }
 
+static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
+{
+	qc->__sg = NULL;
+	qc->flags = 0;
+	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
+	qc->nsect = 0;
+	qc->nbytes = qc->curbytes = 0;
+
+	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
+}
+
+
+/**
+ *	ata_irq_on - Enable interrupts on a port.
+ *	@ap: Port on which interrupts are enabled.
+ *
+ *	Enable interrupts on a legacy IDE device using MMIO or PIO,
+ *	wait for idle, clear any pending interrupts.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_irq_on(struct ata_port *ap)
 {
 	struct ata_ioports *ioaddr = &ap->ioaddr;
@@ -542,6 +702,18 @@
 	return tmp;
 }
 
+
+/**
+ *	ata_irq_ack - Acknowledge a device interrupt.
+ *	@ap: Port on which interrupts are enabled.
+ *
+ *	Wait up to 10 ms for legacy IDE device to become idle (BUSY
+ *	or BUSY+DRQ clear).  Obtain dma status and port status from
+ *	device.  Clear the interrupt.  Return port status.
+ *
+ *	LOCKING:
+ */
+
 static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 {
 	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;
@@ -583,16 +755,53 @@
 	ap->ops->scr_write(ap, reg, val);
 }
 
+static inline void scr_write_flush(struct ata_port *ap, unsigned int reg,
+				   u32 val)
+{
+	ap->ops->scr_write(ap, reg, val);
+	(void) ap->ops->scr_read(ap, reg);
+}
+
 static inline unsigned int sata_dev_present(struct ata_port *ap)
 {
 	return ((scr_read(ap, SCR_STATUS) & 0xf) == 0x3) ? 1 : 0;
 }
 
-static inline int ata_try_flush_cache(struct ata_device *dev)
+static inline int ata_try_flush_cache(const struct ata_device *dev)
 {
 	return ata_id_wcache_enabled(dev->id) ||
 	       ata_id_has_flush(dev->id) ||
 	       ata_id_has_flush_ext(dev->id);
 }
 
+static inline unsigned int ac_err_mask(u8 status)
+{
+	if (status & ATA_BUSY)
+		return AC_ERR_ATA_BUS;
+	if (status & (ATA_ERR | ATA_DF))
+		return AC_ERR_DEV;
+	return 0;
+}
+
+static inline unsigned int __ac_err_mask(u8 status)
+{
+	unsigned int mask = ac_err_mask(status);
+	if (mask == 0)
+		return AC_ERR_OTHER;
+	return mask;
+}
+
+static inline int ata_pad_alloc(struct ata_port *ap, struct device *dev)
+{
+	ap->pad_dma = 0;
+	ap->pad = dma_alloc_coherent(dev, ATA_DMA_PAD_BUF_SZ,
+				     &ap->pad_dma, GFP_KERNEL);
+	return (ap->pad == NULL) ? -ENOMEM : 0;
+}
+
+static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
+{
+	dma_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
+}
+
 #endif /* __LINUX_LIBATA_H__ */
diff -urN linux-2.4.30.old/include/linux/mm.h linux-2.4.30.dev/include/linux/mm.h
--- linux-2.4.30.old/include/linux/mm.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/mm.h	2008-05-11 02:17:53.000000000 +0200
@@ -117,6 +117,7 @@
 /* read ahead limits */
 extern int vm_min_readahead;
 extern int vm_max_readahead;
+extern unsigned long mmap_min_addr;
 
 /*
  * mapping from the currently active vm_flags protection bits (the
@@ -652,6 +653,11 @@
 	 * page_table_lock lock to serialize against concurrent expand_stacks.
 	 */
 	address &= PAGE_MASK;
+
+	/* ensure a non-privileged process is not trying to mmap lower pages */
+	if (address < mmap_min_addr && !capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
  	spin_lock(&vma->vm_mm->page_table_lock);
 
 	/* already expanded while we were spinning? */
diff -urN linux-2.4.30.old/include/linux/mtd/mtd.h linux-2.4.30.dev/include/linux/mtd/mtd.h
--- linux-2.4.30.old/include/linux/mtd/mtd.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/linux/mtd/mtd.h	2008-05-11 02:17:51.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/version.h>
 #include <linux/types.h>
 #include <linux/mtd/compatmac.h>
+#include <linux/notifier.h>
 #include <linux/module.h>
 #include <linux/uio.h>
 
@@ -217,6 +218,8 @@
 	int (*suspend) (struct mtd_info *mtd);
 	void (*resume) (struct mtd_info *mtd);
 
+	struct notifier_block reboot_notifier;
+
 	void *priv;
 };
 
diff -urN linux-2.4.30.old/include/linux/nbd.h linux-2.4.30.dev/include/linux/nbd.h
--- linux-2.4.30.old/include/linux/nbd.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.30.dev/include/linux/nbd.h	2008-05-11 02:17:53.000000000 +0200
@@ -29,34 +29,6 @@
 
 #include <linux/blk.h>
 
-#ifdef PARANOIA
-extern int requests_in;
-extern int requests_out;
-#endif
-
-static void
-nbd_end_request(struct request *req)
-{
-	struct buffer_head *bh;
-	unsigned nsect;
-	unsigned long flags;
-	int uptodate = (req->errors == 0) ? 1 : 0;
-
-#ifdef PARANOIA
-	requests_out++;
-#endif
-	spin_lock_irqsave(&io_request_lock, flags);
-	while((bh = req->bh) != NULL) {
-		nsect = bh->b_size >> 9;
-		blk_finished_io(nsect);
-		req->bh = bh->b_reqnext;
-		bh->b_reqnext = NULL;
-		bh->b_end_io(bh, uptodate);
-	}
-	blkdev_release_request(req);
-	spin_unlock_irqrestore(&io_request_lock, flags);
-}
-
 #define MAX_NBD 128
 
 struct nbd_device {
diff -urN linux-2.4.30.old/include/linux/ncp_fs.h linux-2.4.30.dev/include/linux/ncp_fs.h
--- linux-2.4.30.old/include/linux/ncp_fs.h	2001-02-09 20:29:44.000000000 +0100
+++ linux-2.4.30.dev/include/linux/ncp_fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -180,9 +180,9 @@
 	ino_t			ino;
 	int			opened;
 	int			access;
-	__u32			server_file_handle __attribute__((packed));
-	__u8			open_create_action __attribute__((packed));
-	__u8			file_handle[6] __attribute__((packed));
+	__u32			server_file_handle;
+	__u8			open_create_action;
+	__u8			file_handle[6];
 };
 
 /* Guess, what 0x564c is :-) */
diff -urN linux-2.4.30.old/include/linux/ncp_fs_i.h linux-2.4.30.dev/include/linux/ncp_fs_i.h
--- linux-2.4.30.old/include/linux/ncp_fs_i.h	2000-06-29 19:42:56.000000000 +0200
+++ linux-2.4.30.dev/include/linux/ncp_fs_i.h	2008-05-11 02:17:53.000000000 +0200
@@ -15,16 +15,16 @@
  * all the information we need to work with an inode after creation.
  */
 struct ncp_inode_info {
-	__u32	dirEntNum __attribute__((packed));
-	__u32	DosDirNum __attribute__((packed));
-	__u32	volNumber __attribute__((packed));
+	__u32	dirEntNum;
+	__u32	DosDirNum;
+	__u32	volNumber;
 	__u32	nwattr;
 	struct semaphore open_sem;
 	atomic_t	opened;
 	int	access;
-	__u32	server_file_handle __attribute__((packed));
-	__u8	open_create_action __attribute__((packed));
-	__u8	file_handle[6] __attribute__((packed));
+	__u32	server_file_handle;
+	__u8	open_create_action;
+	__u8	file_handle[6];
 };
 
 #endif	/* __KERNEL__ */
diff -urN linux-2.4.30.old/include/linux/ncp.h linux-2.4.30.dev/include/linux/ncp.h
--- linux-2.4.30.old/include/linux/ncp.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/linux/ncp.h	2008-05-11 02:17:53.000000000 +0200
@@ -20,28 +20,28 @@
 #define NCP_DEALLOC_SLOT_REQUEST (0x5555)
 
 struct ncp_request_header {
-	__u16 type __attribute__((packed));
-	__u8 sequence __attribute__((packed));
-	__u8 conn_low __attribute__((packed));
-	__u8 task __attribute__((packed));
-	__u8 conn_high __attribute__((packed));
-	__u8 function __attribute__((packed));
-	__u8 data[0] __attribute__((packed));
-};
+	__u16 type;
+	__u8 sequence;
+	__u8 conn_low;
+	__u8 task;
+	__u8 conn_high;
+	__u8 function;
+	__u8 data[0];
+} __attribute__((packed));
 
 #define NCP_REPLY                (0x3333)
 #define NCP_POSITIVE_ACK         (0x9999)
 
 struct ncp_reply_header {
-	__u16 type __attribute__((packed));
-	__u8 sequence __attribute__((packed));
-	__u8 conn_low __attribute__((packed));
-	__u8 task __attribute__((packed));
-	__u8 conn_high __attribute__((packed));
-	__u8 completion_code __attribute__((packed));
-	__u8 connection_state __attribute__((packed));
-	__u8 data[0] __attribute__((packed));
-};
+	__u16 type;
+	__u8 sequence;
+	__u8 conn_low;
+	__u8 task;
+	__u8 conn_high;
+	__u8 completion_code;
+	__u8 connection_state;
+	__u8 data[0];
+} __attribute__((packed));
 
 #define NCP_VOLNAME_LEN (16)
 #define NCP_NUMBER_OF_VOLUMES (256)
@@ -110,33 +110,33 @@
 #endif
 
 struct nw_info_struct {
-	__u32 spaceAlloc __attribute__((packed));
-	__u32 attributes __attribute__((packed));
-	__u16 flags __attribute__((packed));
-	__u32 dataStreamSize __attribute__((packed));
-	__u32 totalStreamSize __attribute__((packed));
-	__u16 numberOfStreams __attribute__((packed));
-	__u16 creationTime __attribute__((packed));
-	__u16 creationDate __attribute__((packed));
-	__u32 creatorID __attribute__((packed));
-	__u16 modifyTime __attribute__((packed));
-	__u16 modifyDate __attribute__((packed));
-	__u32 modifierID __attribute__((packed));
-	__u16 lastAccessDate __attribute__((packed));
-	__u16 archiveTime __attribute__((packed));
-	__u16 archiveDate __attribute__((packed));
-	__u32 archiverID __attribute__((packed));
-	__u16 inheritedRightsMask __attribute__((packed));
-	__u32 dirEntNum __attribute__((packed));
-	__u32 DosDirNum __attribute__((packed));
-	__u32 volNumber __attribute__((packed));
-	__u32 EADataSize __attribute__((packed));
-	__u32 EAKeyCount __attribute__((packed));
-	__u32 EAKeySize __attribute__((packed));
-	__u32 NSCreator __attribute__((packed));
-	__u8 nameLen __attribute__((packed));
-	__u8 entryName[256] __attribute__((packed));
-};
+	__u32 spaceAlloc;
+	__u32 attributes;
+	__u16 flags;
+	__u32 dataStreamSize;
+	__u32 totalStreamSize;
+	__u16 numberOfStreams;
+	__u16 creationTime;
+	__u16 creationDate;
+	__u32 creatorID;
+	__u16 modifyTime;
+	__u16 modifyDate;
+	__u32 modifierID;
+	__u16 lastAccessDate;
+	__u16 archiveTime;
+	__u16 archiveDate;
+	__u32 archiverID;
+	__u16 inheritedRightsMask;
+	__u32 dirEntNum;
+	__u32 DosDirNum;
+	__u32 volNumber;
+	__u32 EADataSize;
+	__u32 EAKeyCount;
+	__u32 EAKeySize;
+	__u32 NSCreator;
+	__u8 nameLen;
+	__u8 entryName[256];
+} __attribute__((packed));
 
 /* modify mask - use with MODIFY_DOS_INFO structure */
 #define DM_ATTRIBUTES		  (ntohl(0x02000000L))
@@ -154,26 +154,26 @@
 #define DM_MAXIMUM_SPACE	  (ntohl(0x00200000L))
 
 struct nw_modify_dos_info {
-	__u32 attributes __attribute__((packed));
-	__u16 creationDate __attribute__((packed));
-	__u16 creationTime __attribute__((packed));
-	__u32 creatorID __attribute__((packed));
-	__u16 modifyDate __attribute__((packed));
-	__u16 modifyTime __attribute__((packed));
-	__u32 modifierID __attribute__((packed));
-	__u16 archiveDate __attribute__((packed));
-	__u16 archiveTime __attribute__((packed));
-	__u32 archiverID __attribute__((packed));
-	__u16 lastAccessDate __attribute__((packed));
-	__u16 inheritanceGrantMask __attribute__((packed));
-	__u16 inheritanceRevokeMask __attribute__((packed));
-	__u32 maximumSpace __attribute__((packed));
-};
+	__u32 attributes;
+	__u16 creationDate;
+	__u16 creationTime;
+	__u32 creatorID;
+	__u16 modifyDate;
+	__u16 modifyTime;
+	__u32 modifierID;
+	__u16 archiveDate;
+	__u16 archiveTime;
+	__u32 archiverID;
+	__u16 lastAccessDate;
+	__u16 inheritanceGrantMask;
+	__u16 inheritanceRevokeMask;
+	__u32 maximumSpace;
+} __attribute__((packed));
 
 struct nw_search_sequence {
-	__u8 volNumber __attribute__((packed));
-	__u32 dirBase __attribute__((packed));
-	__u32 sequence __attribute__((packed));
-};
+	__u8 volNumber;
+	__u32 dirBase;
+	__u32 sequence;
+} __attribute__((packed));
 
 #endif				/* _LINUX_NCP_H */
diff -urN linux-2.4.30.old/include/linux/netdevice.h linux-2.4.30.dev/include/linux/netdevice.h
--- linux-2.4.30.old/include/linux/netdevice.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netdevice.h	2008-05-11 02:17:54.000000000 +0200
@@ -297,7 +297,7 @@
 	 * See <net/iw_handler.h> for details. Jean II */
 	struct iw_handler_def *	wireless_handlers;
 
-	struct ethtool_ops *ethtool_ops;
+
 
 	/*
 	 * This marks the end of the "visible" part of the structure. All
@@ -352,8 +352,8 @@
 
 	struct Qdisc		*qdisc;
 	struct Qdisc		*qdisc_sleeping;
+	struct Qdisc		*qdisc_list;
 	struct Qdisc		*qdisc_ingress;
-	struct list_head	qdisc_list;
 	unsigned long		tx_queue_len;	/* Max frames per queue allowed */
 
 	/* hard_start_xmit synchronizer */
@@ -453,6 +453,7 @@
 	/* this will get initialized at each interface type init routine */
 	struct divert_blk	*divert;
 #endif /* CONFIG_NET_DIVERT */
+	struct ethtool_ops *ethtool_ops;
 };
 
 /* 2.6 compatibility */
diff -urN linux-2.4.30.old/include/linux/netfilter_arp/arp_tables.h linux-2.4.30.dev/include/linux/netfilter_arp/arp_tables.h
--- linux-2.4.30.old/include/linux/netfilter_arp/arp_tables.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30.dev/include/linux/netfilter_arp/arp_tables.h	2008-05-11 02:17:52.000000000 +0200
@@ -154,7 +154,7 @@
 #define ARPT_CONTINUE 0xFFFFFFFF
 
 /* For standard target */
-#define ARPT_RETURN (-NF_MAX_VERDICT - 1)
+#define ARPT_RETURN (-NF_REPEAT - 1)
 
 /* The argument to ARPT_SO_GET_INFO */
 struct arpt_getinfo
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebtables.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebtables.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebtables.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebtables.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,361 @@
+/*
+ *  ebtables
+ *
+ *	Authors:
+ *	Bart De Schuymer		<bart.de.schuymer@pandora.be>
+ *
+ *  ebtables.c,v 2.0, September, 2002
+ *
+ *  This code is stongly inspired on the iptables code which is
+ *  Copyright (C) 1999 Paul `Rusty' Russell & Michael J. Neuling
+ */
+
+#ifndef __LINUX_BRIDGE_EFF_H
+#define __LINUX_BRIDGE_EFF_H
+#include <linux/if.h>
+#include <linux/netfilter_bridge.h>
+#include <linux/if_ether.h>
+
+#define EBT_TABLE_MAXNAMELEN 32
+#define EBT_CHAIN_MAXNAMELEN EBT_TABLE_MAXNAMELEN
+#define EBT_FUNCTION_MAXNAMELEN EBT_TABLE_MAXNAMELEN
+
+// verdicts >0 are "branches"
+#define EBT_ACCEPT   -1
+#define EBT_DROP     -2
+#define EBT_CONTINUE -3
+#define EBT_RETURN   -4
+#define NUM_STANDARD_TARGETS   4
+
+struct ebt_counter
+{
+	uint64_t pcnt;
+	uint64_t bcnt;
+};
+
+struct ebt_entries {
+	// this field is always set to zero
+	// See EBT_ENTRY_OR_ENTRIES.
+	// Must be same size as ebt_entry.bitmask
+	unsigned int distinguisher;
+	// the chain name
+	char name[EBT_CHAIN_MAXNAMELEN];
+	// counter offset for this chain
+	unsigned int counter_offset;
+	// one standard (accept, drop, return) per hook
+	int policy;
+	// nr. of entries
+	unsigned int nentries;
+	// entry list
+	char data[0];
+};
+
+// used for the bitmask of struct ebt_entry
+
+// This is a hack to make a difference between an ebt_entry struct and an
+// ebt_entries struct when traversing the entries from start to end.
+// Using this simplifies the code alot, while still being able to use
+// ebt_entries.
+// Contrary, iptables doesn't use something like ebt_entries and therefore uses
+// different techniques for naming the policy and such. So, iptables doesn't
+// need a hack like this.
+#define EBT_ENTRY_OR_ENTRIES 0x01
+// these are the normal masks
+#define EBT_NOPROTO 0x02
+#define EBT_802_3 0x04
+#define EBT_SOURCEMAC 0x08
+#define EBT_DESTMAC 0x10
+#define EBT_F_MASK (EBT_NOPROTO | EBT_802_3 | EBT_SOURCEMAC | EBT_DESTMAC \
+   | EBT_ENTRY_OR_ENTRIES)
+
+#define EBT_IPROTO 0x01
+#define EBT_IIN 0x02
+#define EBT_IOUT 0x04
+#define EBT_ISOURCE 0x8
+#define EBT_IDEST 0x10
+#define EBT_ILOGICALIN 0x20
+#define EBT_ILOGICALOUT 0x40
+#define EBT_INV_MASK (EBT_IPROTO | EBT_IIN | EBT_IOUT | EBT_ILOGICALIN \
+   | EBT_ILOGICALOUT | EBT_ISOURCE | EBT_IDEST)
+
+struct ebt_entry_match
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct ebt_match *match;
+	} u;
+	// size of data
+	unsigned int match_size;
+	unsigned char data[0];
+};
+
+struct ebt_entry_watcher
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct ebt_watcher *watcher;
+	} u;
+	// size of data
+	unsigned int watcher_size;
+	unsigned char data[0];
+};
+
+struct ebt_entry_target
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct ebt_target *target;
+	} u;
+	// size of data
+	unsigned int target_size;
+	unsigned char data[0];
+};
+
+#define EBT_STANDARD_TARGET "standard"
+struct ebt_standard_target
+{
+	struct ebt_entry_target target;
+	int verdict;
+};
+
+// one entry
+struct ebt_entry {
+	// this needs to be the first field
+	unsigned int bitmask;
+	unsigned int invflags;
+	uint16_t ethproto;
+	// the physical in-dev
+	char in[IFNAMSIZ];
+	// the logical in-dev
+	char logical_in[IFNAMSIZ];
+	// the physical out-dev
+	char out[IFNAMSIZ];
+	// the logical out-dev
+	char logical_out[IFNAMSIZ];
+	unsigned char sourcemac[ETH_ALEN];
+	unsigned char sourcemsk[ETH_ALEN];
+	unsigned char destmac[ETH_ALEN];
+	unsigned char destmsk[ETH_ALEN];
+	// sizeof ebt_entry + matches
+	unsigned int watchers_offset;
+	// sizeof ebt_entry + matches + watchers
+	unsigned int target_offset;
+	// sizeof ebt_entry + matches + watchers + target
+	unsigned int next_offset;
+	unsigned char elems[0];
+};
+
+struct ebt_replace
+{
+	char name[EBT_TABLE_MAXNAMELEN];
+	unsigned int valid_hooks;
+	// nr of rules in the table
+	unsigned int nentries;
+	// total size of the entries
+	unsigned int entries_size;
+	// start of the chains
+	struct ebt_entries *hook_entry[NF_BR_NUMHOOKS];
+	// nr of counters userspace expects back
+	unsigned int num_counters;
+	// where the kernel will put the old counters
+	struct ebt_counter *counters;
+	char *entries;
+};
+
+// [gs]etsockopt numbers
+#define EBT_BASE_CTL            128
+
+#define EBT_SO_SET_ENTRIES      (EBT_BASE_CTL)
+#define EBT_SO_SET_COUNTERS     (EBT_SO_SET_ENTRIES+1)
+#define EBT_SO_SET_MAX          (EBT_SO_SET_COUNTERS+1)
+
+#define EBT_SO_GET_INFO         (EBT_BASE_CTL)
+#define EBT_SO_GET_ENTRIES      (EBT_SO_GET_INFO+1)
+#define EBT_SO_GET_INIT_INFO    (EBT_SO_GET_ENTRIES+1)
+#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO+1)
+#define EBT_SO_GET_MAX          (EBT_SO_GET_INIT_ENTRIES+1)
+
+#ifdef __KERNEL__
+
+// return values for match() functions
+#define EBT_MATCH 0
+#define EBT_NOMATCH 1
+
+struct ebt_match
+{
+	struct list_head list;
+	const char name[EBT_FUNCTION_MAXNAMELEN];
+	// 0 == it matches
+	int (*match)(const struct sk_buff *skb, const struct net_device *in,
+	   const struct net_device *out, const void *matchdata,
+	   unsigned int datalen);
+	// 0 == let it in
+	int (*check)(const char *tablename, unsigned int hookmask,
+	   const struct ebt_entry *e, void *matchdata, unsigned int datalen);
+	void (*destroy)(void *matchdata, unsigned int datalen);
+	struct module *me;
+};
+
+struct ebt_watcher
+{
+	struct list_head list;
+	const char name[EBT_FUNCTION_MAXNAMELEN];
+	void (*watcher)(const struct sk_buff *skb, unsigned int hooknr,
+	   const struct net_device *in, const struct net_device *out,
+	   const void *watcherdata, unsigned int datalen);
+	// 0 == let it in
+	int (*check)(const char *tablename, unsigned int hookmask,
+	   const struct ebt_entry *e, void *watcherdata, unsigned int datalen);
+	void (*destroy)(void *watcherdata, unsigned int datalen);
+	struct module *me;
+};
+
+struct ebt_target
+{
+	struct list_head list;
+	const char name[EBT_FUNCTION_MAXNAMELEN];
+	// returns one of the standard verdicts
+	int (*target)(struct sk_buff **pskb, unsigned int hooknr,
+	   const struct net_device *in, const struct net_device *out,
+	   const void *targetdata, unsigned int datalen);
+	// 0 == let it in
+	int (*check)(const char *tablename, unsigned int hookmask,
+	   const struct ebt_entry *e, void *targetdata, unsigned int datalen);
+	void (*destroy)(void *targetdata, unsigned int datalen);
+	struct module *me;
+};
+
+// used for jumping from and into user defined chains (udc)
+struct ebt_chainstack
+{
+	struct ebt_entries *chaininfo; // pointer to chain data
+	struct ebt_entry *e; // pointer to entry data
+	unsigned int n; // n'th entry
+};
+
+struct ebt_table_info
+{
+	// total size of the entries
+	unsigned int entries_size;
+	unsigned int nentries;
+	// pointers to the start of the chains
+	struct ebt_entries *hook_entry[NF_BR_NUMHOOKS];
+	// room to maintain the stack used for jumping from and into udc
+	struct ebt_chainstack **chainstack;
+	char *entries;
+	struct ebt_counter counters[0] ____cacheline_aligned;
+};
+
+struct ebt_table
+{
+	struct list_head list;
+	char name[EBT_TABLE_MAXNAMELEN];
+	struct ebt_replace *table;
+	unsigned int valid_hooks;
+	rwlock_t lock;
+	// e.g. could be the table explicitly only allows certain
+	// matches, targets, ... 0 == let it in
+	int (*check)(const struct ebt_table_info *info,
+	   unsigned int valid_hooks);
+	// the data used by the kernel
+	struct ebt_table_info *private;
+};
+
+#define EBT_ALIGN(s) (((s) + (__alignof__(struct ebt_entry_target)-1)) & \
+		     ~(__alignof__(struct ebt_entry_target)-1))
+extern int ebt_register_table(struct ebt_table *table);
+extern void ebt_unregister_table(struct ebt_table *table);
+extern int ebt_register_match(struct ebt_match *match);
+extern void ebt_unregister_match(struct ebt_match *match);
+extern int ebt_register_watcher(struct ebt_watcher *watcher);
+extern void ebt_unregister_watcher(struct ebt_watcher *watcher);
+extern int ebt_register_target(struct ebt_target *target);
+extern void ebt_unregister_target(struct ebt_target *target);
+extern unsigned int ebt_do_table(unsigned int hook, struct sk_buff **pskb,
+   const struct net_device *in, const struct net_device *out,
+   struct ebt_table *table);
+
+   // Used in the kernel match() functions
+#define FWINV(bool,invflg) ((bool) ^ !!(info->invflags & invflg))
+// True if the hook mask denotes that the rule is in a base chain,
+// used in the check() functions
+#define BASE_CHAIN (hookmask & (1 << NF_BR_NUMHOOKS))
+// Clear the bit in the hook mask that tells if the rule is on a base chain
+#define CLEAR_BASE_CHAIN_BIT (hookmask &= ~(1 << NF_BR_NUMHOOKS))
+// True if the target is not a standard target
+#define INVALID_TARGET (info->target < -NUM_STANDARD_TARGETS || info->target >= 0)
+
+#endif /* __KERNEL__ */
+
+// blatently stolen from ip_tables.h
+// fn returns 0 to continue iteration
+#define EBT_MATCH_ITERATE(e, fn, args...)                   \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry_match *__match;                    \
+	                                                    \
+	for (__i = sizeof(struct ebt_entry);                \
+	     __i < (e)->watchers_offset;                    \
+	     __i += __match->match_size +                   \
+	     sizeof(struct ebt_entry_match)) {              \
+		__match = (void *)(e) + __i;                \
+		                                            \
+		__ret = fn(__match , ## args);              \
+		if (__ret != 0)                             \
+			break;                              \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (e)->watchers_offset)            \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#define EBT_WATCHER_ITERATE(e, fn, args...)                 \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry_watcher *__watcher;                \
+	                                                    \
+	for (__i = e->watchers_offset;                      \
+	     __i < (e)->target_offset;                      \
+	     __i += __watcher->watcher_size +               \
+	     sizeof(struct ebt_entry_watcher)) {            \
+		__watcher = (void *)(e) + __i;              \
+		                                            \
+		__ret = fn(__watcher , ## args);            \
+		if (__ret != 0)                             \
+			break;                              \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (e)->target_offset)              \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#define EBT_ENTRY_ITERATE(entries, size, fn, args...)       \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry *__entry;                          \
+	                                                    \
+	for (__i = 0; __i < (size);) {                      \
+		__entry = (void *)(entries) + __i;          \
+		__ret = fn(__entry , ## args);              \
+		if (__ret != 0)                             \
+			break;                              \
+		if (__entry->bitmask != 0)                  \
+			__i += __entry->next_offset;        \
+		else                                        \
+			__i += sizeof(struct ebt_entries);  \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (size))                          \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_among.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_among.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_among.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_among.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,65 @@
+#ifndef __LINUX_BRIDGE_EBT_AMONG_H
+#define __LINUX_BRIDGE_EBT_AMONG_H
+
+#define EBT_AMONG_DST 0x01
+#define EBT_AMONG_SRC 0x02
+
+/* Grzegorz Borowiak <grzes@gnu.univ.gda.pl> 2003
+ * 
+ * Write-once-read-many hash table, used for checking if a given
+ * MAC address belongs to a set or not and possibly for checking
+ * if it is related with a given IPv4 address.
+ *
+ * The hash value of an address is its last byte.
+ * 
+ * In real-world ethernet addresses, values of the last byte are
+ * evenly distributed and there is no need to consider other bytes.
+ * It would only slow the routines down.
+ *
+ * For MAC address comparison speedup reasons, we introduce a trick.
+ * MAC address is mapped onto an array of two 32-bit integers.
+ * This pair of integers is compared with MAC addresses in the
+ * hash table, which are stored also in form of pairs of integers
+ * (in `cmp' array). This is quick as it requires only two elementary
+ * number comparisons in worst case. Further, we take advantage of
+ * fact that entropy of 3 last bytes of address is larger than entropy
+ * of 3 first bytes. So first we compare 4 last bytes of addresses and
+ * if they are the same we compare 2 first.
+ *
+ * Yes, it is a memory overhead, but in 2003 AD, who cares?
+ */
+
+struct ebt_mac_wormhash_tuple
+{
+	uint32_t cmp[2];
+	uint32_t ip;
+};
+
+struct ebt_mac_wormhash
+{
+	int table[257];
+	int poolsize;
+	struct ebt_mac_wormhash_tuple pool[0];
+};
+
+#define ebt_mac_wormhash_size(x) ((x) ? sizeof(struct ebt_mac_wormhash) \
+		+ (x)->poolsize * sizeof(struct ebt_mac_wormhash_tuple) : 0)
+
+struct ebt_among_info
+{
+	int wh_dst_ofs;
+	int wh_src_ofs;
+	int bitmask;
+};
+
+#define EBT_AMONG_DST_NEG 0x1
+#define EBT_AMONG_SRC_NEG 0x2
+
+#define ebt_among_wh_dst(x) ((x)->wh_dst_ofs ? \
+	(struct ebt_mac_wormhash*)((char*)(x) + (x)->wh_dst_ofs) : NULL)
+#define ebt_among_wh_src(x) ((x)->wh_src_ofs ? \
+	(struct ebt_mac_wormhash*)((char*)(x) + (x)->wh_src_ofs) : NULL)
+
+#define EBT_AMONG_MATCH "among"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_arp.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_arp.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_arp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_arp.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef __LINUX_BRIDGE_EBT_ARP_H
+#define __LINUX_BRIDGE_EBT_ARP_H
+
+#define EBT_ARP_OPCODE 0x01
+#define EBT_ARP_HTYPE 0x02
+#define EBT_ARP_PTYPE 0x04
+#define EBT_ARP_SRC_IP 0x08
+#define EBT_ARP_DST_IP 0x10
+#define EBT_ARP_SRC_MAC 0x20
+#define EBT_ARP_DST_MAC 0x40
+#define EBT_ARP_MASK (EBT_ARP_OPCODE | EBT_ARP_HTYPE | EBT_ARP_PTYPE | \
+   EBT_ARP_SRC_IP | EBT_ARP_DST_IP | EBT_ARP_SRC_MAC | EBT_ARP_DST_MAC)
+#define EBT_ARP_MATCH "arp"
+
+struct ebt_arp_info
+{
+	uint16_t htype;
+	uint16_t ptype;
+	uint16_t opcode;
+	uint32_t saddr;
+	uint32_t smsk;
+	uint32_t daddr;
+	uint32_t dmsk;
+	unsigned char smaddr[ETH_ALEN];
+	unsigned char smmsk[ETH_ALEN];
+	unsigned char dmaddr[ETH_ALEN];
+	unsigned char dmmsk[ETH_ALEN];
+	uint8_t  bitmask;
+	uint8_t  invflags;
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_arpreply.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_arpreply.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_arpreply.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_arpreply.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_ARPREPLY_H
+#define __LINUX_BRIDGE_EBT_ARPREPLY_H
+
+struct ebt_arpreply_info
+{
+	unsigned char mac[ETH_ALEN];
+	int target;
+};
+#define EBT_ARPREPLY_TARGET "arpreply"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_ip.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_ip.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_ip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_ip.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *  ebt_ip
+ *
+ *	Authors:
+ *	Bart De Schuymer <bart.de.schuymer@pandora.be>
+ *
+ *  April, 2002
+ *
+ *  Changes:
+ *    added ip-sport and ip-dport
+ *    Innominate Security Technologies AG <mhopf@innominate.com>
+ *    September, 2002
+ */
+
+#ifndef __LINUX_BRIDGE_EBT_IP_H
+#define __LINUX_BRIDGE_EBT_IP_H
+
+#define EBT_IP_SOURCE 0x01
+#define EBT_IP_DEST 0x02
+#define EBT_IP_TOS 0x04
+#define EBT_IP_PROTO 0x08
+#define EBT_IP_SPORT 0x10
+#define EBT_IP_DPORT 0x20
+#define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
+ EBT_IP_SPORT | EBT_IP_DPORT )
+#define EBT_IP_MATCH "ip"
+
+// the same values are used for the invflags
+struct ebt_ip_info
+{
+	uint32_t saddr;
+	uint32_t daddr;
+	uint32_t smsk;
+	uint32_t dmsk;
+	uint8_t  tos;
+	uint8_t  protocol;
+	uint8_t  bitmask;
+	uint8_t  invflags;
+	uint16_t sport[2];
+	uint16_t dport[2];
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_limit.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_limit.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_limit.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_limit.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __LINUX_BRIDGE_EBT_LIMIT_H
+#define __LINUX_BRIDGE_EBT_LIMIT_H
+
+#define EBT_LIMIT_MATCH "limit"
+
+/* timings are in milliseconds. */
+#define EBT_LIMIT_SCALE 10000
+
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+
+struct ebt_limit_info
+{
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+	/* Used internally by the kernel */
+	unsigned long prev;
+	u_int32_t credit;
+	u_int32_t credit_cap, cost;
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_log.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_log.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_log.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_log.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,17 @@
+#ifndef __LINUX_BRIDGE_EBT_LOG_H
+#define __LINUX_BRIDGE_EBT_LOG_H
+
+#define EBT_LOG_IP 0x01 // if the frame is made by ip, log the ip information
+#define EBT_LOG_ARP 0x02
+#define EBT_LOG_MASK (EBT_LOG_IP | EBT_LOG_ARP)
+#define EBT_LOG_PREFIX_SIZE 30
+#define EBT_LOG_WATCHER "log"
+
+struct ebt_log_info
+{
+	uint8_t loglevel;
+	uint8_t prefix[EBT_LOG_PREFIX_SIZE];
+	uint32_t bitmask;
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_mark_m.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_mark_m.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_mark_m.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_mark_m.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,15 @@
+#ifndef __LINUX_BRIDGE_EBT_MARK_M_H
+#define __LINUX_BRIDGE_EBT_MARK_M_H
+
+#define EBT_MARK_AND 0x01
+#define EBT_MARK_OR 0x02
+#define EBT_MARK_MASK (EBT_MARK_AND | EBT_MARK_OR)
+struct ebt_mark_m_info
+{
+	unsigned long mark, mask;
+	uint8_t invert;
+	uint8_t bitmask;
+};
+#define EBT_MARK_MATCH "mark_m"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_mark_t.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_mark_t.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_mark_t.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_mark_t.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef __LINUX_BRIDGE_EBT_MARK_T_H
+#define __LINUX_BRIDGE_EBT_MARK_T_H
+
+struct ebt_mark_t_info
+{
+	unsigned long mark;
+	// EBT_ACCEPT, EBT_DROP or EBT_CONTINUE or EBT_RETURN
+	int target;
+};
+#define EBT_MARK_TARGET "mark"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_nat.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_nat.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_nat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_nat.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __LINUX_BRIDGE_EBT_NAT_H
+#define __LINUX_BRIDGE_EBT_NAT_H
+
+struct ebt_nat_info
+{
+	unsigned char mac[ETH_ALEN];
+	// EBT_ACCEPT, EBT_DROP, EBT_CONTINUE or EBT_RETURN
+	int target;
+};
+#define EBT_SNAT_TARGET "snat"
+#define EBT_DNAT_TARGET "dnat"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_pkttype.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_pkttype.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_pkttype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_pkttype.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_PKTTYPE_H
+#define __LINUX_BRIDGE_EBT_PKTTYPE_H
+
+struct ebt_pkttype_info
+{
+	uint8_t pkt_type;
+	uint8_t invert;
+};
+#define EBT_PKTTYPE_MATCH "pkttype"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_redirect.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_redirect.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_redirect.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_redirect.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_REDIRECT_H
+#define __LINUX_BRIDGE_EBT_REDIRECT_H
+
+struct ebt_redirect_info
+{
+	// EBT_ACCEPT, EBT_DROP or EBT_CONTINUE or EBT_RETURN
+	int target;
+};
+#define EBT_REDIRECT_TARGET "redirect"
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_stp.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_stp.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_stp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_stp.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,46 @@
+#ifndef __LINUX_BRIDGE_EBT_STP_H
+#define __LINUX_BRIDGE_EBT_STP_H
+
+#define EBT_STP_TYPE		0x0001
+
+#define EBT_STP_FLAGS		0x0002
+#define EBT_STP_ROOTPRIO	0x0004
+#define EBT_STP_ROOTADDR	0x0008
+#define EBT_STP_ROOTCOST	0x0010
+#define EBT_STP_SENDERPRIO	0x0020
+#define EBT_STP_SENDERADDR	0x0040
+#define EBT_STP_PORT		0x0080
+#define EBT_STP_MSGAGE		0x0100
+#define EBT_STP_MAXAGE		0x0200
+#define EBT_STP_HELLOTIME	0x0400
+#define EBT_STP_FWDD		0x0800
+
+#define EBT_STP_MASK		0x0fff
+#define EBT_STP_CONFIG_MASK	0x0ffe
+
+#define EBT_STP_MATCH "stp"
+
+struct ebt_stp_config_info
+{
+	uint8_t flags;
+	uint16_t root_priol, root_priou;
+	char root_addr[6], root_addrmsk[6];
+	uint32_t root_costl, root_costu;
+	uint16_t sender_priol, sender_priou;
+	char sender_addr[6], sender_addrmsk[6];
+	uint16_t portl, portu;
+	uint16_t msg_agel, msg_ageu;
+	uint16_t max_agel, max_ageu;
+	uint16_t hello_timel, hello_timeu;
+	uint16_t forward_delayl, forward_delayu;
+};
+
+struct ebt_stp_info
+{
+	uint8_t type;
+	struct ebt_stp_config_info config;
+	uint16_t bitmask;
+	uint16_t invflags;
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_ulog.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_ulog.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_ulog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_ulog.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,33 @@
+#ifndef _EBT_ULOG_H
+#define _EBT_ULOG_H
+
+#define EBT_ULOG_DEFAULT_NLGROUP 0
+#define EBT_ULOG_DEFAULT_QTHRESHOLD 1
+#define EBT_ULOG_MAXNLGROUPS 32 /* hardcoded netlink max */
+#define EBT_ULOG_PREFIX_LEN 32
+#define EBT_ULOG_MAX_QLEN 50
+#define EBT_ULOG_WATCHER "ulog"
+
+struct ebt_ulog_info {
+	uint32_t nlgroup;
+	unsigned int cprange;
+	unsigned int qthreshold;
+	char prefix[EBT_ULOG_PREFIX_LEN];
+};
+
+typedef struct ebt_ulog_packet_msg {
+	char indev[IFNAMSIZ];
+	char outdev[IFNAMSIZ];
+	char physindev[IFNAMSIZ];
+	char physoutdev[IFNAMSIZ];
+	char prefix[EBT_ULOG_PREFIX_LEN];
+	struct timeval stamp;
+	unsigned long mark;
+	unsigned int hook;
+	size_t data_len;
+	/* The complete packet, including Ethernet header and perhaps
+	 * the VLAN header is appended */
+	unsigned char data[0] __attribute__ ((aligned (__alignof__(int))));
+} ebt_ulog_packet_msg_t;
+
+#endif /* _EBT_ULOG_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_vlan.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_vlan.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_vlan.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_vlan.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,20 @@
+#ifndef __LINUX_BRIDGE_EBT_VLAN_H
+#define __LINUX_BRIDGE_EBT_VLAN_H
+
+#define EBT_VLAN_ID	0x01
+#define EBT_VLAN_PRIO	0x02
+#define EBT_VLAN_ENCAP	0x04
+#define EBT_VLAN_MASK (EBT_VLAN_ID | EBT_VLAN_PRIO | EBT_VLAN_ENCAP)
+#define EBT_VLAN_MATCH "vlan"
+
+struct ebt_vlan_info {
+	uint16_t id;		/* VLAN ID {1-4095} */
+	uint8_t prio;		/* VLAN User Priority {0-7} */
+	uint16_t encap;		/* VLAN Encapsulated frame code {0-65535} */
+	uint8_t bitmask;		/* Args bitmask bit 1=1 - ID arg,
+				   bit 2=1 User-Priority arg, bit 3=1 encap*/
+	uint8_t invflags;		/* Inverse bitmask  bit 1=1 - inversed ID arg, 
+				   bit 2=1 - inversed Pirority arg */
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge/ebt_802_3.h linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_802_3.h
--- linux-2.4.30.old/include/linux/netfilter_bridge/ebt_802_3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_bridge/ebt_802_3.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,60 @@
+#ifndef __LINUX_BRIDGE_EBT_802_3_H
+#define __LINUX_BRIDGE_EBT_802_3_H
+
+#define EBT_802_3_SAP 0x01
+#define EBT_802_3_TYPE 0x02
+
+#define EBT_802_3_MATCH "802_3"
+
+/*
+ * If frame has DSAP/SSAP value 0xaa you must check the SNAP type
+ * to discover what kind of packet we're carrying. 
+ */
+#define CHECK_TYPE 0xaa
+
+/*
+ * Control field may be one or two bytes.  If the first byte has
+ * the value 0x03 then the entire length is one byte, otherwise it is two.
+ * One byte controls are used in Unnumbered Information frames.
+ * Two byte controls are used in Numbered Information frames.
+ */
+#define IS_UI 0x03
+
+#define EBT_802_3_MASK (EBT_802_3_SAP | EBT_802_3_TYPE | EBT_802_3)
+
+/* ui has one byte ctrl, ni has two */
+struct hdr_ui {
+	uint8_t dsap;
+	uint8_t ssap;
+	uint8_t ctrl;
+	uint8_t orig[3];
+	uint16_t type;
+};
+
+struct hdr_ni {
+	uint8_t dsap;
+	uint8_t ssap;
+	uint16_t ctrl;
+	uint8_t  orig[3];
+	uint16_t type;
+};
+
+struct ebt_802_3_hdr {
+	uint8_t  daddr[6];
+	uint8_t  saddr[6];
+	uint16_t len;
+	union {
+		struct hdr_ui ui;
+		struct hdr_ni ni;
+	} llc;
+};
+
+struct ebt_802_3_info 
+{
+	uint8_t  sap;
+	uint16_t type;
+	uint8_t  bitmask;
+	uint8_t  invflags;
+};
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_bridge.h linux-2.4.30.dev/include/linux/netfilter_bridge.h
--- linux-2.4.30.old/include/linux/netfilter_bridge.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.30.dev/include/linux/netfilter_bridge.h	2008-05-11 02:17:52.000000000 +0200
@@ -6,6 +6,10 @@
 
 #include <linux/config.h>
 #include <linux/netfilter.h>
+#if defined(__KERNEL__) && defined(CONFIG_NETFILTER)
+#include <asm/atomic.h>
+#include <linux/if_ether.h>
+#endif
 
 /* Bridge Hooks */
 /* After promisc drops, checksum checks. */
@@ -18,7 +22,89 @@
 #define NF_BR_LOCAL_OUT		3
 /* Packets about to hit the wire. */
 #define NF_BR_POST_ROUTING	4
-#define NF_BR_NUMHOOKS		5
+/* Not really a hook, but used for the ebtables broute table */
+#define NF_BR_BROUTING		5
+#define NF_BR_NUMHOOKS		6
+
+#ifdef __KERNEL__
+
+#define BRNF_PKT_TYPE			0x01
+#define BRNF_BRIDGED_DNAT		0x02
+#define BRNF_DONT_TAKE_PARENT		0x04
+#define BRNF_BRIDGED			0x08
+#define BRNF_NF_BRIDGE_PREROUTING	0x10
+
+enum nf_br_hook_priorities {
+	NF_BR_PRI_FIRST = INT_MIN,
+	NF_BR_PRI_NAT_DST_BRIDGED = -300,
+	NF_BR_PRI_FILTER_BRIDGED = -200,
+	NF_BR_PRI_BRNF = 0,
+	NF_BR_PRI_NAT_DST_OTHER = 100,
+	NF_BR_PRI_FILTER_OTHER = 200,
+	NF_BR_PRI_NAT_SRC = 300,
+	NF_BR_PRI_LAST = INT_MAX,
+};
+
+#ifdef CONFIG_NETFILTER
+static inline
+struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)
+{
+	struct nf_bridge_info **nf_bridge = &(skb->nf_bridge);
+
+	if ((*nf_bridge = kmalloc(sizeof(**nf_bridge), GFP_ATOMIC)) != NULL) {
+		atomic_set(&(*nf_bridge)->use, 1);
+		(*nf_bridge)->mask = 0;
+		(*nf_bridge)->physindev = (*nf_bridge)->physoutdev = NULL;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+		(*nf_bridge)->netoutdev = NULL;
+#endif
+	}
+
+	return *nf_bridge;
+}
+
+/* Only used in br_forward.c */
+static inline
+void nf_bridge_maybe_copy_header(struct sk_buff *skb)
+{
+	if (skb->nf_bridge) {
+		if (skb->protocol == __constant_htons(ETH_P_8021Q)) {
+			memcpy(skb->data - 18, skb->nf_bridge->data, 18);
+			skb_push(skb, 4);
+		} else
+			memcpy(skb->data - 16, skb->nf_bridge->data, 16);
+	}
+}
+
+static inline
+void nf_bridge_save_header(struct sk_buff *skb)
+{
+        int header_size = 16;
+
+	if (skb->protocol == __constant_htons(ETH_P_8021Q))
+		header_size = 18;
+	memcpy(skb->nf_bridge->data, skb->data - header_size, header_size);
+}
+
+struct bridge_skb_cb {
+	union {
+		__u32 ipv4;
+	} daddr;
+};
+
 
+/* This is called by the IP fragmenting code and it ensures there is
+ * enough room for the encapsulating header (if there is one). */
+static inline
+int nf_bridge_pad(struct sk_buff *skb)
+{
+        if (skb->nf_bridge) {
+                if (skb->protocol == __constant_htons(ETH_P_8021Q))
+                        return 4;
+        }
+        return 0;
+}
+#endif /* CONFIG_NETFILTER */
 
+#endif /* __KERNEL__ */
 #endif
diff -urN linux-2.4.30.old/include/linux/netfilter.h linux-2.4.30.dev/include/linux/netfilter.h
--- linux-2.4.30.old/include/linux/netfilter.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter.h	2008-05-11 02:17:52.000000000 +0200
@@ -17,7 +17,8 @@
 #define NF_STOLEN 2
 #define NF_QUEUE 3
 #define NF_REPEAT 4
-#define NF_MAX_VERDICT NF_REPEAT
+#define NF_STOP 5
+#define NF_MAX_VERDICT NF_STOP
 
 /* Generic cache responses from hook functions.
    <= 0x2000 is used for protocol-flags. */
@@ -118,17 +119,34 @@
 /* This is gross, but inline doesn't cut it for avoiding the function
    call in fast path: gcc doesn't inline (needs value tracking?). --RR */
 #ifdef CONFIG_NETFILTER_DEBUG
-#define NF_HOOK nf_hook_slow
+#define NF_HOOK(pf, hook, skb, indev, outdev, okfn)                           \
+({int __ret;                                                                  \
+if ((__ret=nf_hook_slow(pf, hook, &(skb), indev, outdev, okfn, INT_MIN)) == 1) \
+       __ret = (okfn)(skb);                                                   \
+__ret;})
+#define NF_HOOK_THRESH(pf, hook, skb, indev, outdev, okfn, thresh)            \
+({int __ret;                                                                  \
+if ((__ret=nf_hook_slow(pf, hook, &(skb), indev, outdev, okfn, thresh)) == 1)  \
+       __ret = (okfn)(skb);                                                   \
+__ret;})
 #else
-#define NF_HOOK(pf, hook, skb, indev, outdev, okfn)			\
-(list_empty(&nf_hooks[(pf)][(hook)])					\
- ? (okfn)(skb)								\
- : nf_hook_slow((pf), (hook), (skb), (indev), (outdev), (okfn)))
+#define NF_HOOK(pf, hook, skb, indev, outdev, okfn)                           \
+({int __ret;                                                                  \
+if (list_empty(&nf_hooks[pf][hook]) ||                                        \
+    (__ret=nf_hook_slow(pf, hook, &(skb), indev, outdev, okfn, INT_MIN)) == 1) \
+       __ret = (okfn)(skb);                                                   \
+__ret;})
+#define NF_HOOK_THRESH(pf, hook, skb, indev, outdev, okfn, thresh)            \
+({int __ret;                                                                  \
+if (list_empty(&nf_hooks[pf][hook]) ||                                        \
+    (__ret=nf_hook_slow(pf, hook, &(skb), indev, outdev, okfn, thresh)) == 1)  \
+       __ret = (okfn)(skb);                                                   \
+__ret;})
 #endif
 
-int nf_hook_slow(int pf, unsigned int hook, struct sk_buff *skb,
+int nf_hook_slow(int pf, unsigned int hook, struct sk_buff **pskb,
 		 struct net_device *indev, struct net_device *outdev,
-		 int (*okfn)(struct sk_buff *));
+		 int (*okfn)(struct sk_buff *), int thresh);
 
 /* Call setsockopt() */
 int nf_setsockopt(struct sock *sk, int pf, int optval, char *opt, 
diff -urN linux-2.4.30.old/include/linux/netfilter_helpers.h linux-2.4.30.dev/include/linux/netfilter_helpers.h
--- linux-2.4.30.old/include/linux/netfilter_helpers.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_helpers.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,133 @@
+/*
+ * Helpers for netfiler modules.  This file provides implementations for basic
+ * functions such as strncasecmp(), etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_STRNCASECMP        nf_strncasecmp()
+ *   NF_NEED_STRTOU16           nf_strtou16()
+ *   NF_NEED_STRTOU32           nf_strtou32()
+ */
+#ifndef _NETFILTER_HELPERS_H
+#define _NETFILTER_HELPERS_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/ctype.h>
+#define iseol(c) ( (c) == '\r' || (c) == '\n' )
+
+/*
+ * The standard strncasecmp()
+ */
+#ifdef NF_NEED_STRNCASECMP
+static int
+nf_strncasecmp(const char* s1, const char* s2, u_int32_t len)
+{
+    if (s1 == NULL || s2 == NULL)
+    {
+        if (s1 == NULL && s2 == NULL)
+        {
+            return 0;
+        }
+        return (s1 == NULL) ? -1 : 1;
+    }
+    while (len > 0 && tolower(*s1) == tolower(*s2))
+    {
+        len--;
+        s1++;
+        s2++;
+    }
+    return ( (len == 0) ? 0 : (tolower(*s1) - tolower(*s2)) );
+}
+#endif /* NF_NEED_STRNCASECMP */
+
+/*
+ * Parse a string containing a 16-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU16
+static int
+nf_strtou16(const char* pbuf, u_int16_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (isdigit(pbuf[n]))
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU16 */
+
+/*
+ * Parse a string containing a 32-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU32
+static int
+nf_strtou32(const char* pbuf, u_int32_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (pbuf[n] >= '0' && pbuf[n] <= '9')
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU32 */
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.
+ */
+#ifdef NF_NEED_NEXTLINE
+static int
+nf_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    while (p[off] != '\n')
+    {
+        if (len-off <= 1)
+        {
+            return 0;
+        }
+
+        physlen++;
+        off++;
+    }
+
+    /* if we saw a crlf, physlen needs adjusted */
+    if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+    {
+        physlen--;
+    }
+
+    /* advance past the newline */
+    off++;
+
+    *plineoff = *poff;
+    *plinelen = physlen;
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_HELPERS_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack.h	2008-05-11 02:17:53.000000000 +0200
@@ -50,30 +50,39 @@
 
 #include <linux/netfilter_ipv4/ip_conntrack_tcp.h>
 #include <linux/netfilter_ipv4/ip_conntrack_icmp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_proto_gre.h>
 
 /* per conntrack: protocol private data */
 union ip_conntrack_proto {
 	/* insert conntrack proto private data here */
 	struct ip_ct_tcp tcp;
 	struct ip_ct_icmp icmp;
+	struct ip_ct_gre gre;
 };
 
 union ip_conntrack_expect_proto {
 	/* insert expect proto private data here */
+	struct ip_ct_gre_expect gre;
 };
 
 /* Add protocol helper include file here */
+#include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
 #include <linux/netfilter_ipv4/ip_conntrack_amanda.h>
 
 #include <linux/netfilter_ipv4/ip_conntrack_ftp.h>
 #include <linux/netfilter_ipv4/ip_conntrack_irc.h>
+#include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
+#include <linux/netfilter_ipv4/ip_conntrack_h323.h>
 
 /* per expectation: application helper private data */
 union ip_conntrack_expect_help {
 	/* insert conntrack helper private data (expect) here */
+	struct ip_ct_rtsp_expect exp_rtsp_info;
 	struct ip_ct_amanda_expect exp_amanda_info;
 	struct ip_ct_ftp_expect exp_ftp_info;
 	struct ip_ct_irc_expect exp_irc_info;
+	struct ip_ct_pptp_expect exp_pptp_info;
+	struct ip_ct_h225_expect exp_h225_info;
 
 #ifdef CONFIG_IP_NF_NAT_NEEDED
 	union {
@@ -85,16 +94,21 @@
 /* per conntrack: application helper private data */
 union ip_conntrack_help {
 	/* insert conntrack helper private data (master) here */
+	struct ip_ct_rtsp_master ct_rtsp_info;
 	struct ip_ct_ftp_master ct_ftp_info;
 	struct ip_ct_irc_master ct_irc_info;
+	struct ip_ct_pptp_master ct_pptp_info;
+	struct ip_ct_h225_master ct_h225_info;
 };
 
 #ifdef CONFIG_IP_NF_NAT_NEEDED
 #include <linux/netfilter_ipv4/ip_nat.h>
+#include <linux/netfilter_ipv4/ip_nat_pptp.h>
 
 /* per conntrack: nat application helper private data */
 union ip_conntrack_nat_help {
 	/* insert nat helper private data here */
+	struct ip_nat_pptp nat_pptp_info;
 };
 #endif
 
@@ -191,7 +205,11 @@
 	struct nf_ct_info infos[IP_CT_NUMBER];
 
 	/* Storage reserved for other modules: */
-
+	/* devik: store num of bytes transfered; counter uses saturated incr. */
+	#if defined(CONFIG_IP_NF_MATCH_CONNBYTES) || defined(CONFIG_IP_NF_MATCH_CONNBYTES_MODULE)
+	unsigned long bytes;
+	#endif
+	
 	union ip_conntrack_proto proto;
 
 	union ip_conntrack_help help;
@@ -207,6 +225,20 @@
 	} nat;
 #endif /* CONFIG_IP_NF_NAT_NEEDED */
 
+#if defined(CONFIG_IP_NF_MATCH_LAYER7) || defined(CONFIG_IP_NF_MATCH_LAYER7_MODULE)
+	struct {
+		unsigned int numpackets; /* surely this is kept track of somewhere else, right? I can't find it... */
+		char * app_proto; /* "http", "ftp", etc.  NULL if unclassifed */
+		
+		/* the application layer data so far.  NULL if ->numpackets > numpackets */
+		char * app_data; 
+
+		unsigned int app_data_len;
+	} layer7;
+#endif
+#if defined(CONFIG_IP_NF_CONNTRACK_MARK)
+	unsigned long mark;
+#endif
 };
 
 /* get master conntrack via master expectation */
@@ -229,7 +261,7 @@
 ip_conntrack_get(struct sk_buff *skb, enum ip_conntrack_info *ctinfo);
 
 /* decrement reference count on a conntrack */
-extern inline void ip_conntrack_put(struct ip_conntrack *ct);
+extern void ip_conntrack_put(struct ip_conntrack *ct);
 
 /* find unconfirmed expectation based on tuple */
 struct ip_conntrack_expect *
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_h323.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_h323.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_h323.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_h323.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,30 @@
+#ifndef _IP_CONNTRACK_H323_H
+#define _IP_CONNTRACK_H323_H
+/* H.323 connection tracking. */
+
+#ifdef __KERNEL__
+/* Protects H.323 related data */
+DECLARE_LOCK_EXTERN(ip_h323_lock);
+#endif
+
+/* Default H.225 port */
+#define H225_PORT	1720
+
+/* This structure is per expected connection */
+struct ip_ct_h225_expect {
+	u_int16_t port;			/* Port of the H.225 helper/RTCP/RTP channel */
+	enum ip_conntrack_dir dir;	/* Direction of the original connection */
+	unsigned int offset;		/* offset of the address in the payload */
+};
+
+/* This structure exists only once per master */
+struct ip_ct_h225_master {
+	int is_h225;				/* H.225 or H.245 connection */
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+	enum ip_conntrack_dir dir;		/* Direction of the original connection */
+	u_int32_t seq[IP_CT_DIR_MAX];		/* Exceptional packet mangling for signal addressess... */
+	unsigned int offset[IP_CT_DIR_MAX];	/* ...and the offset of the addresses in the payload */
+#endif
+};
+
+#endif /* _IP_CONNTRACK_H323_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_pptp.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_pptp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_pptp.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,313 @@
+/* PPTP constants and structs */
+#ifndef _CONNTRACK_PPTP_H
+#define _CONNTRACK_PPTP_H
+
+/* state of the control session */
+enum pptp_ctrlsess_state {
+	PPTP_SESSION_NONE,			/* no session present */
+	PPTP_SESSION_ERROR,			/* some session error */
+	PPTP_SESSION_STOPREQ,			/* stop_sess request seen */
+	PPTP_SESSION_REQUESTED,			/* start_sess request seen */
+	PPTP_SESSION_CONFIRMED,			/* session established */
+};
+
+/* state of the call inside the control session */
+enum pptp_ctrlcall_state {
+	PPTP_CALL_NONE,
+	PPTP_CALL_ERROR,
+	PPTP_CALL_OUT_REQ,
+	PPTP_CALL_OUT_CONF,
+	PPTP_CALL_IN_REQ,
+	PPTP_CALL_IN_REP,
+	PPTP_CALL_IN_CONF,
+	PPTP_CALL_CLEAR_REQ,
+};
+
+
+/* conntrack private data */
+struct ip_ct_pptp_master {
+	enum pptp_ctrlsess_state sstate;	/* session state */
+
+	/* everything below is going to be per-expectation in newnat,
+	 * since there could be more than one call within one session */
+	enum pptp_ctrlcall_state cstate;	/* call state */
+	u_int16_t pac_call_id;			/* call id of PAC, host byte order */
+	u_int16_t pns_call_id;			/* call id of PNS, host byte order */
+};
+
+/* conntrack_expect private member */
+struct ip_ct_pptp_expect {
+	enum pptp_ctrlcall_state cstate; 	/* call state */
+	u_int16_t pac_call_id;			/* call id of PAC */
+	u_int16_t pns_call_id;			/* call id of PNS */
+};
+
+
+#ifdef __KERNEL__
+
+#include <linux/netfilter_ipv4/lockhelp.h>
+DECLARE_LOCK_EXTERN(ip_pptp_lock);
+
+#define IP_CONNTR_PPTP		PPTP_CONTROL_PORT
+
+union pptp_ctrl_union {
+                void				*rawreq;
+		struct PptpStartSessionRequest	*sreq;
+		struct PptpStartSessionReply	*srep;
+		struct PptpStopSessionRequest	*streq;
+		struct PptpStopSessionReply	*strep;
+                struct PptpOutCallRequest       *ocreq;
+                struct PptpOutCallReply         *ocack;
+                struct PptpInCallRequest        *icreq;
+                struct PptpInCallReply          *icack;
+                struct PptpInCallConnected      *iccon;
+		struct PptpClearCallRequest	*clrreq;
+                struct PptpCallDisconnectNotify *disc;
+                struct PptpWanErrorNotify       *wanerr;
+                struct PptpSetLinkInfo          *setlink;
+};
+
+
+
+#define PPTP_CONTROL_PORT	1723
+
+#define PPTP_PACKET_CONTROL	1
+#define PPTP_PACKET_MGMT	2
+
+#define PPTP_MAGIC_COOKIE	0x1a2b3c4d
+
+struct pptp_pkt_hdr {
+	__u16	packetLength;
+	__u16	packetType;
+	__u32	magicCookie;
+};
+
+/* PptpControlMessageType values */
+#define PPTP_START_SESSION_REQUEST	1
+#define PPTP_START_SESSION_REPLY	2
+#define PPTP_STOP_SESSION_REQUEST	3
+#define PPTP_STOP_SESSION_REPLY		4
+#define PPTP_ECHO_REQUEST		5
+#define PPTP_ECHO_REPLY			6
+#define PPTP_OUT_CALL_REQUEST		7
+#define PPTP_OUT_CALL_REPLY		8
+#define PPTP_IN_CALL_REQUEST		9
+#define PPTP_IN_CALL_REPLY		10
+#define PPTP_IN_CALL_CONNECT		11
+#define PPTP_CALL_CLEAR_REQUEST		12
+#define PPTP_CALL_DISCONNECT_NOTIFY	13
+#define PPTP_WAN_ERROR_NOTIFY		14
+#define PPTP_SET_LINK_INFO		15
+
+#define PPTP_MSG_MAX			15
+
+/* PptpGeneralError values */
+#define PPTP_ERROR_CODE_NONE		0
+#define PPTP_NOT_CONNECTED		1
+#define PPTP_BAD_FORMAT			2
+#define PPTP_BAD_VALUE			3
+#define PPTP_NO_RESOURCE		4
+#define PPTP_BAD_CALLID			5
+#define PPTP_REMOVE_DEVICE_ERROR	6
+
+struct PptpControlHeader {
+	__u16	messageType;
+	__u16	reserved;
+};
+
+/* FramingCapability Bitmap Values */
+#define PPTP_FRAME_CAP_ASYNC		0x1
+#define PPTP_FRAME_CAP_SYNC		0x2
+
+/* BearerCapability Bitmap Values */
+#define PPTP_BEARER_CAP_ANALOG		0x1
+#define PPTP_BEARER_CAP_DIGITAL		0x2
+
+struct PptpStartSessionRequest {
+	__u16	protocolVersion;
+	__u8	reserved1;
+	__u8	reserved2;
+	__u32	framingCapability;
+	__u32	bearerCapability;
+	__u16	maxChannels;
+	__u16	firmwareRevision;
+	__u8	hostName[64];
+	__u8	vendorString[64];
+};
+
+/* PptpStartSessionResultCode Values */
+#define PPTP_START_OK			1
+#define PPTP_START_GENERAL_ERROR	2
+#define PPTP_START_ALREADY_CONNECTED	3
+#define PPTP_START_NOT_AUTHORIZED	4
+#define PPTP_START_UNKNOWN_PROTOCOL	5
+
+struct PptpStartSessionReply {
+	__u16	protocolVersion;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u32	framingCapability;
+	__u32	bearerCapability;
+	__u16	maxChannels;
+	__u16	firmwareRevision;
+	__u8	hostName[64];
+	__u8	vendorString[64];
+};
+
+/* PptpStopReasons */
+#define PPTP_STOP_NONE			1
+#define PPTP_STOP_PROTOCOL		2
+#define PPTP_STOP_LOCAL_SHUTDOWN	3
+
+struct PptpStopSessionRequest {
+	__u8	reason;
+};
+
+/* PptpStopSessionResultCode */
+#define PPTP_STOP_OK			1
+#define PPTP_STOP_GENERAL_ERROR		2
+
+struct PptpStopSessionReply {
+	__u8	resultCode;
+	__u8	generalErrorCode;
+};
+
+struct PptpEchoRequest {
+	__u32 identNumber;
+};
+
+/* PptpEchoReplyResultCode */
+#define PPTP_ECHO_OK			1
+#define PPTP_ECHO_GENERAL_ERROR		2
+
+struct PptpEchoReply {
+	__u32	identNumber;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	reserved;
+};
+
+/* PptpFramingType */
+#define PPTP_ASYNC_FRAMING		1
+#define PPTP_SYNC_FRAMING		2
+#define PPTP_DONT_CARE_FRAMING		3
+
+/* PptpCallBearerType */
+#define PPTP_ANALOG_TYPE		1
+#define PPTP_DIGITAL_TYPE		2
+#define PPTP_DONT_CARE_BEARER_TYPE	3
+
+struct PptpOutCallRequest {
+	__u16	callID;
+	__u16	callSerialNumber;
+	__u32	minBPS;
+	__u32	maxBPS;
+	__u32	bearerType;
+	__u32	framingType;
+	__u16	packetWindow;
+	__u16	packetProcDelay;
+	__u16	reserved1;
+	__u16	phoneNumberLength;
+	__u16	reserved2;
+	__u8	phoneNumber[64];
+	__u8	subAddress[64];
+};
+
+/* PptpCallResultCode */
+#define PPTP_OUTCALL_CONNECT		1
+#define PPTP_OUTCALL_GENERAL_ERROR	2
+#define PPTP_OUTCALL_NO_CARRIER		3
+#define PPTP_OUTCALL_BUSY		4
+#define PPTP_OUTCALL_NO_DIAL_TONE	5
+#define PPTP_OUTCALL_TIMEOUT		6
+#define PPTP_OUTCALL_DONT_ACCEPT	7
+
+struct PptpOutCallReply {
+	__u16	callID;
+	__u16	peersCallID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	causeCode;
+	__u32	connectSpeed;
+	__u16	packetWindow;
+	__u16	packetProcDelay;
+	__u32	physChannelID;
+};
+
+struct PptpInCallRequest {
+	__u16	callID;
+	__u16	callSerialNumber;
+	__u32	callBearerType;
+	__u32	physChannelID;
+	__u16	dialedNumberLength;
+	__u16	dialingNumberLength;
+	__u8	dialedNumber[64];
+	__u8	dialingNumber[64];
+	__u8	subAddress[64];
+};
+
+/* PptpInCallResultCode */
+#define PPTP_INCALL_ACCEPT		1
+#define PPTP_INCALL_GENERAL_ERROR	2
+#define PPTP_INCALL_DONT_ACCEPT		3
+
+struct PptpInCallReply {
+	__u16	callID;
+	__u16	peersCallID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	packetWindow;
+	__u16	packetProcDelay;
+	__u16	reserved;
+};
+
+struct PptpInCallConnected {
+	__u16	peersCallID;
+	__u16	reserved;
+	__u32	connectSpeed;
+	__u16	packetWindow;
+	__u16	packetProcDelay;
+	__u32	callFramingType;
+};
+
+struct PptpClearCallRequest {
+	__u16	callID;
+	__u16	reserved;
+};
+
+struct PptpCallDisconnectNotify {
+	__u16	callID;
+	__u8	resultCode;
+	__u8	generalErrorCode;
+	__u16	causeCode;
+	__u16	reserved;
+	__u8	callStatistics[128];
+};
+
+struct PptpWanErrorNotify {
+	__u16	peersCallID;
+	__u16	reserved;
+	__u32	crcErrors;
+	__u32	framingErrors;
+	__u32	hardwareOverRuns;
+	__u32	bufferOverRuns;
+	__u32	timeoutErrors;
+	__u32	alignmentErrors;
+};
+
+struct PptpSetLinkInfo {
+	__u16	peersCallID;
+	__u16	reserved;
+	__u32	sendAccm;
+	__u32	recvAccm;
+};
+
+
+struct pptp_priv_data {
+	__u16	call_id;
+	__u16	mcall_id;
+	__u16	pcall_id;
+};
+
+#endif /* __KERNEL__ */
+#endif /* _CONNTRACK_PPTP_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_proto_gre.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,123 @@
+#ifndef _CONNTRACK_PROTO_GRE_H
+#define _CONNTRACK_PROTO_GRE_H
+#include <asm/byteorder.h>
+
+/* GRE PROTOCOL HEADER */
+
+/* GRE Version field */
+#define GRE_VERSION_1701	0x0
+#define GRE_VERSION_PPTP	0x1
+
+/* GRE Protocol field */
+#define GRE_PROTOCOL_PPTP	0x880B
+
+/* GRE Flags */
+#define GRE_FLAG_C		0x80
+#define GRE_FLAG_R		0x40
+#define GRE_FLAG_K		0x20
+#define GRE_FLAG_S		0x10
+#define GRE_FLAG_A		0x80
+
+#define GRE_IS_C(f)	((f)&GRE_FLAG_C)
+#define GRE_IS_R(f)	((f)&GRE_FLAG_R)
+#define GRE_IS_K(f)	((f)&GRE_FLAG_K)
+#define GRE_IS_S(f)	((f)&GRE_FLAG_S)
+#define GRE_IS_A(f)	((f)&GRE_FLAG_A)
+
+/* GRE is a mess: Four different standards */
+struct gre_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u16	rec:3,
+		srr:1,
+		seq:1,
+		key:1,
+		routing:1,
+		csum:1,
+		version:3,
+		reserved:4,
+		ack:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u16	csum:1,
+		routing:1,
+		key:1,
+		seq:1,
+		srr:1,
+		rec:3,
+		ack:1,
+		reserved:4,
+		version:3;
+#else
+#error "Adjust your <asm/byteorder.h> defines"
+#endif
+	__u16	protocol;
+};
+
+/* modified GRE header for PPTP */
+struct gre_hdr_pptp {
+	__u8  flags;		/* bitfield */
+	__u8  version;		/* should be GRE_VERSION_PPTP */
+	__u16 protocol;		/* should be GRE_PROTOCOL_PPTP */
+	__u16 payload_len;	/* size of ppp payload, not inc. gre header */
+	__u16 call_id;		/* peer's call_id for this session */
+	__u32 seq;		/* sequence number.  Present if S==1 */
+	__u32 ack;		/* seq number of highest packet recieved by */
+				/*  sender in this session */
+};
+
+
+/* this is part of ip_conntrack */
+struct ip_ct_gre {
+	unsigned int stream_timeout;
+	unsigned int timeout;
+};
+
+/* this is part of ip_conntrack_expect */
+struct ip_ct_gre_expect {
+	struct ip_ct_gre_keymap *keymap_orig, *keymap_reply;
+};
+
+#ifdef __KERNEL__
+struct ip_conntrack_expect;
+
+/* structure for original <-> reply keymap */
+struct ip_ct_gre_keymap {
+	struct list_head list;
+
+	struct ip_conntrack_tuple tuple;
+};
+
+
+/* add new tuple->key_reply pair to keymap */
+int ip_ct_gre_keymap_add(struct ip_conntrack_expect *exp,
+			 struct ip_conntrack_tuple *t,
+			 int reply);
+
+/* change an existing keymap entry */
+void ip_ct_gre_keymap_change(struct ip_ct_gre_keymap *km,
+			     struct ip_conntrack_tuple *t);
+
+/* delete keymap entries */
+void ip_ct_gre_keymap_destroy(struct ip_conntrack_expect *exp);
+
+
+/* get pointer to gre key, if present */
+static inline u_int32_t *gre_key(struct gre_hdr *greh)
+{
+	if (!greh->key)
+		return NULL;
+	if (greh->csum || greh->routing)
+		return (u_int32_t *) (greh+sizeof(*greh)+4);
+	return (u_int32_t *) (greh+sizeof(*greh));
+}
+
+/* get pointer ot gre csum, if present */
+static inline u_int16_t *gre_csum(struct gre_hdr *greh)
+{
+	if (!greh->csum)
+		return NULL;
+	return (u_int16_t *) (greh+sizeof(*greh));
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _CONNTRACK_PROTO_GRE_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * RTSP extension for IP connection tracking.
+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
+ * based on ip_conntrack_irc.h
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+#ifndef _IP_CONNTRACK_RTSP_H
+#define _IP_CONNTRACK_RTSP_H
+
+/* #define IP_NF_RTSP_DEBUG */
+#define IP_NF_RTSP_VERSION "0.01"
+
+/* port block types */
+typedef enum {
+    pb_single,  /* client_port=x */
+    pb_range,   /* client_port=x-y */
+    pb_discon   /* client_port=x/y (rtspbis) */
+} portblock_t;
+
+/* We record seq number and length of rtsp headers here, all in host order. */
+
+/*
+ * This structure is per expected connection.  It is a member of struct
+ * ip_conntrack_expect.  The TCP SEQ for the conntrack expect is stored
+ * there and we are expected to only store the length of the data which
+ * needs replaced.  If a packet contains multiple RTSP messages, we create
+ * one expected connection per message.
+ *
+ * We use these variables to mark the entire header block.  This may seem
+ * like overkill, but the nature of RTSP requires it.  A header may appear
+ * multiple times in a message.  We must treat two Transport headers the
+ * same as one Transport header with two entries.
+ */
+struct ip_ct_rtsp_expect
+{
+    u_int32_t   len;        /* length of header block */
+    portblock_t pbtype;     /* Type of port block that was requested */
+    u_int16_t   loport;     /* Port that was requested, low or first */
+    u_int16_t   hiport;     /* Port that was requested, high or second */
+#if 0
+    uint        method;     /* RTSP method */
+    uint        cseq;       /* CSeq from request */
+#endif
+};
+
+/* This structure exists only once per master */
+struct ip_ct_rtsp_master
+{
+    /* Empty (?) */
+};
+
+
+#ifdef __KERNEL__
+
+#include <linux/netfilter_ipv4/lockhelp.h>
+
+#define RTSP_PORT   554
+
+/* Protects rtsp part of conntracks */
+DECLARE_LOCK_EXTERN(ip_rtsp_lock);
+
+#endif /* __KERNEL__ */
+
+#endif /* _IP_CONNTRACK_RTSP_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_tuple.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	2008-05-11 02:17:51.000000000 +0200
@@ -14,7 +14,7 @@
 union ip_conntrack_manip_proto
 {
 	/* Add other protocols here. */
-	u_int16_t all;
+	u_int32_t all;
 
 	struct {
 		u_int16_t port;
@@ -25,6 +25,9 @@
 	struct {
 		u_int16_t id;
 	} icmp;
+	struct {
+		u_int32_t key;
+	} gre;
 };
 
 /* The manipulable part of the tuple. */
@@ -44,7 +47,7 @@
 		u_int32_t ip;
 		union {
 			/* Add other protocols here. */
-			u_int16_t all;
+			u_int32_t all;
 
 			struct {
 				u_int16_t port;
@@ -55,6 +58,9 @@
 			struct {
 				u_int8_t type, code;
 			} icmp;
+			struct {
+				u_int32_t key;
+			} gre;
 		} u;
 
 		/* The protocol. */
@@ -80,10 +86,16 @@
 #ifdef __KERNEL__
 
 #define DUMP_TUPLE(tp)						\
-DEBUGP("tuple %p: %u %u.%u.%u.%u:%hu -> %u.%u.%u.%u:%hu\n",	\
+DEBUGP("tuple %p: %u %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n",	\
        (tp), (tp)->dst.protonum,				\
-       NIPQUAD((tp)->src.ip), ntohs((tp)->src.u.all),		\
-       NIPQUAD((tp)->dst.ip), ntohs((tp)->dst.u.all))
+       NIPQUAD((tp)->src.ip), ntohl((tp)->src.u.all),		\
+       NIPQUAD((tp)->dst.ip), ntohl((tp)->dst.u.all))
+
+#define DUMP_TUPLE_RAW(x) 						\
+	DEBUGP("tuple %p: %u %u.%u.%u.%u:0x%08x -> %u.%u.%u.%u:0x%08x\n",\
+	(x), (x)->dst.protonum,						\
+	NIPQUAD((x)->src.ip), ntohl((x)->src.u.all), 			\
+	NIPQUAD((x)->dst.ip), ntohl((x)->dst.u.all))
 
 #define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)
 
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_nat_pptp.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_nat_pptp.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_nat_pptp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_nat_pptp.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,11 @@
+/* PPTP constants and structs */
+#ifndef _NAT_PPTP_H
+#define _NAT_PPTP_H
+
+/* conntrack private data */
+struct ip_nat_pptp {
+	u_int16_t pns_call_id;		/* NAT'ed PNS call id */
+	u_int16_t pac_call_id;		/* NAT'ed PAC call id */
+};
+
+#endif /* _NAT_PPTP_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_nat_rule.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_nat_rule.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_nat_rule.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_nat_rule.h	2008-05-11 02:17:53.000000000 +0200
@@ -19,5 +19,10 @@
 alloc_null_binding(struct ip_conntrack *conntrack,
 		   struct ip_nat_info *info,
 		   unsigned int hooknum);
+
+extern unsigned int
+alloc_null_binding_confirmed(struct ip_conntrack *conntrack,
+			     struct ip_nat_info *info,
+			     unsigned int hooknum);
 #endif
 #endif /* _IP_NAT_RULE_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ip_tables.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ip_tables.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ip_tables.h	2008-05-11 02:17:53.000000000 +0200
@@ -159,7 +159,7 @@
 #define IPT_CONTINUE 0xFFFFFFFF
 
 /* For standard target */
-#define IPT_RETURN (-NF_MAX_VERDICT - 1)
+#define IPT_RETURN (-NF_REPEAT - 1)
 
 /* TCP matching stuff */
 struct ipt_tcp
@@ -283,8 +283,6 @@
 	struct ipt_entry entrytable[0];
 };
 
-extern struct semaphore ipt_mutex;
-
 /* Standard return verdict, or do jump. */
 #define IPT_STANDARD_TARGET ""
 /* Error verdict. */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_CLASSIFY.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_CLASSIFY.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_CLASSIFY.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_CLASSIFY.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _IPT_CLASSIFY_H
+#define _IPT_CLASSIFY_H
+
+struct ipt_classify_target_info {
+	u_int32_t priority;
+};
+
+#endif /*_IPT_CLASSIFY_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_connbytes.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_connbytes.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_connbytes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_connbytes.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,27 @@
+#ifndef _IPT_CONNBYTES_H
+#define _IPT_CONNBYTES_H
+
+enum ipt_connbytes_what {
+	IPT_CONNBYTES_WHAT_PKTS,
+	IPT_CONNBYTES_WHAT_BYTES,
+	IPT_CONNBYTES_WHAT_AVGPKT,
+};
+
+enum ipt_connbytes_direction {
+	IPT_CONNBYTES_DIR_ORIGINAL,
+	IPT_CONNBYTES_DIR_REPLY,
+	IPT_CONNBYTES_DIR_BOTH,
+};
+
+struct ipt_connbytes_info
+{
+	/* if from<=to then it matches the range; if from>to then
+		inverse range is matched */
+	struct {
+		u_int64_t from; /* count to be matched */
+		u_int64_t to;   /* count to be matched */
+	} count;
+	u_int8_t what;		/* ipt_connbytes_what */
+	u_int8_t direction;     /* ipt_connbytes_direction */
+};
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_CONNMARK.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_CONNMARK.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_CONNMARK.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_CONNMARK.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef _IPT_CONNMARK_H_target
+#define _IPT_CONNMARK_H_target
+
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+enum {
+	IPT_CONNMARK_SET = 0,
+	IPT_CONNMARK_SAVE,
+	IPT_CONNMARK_RESTORE
+};
+
+struct ipt_connmark_target_info {
+	unsigned long mark;
+	unsigned long mask;
+	u_int8_t mode;
+};
+
+#endif /*_IPT_CONNMARK_H_target*/
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_connmark.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_connmark.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_connmark.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_connmark.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef _IPT_CONNMARK_H
+#define _IPT_CONNMARK_H
+
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+struct ipt_connmark_info {
+	unsigned long mark, mask;
+	u_int8_t invert;
+};
+
+#endif /*_IPT_CONNMARK_H*/
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_IMQ.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_IMQ.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_IMQ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_IMQ.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _IPT_IMQ_H
+#define _IPT_IMQ_H
+
+struct ipt_imq_info {
+	unsigned int todev;	/* target imq device */
+};
+
+#endif /* _IPT_IMQ_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_ipp2p.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_ipp2p.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_ipp2p.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_ipp2p.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,31 @@
+#ifndef __IPT_IPP2P_H
+#define __IPT_IPP2P_H
+#define IPP2P_VERSION "0.8.1_rc1"
+
+struct ipt_p2p_info {
+    int cmd;
+    int debug;
+};
+
+#endif //__IPT_IPP2P_H
+
+#define SHORT_HAND_IPP2P	1 /* --ipp2p switch*/
+//#define SHORT_HAND_DATA		4 /* --ipp2p-data switch*/
+#define SHORT_HAND_NONE		5 /* no short hand*/
+
+#define IPP2P_EDK		(1 << 1)
+#define IPP2P_DATA_KAZAA	(1 << 2)
+#define IPP2P_DATA_EDK		(1 << 3)
+#define IPP2P_DATA_DC		(1 << 4)
+#define IPP2P_DC		(1 << 5)
+#define IPP2P_DATA_GNU		(1 << 6)
+#define IPP2P_GNU		(1 << 7)
+#define IPP2P_KAZAA		(1 << 8)
+#define IPP2P_BIT		(1 << 9)
+#define IPP2P_APPLE		(1 << 10)
+#define IPP2P_SOUL		(1 << 11)
+#define IPP2P_WINMX		(1 << 12)
+#define IPP2P_ARES		(1 << 13)
+#define IPP2P_MUTE		(1 << 14)
+#define IPP2P_WASTE		(1 << 15)
+#define IPP2P_XDCC		(1 << 16)
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_layer7.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_layer7.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_layer7.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_layer7.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,27 @@
+/* 
+  By Matthew Strait <quadong@users.sf.net>, Dec 2003.
+  http://l7-filter.sf.net
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version
+  2 of the License, or (at your option) any later version.
+  http://www.gnu.org/licenses/gpl.txt
+*/
+
+#ifndef _IPT_LAYER7_H
+#define _IPT_LAYER7_H
+
+#define MAX_PATTERN_LEN 8192
+#define MAX_PROTOCOL_LEN 256
+
+typedef char *(*proc_ipt_search) (char *, char, char *);
+
+struct ipt_layer7_info {
+    char protocol[MAX_PROTOCOL_LEN];
+    char invert:1;
+    char pattern[MAX_PATTERN_LEN];
+	char pkt;
+};
+
+#endif /* _IPT_LAYER7_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_multiport.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_multiport.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_multiport.h	2000-12-11 22:31:30.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_multiport.h	2008-05-11 02:17:52.000000000 +0200
@@ -11,11 +11,12 @@
 
 #define IPT_MULTI_PORTS	15
 
-/* Must fit inside union ipt_matchinfo: 16 bytes */
-struct ipt_multiport
+struct ipt_multiport_v1
 {
 	u_int8_t flags;				/* Type of comparison */
 	u_int8_t count;				/* Number of ports */
 	u_int16_t ports[IPT_MULTI_PORTS];	/* Ports */
+	u_int8_t pflags[IPT_MULTI_PORTS];	/* Port flags */
+	u_int8_t invert;			/* Invert flag */
 };
 #endif /*_IPT_MULTIPORT_H*/
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_physdev.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_physdev.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_physdev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_physdev.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef _IPT_PHYSDEV_H
+#define _IPT_PHYSDEV_H
+
+#ifdef __KERNEL__
+#include <linux/if.h>
+#endif
+
+#define IPT_PHYSDEV_OP_IN		0x01
+#define IPT_PHYSDEV_OP_OUT		0x02
+#define IPT_PHYSDEV_OP_BRIDGED		0x04
+#define IPT_PHYSDEV_OP_ISIN		0x08
+#define IPT_PHYSDEV_OP_ISOUT		0x10
+#define IPT_PHYSDEV_OP_MASK		(0x20 - 1)
+
+struct ipt_physdev_info {
+	char physindev[IFNAMSIZ];
+	char in_mask[IFNAMSIZ];
+	char physoutdev[IFNAMSIZ];
+	char out_mask[IFNAMSIZ];
+	u_int8_t invert;
+	u_int8_t bitmask;
+};
+
+#endif /*_IPT_PHYSDEV_H*/
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_string.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_string.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_string.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_string.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef _IPT_STRING_H
+#define _IPT_STRING_H
+
+#define IPT_STRING_MAX_PATTERN_SIZE 128
+#define IPT_STRING_MAX_ALGO_NAME_SIZE 16
+
+struct ipt_string_info
+{
+	u_int16_t from_offset;
+	u_int16_t to_offset;
+	char	  algo[IPT_STRING_MAX_ALGO_NAME_SIZE];
+	char 	  pattern[IPT_STRING_MAX_PATTERN_SIZE];
+	u_int8_t  patlen;
+	u_int8_t  invert;
+	struct ts_config __attribute__((aligned(8))) *config;
+};
+
+#endif /*_IPT_STRING_H*/
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_TTL.h linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_TTL.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4/ipt_TTL.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4/ipt_TTL.h	2008-05-11 02:17:51.000000000 +0200
@@ -0,0 +1,21 @@
+/* TTL modification module for IP tables
+ * (C) 2000 by Harald Welte <laforge@gnumonks.org> */
+
+#ifndef _IPT_TTL_H
+#define _IPT_TTL_H
+
+enum {
+	IPT_TTL_SET = 0,
+	IPT_TTL_INC,
+	IPT_TTL_DEC
+};
+
+#define IPT_TTL_MAXMODE	IPT_TTL_DEC
+
+struct ipt_TTL_info {
+	u_int8_t	mode;
+	u_int8_t	ttl;
+};
+
+
+#endif
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv4.h linux-2.4.30.dev/include/linux/netfilter_ipv4.h
--- linux-2.4.30.old/include/linux/netfilter_ipv4.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv4.h	2008-05-11 02:17:52.000000000 +0200
@@ -52,8 +52,10 @@
 enum nf_ip_hook_priorities {
 	NF_IP_PRI_FIRST = INT_MIN,
 	NF_IP_PRI_CONNTRACK = -200,
+	NF_IP_PRI_BRIDGE_SABOTAGE_FORWARD = -175,
 	NF_IP_PRI_MANGLE = -150,
 	NF_IP_PRI_NAT_DST = -100,
+	NF_IP_PRI_BRIDGE_SABOTAGE_LOCAL_OUT = -50,
 	NF_IP_PRI_FILTER = 0,
 	NF_IP_PRI_NAT_SRC = 100,
 	NF_IP_PRI_LAST = INT_MAX,
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv6/ip6_tables.h linux-2.4.30.dev/include/linux/netfilter_ipv6/ip6_tables.h
--- linux-2.4.30.old/include/linux/netfilter_ipv6/ip6_tables.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/netfilter_ipv6/ip6_tables.h	2008-05-11 02:17:52.000000000 +0200
@@ -165,7 +165,7 @@
 #define IP6T_CONTINUE 0xFFFFFFFF
 
 /* For standard target */
-#define IP6T_RETURN (-NF_MAX_VERDICT - 1)
+#define IP6T_RETURN (-NF_REPEAT - 1)
 
 /* TCP matching stuff */
 struct ip6t_tcp
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv6/ip6t_IMQ.h linux-2.4.30.dev/include/linux/netfilter_ipv6/ip6t_IMQ.h
--- linux-2.4.30.old/include/linux/netfilter_ipv6/ip6t_IMQ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv6/ip6t_IMQ.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _IP6T_IMQ_H
+#define _IP6T_IMQ_H
+
+struct ip6t_imq_info {
+	unsigned int todev;	/* target imq device */
+};
+
+#endif /* _IP6T_IMQ_H */
diff -urN linux-2.4.30.old/include/linux/netfilter_ipv6.h linux-2.4.30.dev/include/linux/netfilter_ipv6.h
--- linux-2.4.30.old/include/linux/netfilter_ipv6.h	2001-01-02 01:17:54.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_ipv6.h	2008-05-11 02:17:52.000000000 +0200
@@ -57,8 +57,10 @@
 enum nf_ip6_hook_priorities {
 	NF_IP6_PRI_FIRST = INT_MIN,
 	NF_IP6_PRI_CONNTRACK = -200,
+	NF_IP6_PRI_BRIDGE_SABOTAGE_FORWARD = -175,
 	NF_IP6_PRI_MANGLE = -150,
 	NF_IP6_PRI_NAT_DST = -100,
+	NF_IP6_PRI_BRIDGE_SABOTAGE_LOCAL_OUT = -50,
 	NF_IP6_PRI_FILTER = 0,
 	NF_IP6_PRI_NAT_SRC = 100,
 	NF_IP6_PRI_LAST = INT_MAX,
diff -urN linux-2.4.30.old/include/linux/netfilter_mime.h linux-2.4.30.dev/include/linux/netfilter_mime.h
--- linux-2.4.30.old/include/linux/netfilter_mime.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/netfilter_mime.h	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,90 @@
+/*
+ * MIME functions for netfilter modules.  This file provides implementations
+ * for basic MIME parsing.  MIME headers are used in many protocols, such as
+ * HTTP, RTSP, SIP, etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_MIME_NEXTLINE      nf_mime_nextline()
+ */
+#ifndef _NETFILTER_MIME_H
+#define _NETFILTER_MIME_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.  If the current line is empty, *plinelen will be set to zero.  If
+ * not, it will be set to the actual line length (including CRLF).
+ *
+ * 'line' in this context means logical line (includes LWS continuations).
+ * Returns 1 on success, 0 on failure.
+ */
+#ifdef NF_NEED_MIME_NEXTLINE
+static int
+nf_mime_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+    int     is_first_line = 1;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    do
+    {
+        while (p[off] != '\n')
+        {
+            if (len-off <= 1)
+            {
+                return 0;
+            }
+
+            physlen++;
+            off++;
+        }
+
+        /* if we saw a crlf, physlen needs adjusted */
+        if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+        {
+            physlen--;
+        }
+
+        /* advance past the newline */
+        off++;
+
+        /* check for an empty line */
+        if (physlen == 0)
+        {
+            break;
+        }
+
+        /* check for colon on the first physical line */
+        if (is_first_line)
+        {
+            is_first_line = 0;
+            if (memchr(p+(*poff), ':', physlen) == NULL)
+            {
+                return 0;
+            }
+        }
+    }
+    while (p[off] == ' ' || p[off] == '\t');
+
+    *plineoff = *poff;
+    *plinelen = (physlen == 0) ? 0 : (off - *poff);
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_MIME_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_MIME_H */
diff -urN linux-2.4.30.old/include/linux/nfs_fs_i.h linux-2.4.30.dev/include/linux/nfs_fs_i.h
--- linux-2.4.30.old/include/linux/nfs_fs_i.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.30.dev/include/linux/nfs_fs_i.h	2008-05-11 02:17:53.000000000 +0200
@@ -85,6 +85,7 @@
 #define NFS_INO_REVALIDATING	0x0004		/* revalidating attrs */
 #define NFS_IS_SNAPSHOT		0x0010		/* a snapshot file */
 #define NFS_INO_FLUSH		0x0020		/* inode is due for flushing */
+#define NFS_INO_MAPPED		0x0040		/* page invalidation failed */
 
 /*
  * NFS lock info
diff -urN linux-2.4.30.old/include/linux/pci_ids.h linux-2.4.30.dev/include/linux/pci_ids.h
--- linux-2.4.30.old/include/linux/pci_ids.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/pci_ids.h	2008-05-11 02:17:54.000000000 +0200
@@ -319,7 +319,11 @@
 /* RadeonIGP */
 #define PCI_DEVICE_ID_ATI_RADEON_IGP	0xCAB0
 /* ATI IXP Chipset */
-#define PCI_DEVICE_ID_ATI_IXP_IDE	0x4349
+#define PCI_DEVICE_ID_ATI_IXP200_IDE	0x4349
+#define PCI_DEVICE_ID_ATI_IXP300_IDE	0x4369
+#define PCI_DEVICE_ID_ATI_IXP300_SATA	0x436e
+#define PCI_DEVICE_ID_ATI_IXP400_IDE	0x4376
+#define PCI_DEVICE_ID_ATI_IXP400_SATA	0x4379
 
 #define PCI_VENDOR_ID_VLSI		0x1004
 #define PCI_DEVICE_ID_VLSI_82C592	0x0005
@@ -608,6 +612,10 @@
 #define PCI_DEVICE_ID_HP_PCIX_LBA	0x122e
 #define PCI_DEVICE_ID_HP_SX1000_IOC	0x127c
 #define PCI_DEVICE_ID_HP_CISS		0x3210
+#define PCI_DEVICE_ID_HP_CISSA		0x3220
+#define PCI_DEVICE_ID_HP_CISSB		0x3222
+#define PCI_DEVICE_ID_HP_CISSC		0x3230
+#define PCI_DEVICE_ID_HP_CISSD		0x3238
 
 #define PCI_VENDOR_ID_PCTECH		0x1042
 #define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
@@ -1034,6 +1042,16 @@
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE3_1		0x0201
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE3_2		0x0202
 #define PCI_DEVICE_ID_NVIDIA_QUADRO_DDC		0x0203
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_IDE	0x0265
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA	0x0266
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA2	0x0267
+#define PCI_DEVICE_ID_NVIDIA_NVENET_12		0x0268
+#define PCI_DEVICE_ID_NVIDIA_NVENET_13		0x0269
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_IDE	0x036E
+#define PCI_DEVICE_ID_NVIDIA_NVENET_14		0x0372
+#define PCI_DEVICE_ID_NVIDIA_NVENET_15		0x0373
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA	0x037E
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA2	0x037F
 
 #define PCI_VENDOR_ID_IMS		0x10e0
 #define PCI_DEVICE_ID_IMS_8849		0x8849
@@ -1141,6 +1159,7 @@
 #define PCI_DEVICE_ID_VIA_8377_0	0x3189
 #define PCI_DEVICE_ID_VIA_K8T400M_0	0x3188
 #define PCI_DEVICE_ID_VIA_8237		0x3227
+#define PCI_DEVICE_ID_VIA_8237A		0x3337
 #define PCI_DEVICE_ID_VIA_86C100A	0x6100
 #define PCI_DEVICE_ID_VIA_8231		0x8231
 #define PCI_DEVICE_ID_VIA_8231_4	0x8235
@@ -1699,6 +1718,8 @@
 #define PCI_DEVICE_ID_AFAVLAB_P028	0x2180
 
 #define PCI_VENDOR_ID_BROADCOM		0x14e4
+#define PCI_DEVICE_ID_TIGON3_5752	0x1600
+#define PCI_DEVICE_ID_TIGON3_5752M	0x1601
 #define PCI_DEVICE_ID_TIGON3_5700	0x1644
 #define PCI_DEVICE_ID_TIGON3_5701	0x1645
 #define PCI_DEVICE_ID_TIGON3_5702	0x1646
@@ -1735,6 +1756,7 @@
 #define PCI_DEVICE_ID_TIGON3_5901_2	0x170e
 #define PCI_DEVICE_ID_BCM4401		0x4401
 #define PCI_DEVICE_ID_BCM4401B0		0x4402
+#define PCI_DEVICE_ID_BCM4713		0x4713
 
 #define PCI_VENDOR_ID_ENE		0x1524
 #define PCI_DEVICE_ID_ENE_1211		0x1211
@@ -1957,6 +1979,7 @@
 #define PCI_DEVICE_ID_INTEL_ICH6_1	0x2641
 #define PCI_DEVICE_ID_INTEL_ICH6_2	0x266f
 #define PCI_DEVICE_ID_INTEL_ICH6_18	0x266e
+#define PCI_DEVICE_ID_INTEL_ICH7_21	0x27df
 #define PCI_DEVICE_ID_INTEL_82850_HB	0x2530
 #define PCI_DEVICE_ID_INTEL_82845G_HB	0x2560
 #define PCI_DEVICE_ID_INTEL_SMCH	0x3590
@@ -2079,3 +2102,7 @@
 
 #define PCI_VENDOR_ID_WORKBIT		0x1145
 #define PCI_DEVICE_ID_WORKBIT_CB	0xf021
+
+#define PCI_VENDOR_ID_JMICRON		0x197b
+#define PCI_DEVICE_ID_JMICRON_20363	0x2363
+
diff -urN linux-2.4.30.old/include/linux/ppp-comp.h linux-2.4.30.dev/include/linux/ppp-comp.h
--- linux-2.4.30.old/include/linux/ppp-comp.h	1999-08-06 19:44:11.000000000 +0200
+++ linux-2.4.30.dev/include/linux/ppp-comp.h	2008-05-11 02:17:51.000000000 +0200
@@ -28,7 +28,7 @@
  */
 
 /*
- *  ==FILEVERSION 980319==
+ *  ==FILEVERSION 20040509==
  *
  *  NOTE TO MAINTAINERS:
  *     If you modify this file at all, please set the above date.
@@ -78,7 +78,7 @@
 
 	/* Compress a packet */
 	int     (*compress) (void *state, unsigned char *rptr,
-			      unsigned char *obuf, int isize, int osize);
+			     unsigned char *obuf, int isize, int osize);
 
 	/* Return compression statistics */
 	void	(*comp_stat) (void *state, struct compstat *stats);
@@ -99,7 +99,7 @@
 
 	/* Decompress a packet. */
 	int	(*decompress) (void *state, unsigned char *ibuf, int isize,
-				unsigned char *obuf, int osize);
+			       unsigned char *obuf, int osize);
 
 	/* Update state for an incompressible packet received */
 	void	(*incomp) (void *state, unsigned char *ibuf, int icnt);
@@ -187,6 +187,42 @@
 #define DEFLATE_CHK_SEQUENCE	0
 
 /*
+ * Definitions for MPPE/MPPC.
+ */
+
+#define CI_MPPE			18	/* config option for MPPE */
+#define CILEN_MPPE		6	/* length of config option */
+
+#define MPPE_OVHD		4	/* MPPE overhead */
+#define MPPE_MAX_KEY_LEN	16	/* largest key length (128-bit) */
+
+#define MPPE_STATELESS          0x01	/* configuration bit H */
+#define MPPE_40BIT              0x20	/* configuration bit L */
+#define MPPE_56BIT              0x80	/* configuration bit M */
+#define MPPE_128BIT             0x40	/* configuration bit S */
+#define MPPE_MPPC               0x01	/* configuration bit C */
+
+/*
+ * Definitions for Stac LZS.
+ */
+
+#define CI_LZS			17	/* config option for Stac LZS */
+#define CILEN_LZS		5	/* length of config option */
+
+#define LZS_OVHD		4	/* max. LZS overhead */
+#define LZS_HIST_LEN		2048	/* LZS history size */
+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
+
+#define LZS_MODE_NONE		0
+#define LZS_MODE_LCB		1
+#define LZS_MODE_CRC		2
+#define LZS_MODE_SEQ		3
+#define LZS_MODE_EXT		4
+
+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
+
+/*
  * Definitions for other, as yet unsupported, compression methods.
  */
 
diff -urN linux-2.4.30.old/include/linux/proc_fs.h linux-2.4.30.dev/include/linux/proc_fs.h
--- linux-2.4.30.old/include/linux/proc_fs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/proc_fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -70,6 +70,7 @@
 	atomic_t count;		/* use count */
 	int deleted;		/* delete flag */
 	kdev_t	rdev;
+	void *set;
 };
 
 #define PROC_INODE_PROPER(inode) ((inode)->i_ino & ~0xffff)
diff -urN linux-2.4.30.old/include/linux/reiserfs_fs.h linux-2.4.30.dev/include/linux/reiserfs_fs.h
--- linux-2.4.30.old/include/linux/reiserfs_fs.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/reiserfs_fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -787,7 +787,7 @@
 
 
 /* Get right delimiting key. -- little endian */
-#define B_PRIGHT_DELIM_KEY(p_s_bh)   (&(blk_right_delim_key(B_BLK_HEAD(p_s_bh))
+#define B_PRIGHT_DELIM_KEY(p_s_bh)   (&(blk_right_delim_key(B_BLK_HEAD(p_s_bh))))
 
 /* Does the buffer contain a disk leaf. */
 #define B_IS_ITEMS_LEVEL(p_s_bh)     (B_LEVEL(p_s_bh) == DISK_LEAF_NODE_LEVEL)
diff -urN linux-2.4.30.old/include/linux/sdla.h linux-2.4.30.dev/include/linux/sdla.h
--- linux-2.4.30.old/include/linux/sdla.h	1996-04-15 10:50:47.000000000 +0200
+++ linux-2.4.30.dev/include/linux/sdla.h	2008-05-11 02:17:53.000000000 +0200
@@ -293,23 +293,23 @@
 #define SDLA_S508_INTEN			0x10
 
 struct sdla_cmd {
-   char  opp_flag		__attribute__((packed));
-   char  cmd			__attribute__((packed));
+   char  opp_flag;
+   char  cmd;
    short length			__attribute__((packed));
-   char  retval			__attribute__((packed));
+   char  retval;
    short dlci			__attribute__((packed));
-   char  flags			__attribute__((packed));
+   char  flags;
    short rxlost_int		__attribute__((packed));
    long  rxlost_app		__attribute__((packed));
-   char  reserve[2]		__attribute__((packed));
-   char  data[SDLA_MAX_DATA]	__attribute__((packed));	/* transfer data buffer */
+   char  reserve[2];
+   char  data[SDLA_MAX_DATA];	/* transfer data buffer */
 };
 
 struct intr_info {
-   char  flags		__attribute__((packed));
+   char  flags;
    short txlen		__attribute__((packed));
-   char  irq		__attribute__((packed));
-   char  flags2		__attribute__((packed));
+   char  irq;
+   char  flags2;
    short timeout	__attribute__((packed));
 };
 
@@ -325,10 +325,10 @@
 
 /* structure pointed to by rse_base in RXBUF_INFO struct */
 struct buf_entry {
-   char  opp_flag	__attribute__((packed));
+   char  opp_flag;
    short length		__attribute__((packed));
    short dlci		__attribute__((packed));
-   char  flags		__attribute__((packed));
+   char  flags;
    short timestamp	__attribute__((packed));
    short reserved[2]	__attribute__((packed));
    long  buf_addr	__attribute__((packed));
diff -urN linux-2.4.30.old/include/linux/sdla_chdlc.h linux-2.4.30.dev/include/linux/sdla_chdlc.h
--- linux-2.4.30.old/include/linux/sdla_chdlc.h	2001-04-12 21:11:39.000000000 +0200
+++ linux-2.4.30.dev/include/linux/sdla_chdlc.h	2008-05-11 02:17:53.000000000 +0200
@@ -61,12 +61,12 @@
 #define PRI_MAX_NO_DATA_BYTES_IN_FRAME  15354 /* PRIMARY - max length of the CHDLC data field */
 
 typedef struct {
-	unsigned char opp_flag PACKED;			/* the opp flag */
-	unsigned char command PACKED;			/* the user command */
+	unsigned char opp_flag;			/* the opp flag */
+	unsigned char command;			/* the user command */
 	unsigned short buffer_length PACKED;		/* the data length */
-  	unsigned char return_code PACKED;		/* the return code */
-	unsigned char MB_reserved[NUMBER_MB_RESERVED_BYTES] PACKED;	/* reserved for later */
-	unsigned char data[SIZEOF_MB_DATA_BFR] PACKED;	/* the data area */
+  	unsigned char return_code;		/* the return code */
+	unsigned char MB_reserved[NUMBER_MB_RESERVED_BYTES];	/* reserved for later */
+	unsigned char data[SIZEOF_MB_DATA_BFR];	/* the data area */
 } CHDLC_MAILBOX_STRUCT;
 
 typedef struct {
@@ -248,7 +248,7 @@
 
 /* the trace configuration structure (SET_TRACE_CONFIGURATION/READ_TRACE_CONFIGURATION commands) */
 typedef struct {
-	unsigned char trace_config PACKED;		/* trace configuration */
+	unsigned char trace_config;		/* trace configuration */
 	unsigned short trace_deactivation_timer PACKED;	/* trace deactivation timer */
 	unsigned long ptr_trace_stat_el_cfg_struct PACKED;	/* a pointer to the line trace element configuration structure */
 } LINE_TRACE_CONFIG_STRUCT;
@@ -272,9 +272,9 @@
 
 /* the line trace status element structure */
 typedef struct {
-	unsigned char opp_flag PACKED;			/* opp flag */
+	unsigned char opp_flag;			/* opp flag */
 	unsigned short trace_length PACKED;		/* trace length */
-	unsigned char trace_type PACKED;		/* trace type */
+	unsigned char trace_type;		/* trace type */
 	unsigned short trace_time_stamp PACKED;	/* time stamp */
 	unsigned short trace_reserved_1 PACKED;	/* reserved for later use */
 	unsigned long trace_reserved_2 PACKED;		/* reserved for later use */
@@ -415,10 +415,10 @@
 
 /* the CHDLC status structure */
 typedef struct {
-	unsigned char CHDLC_link_status PACKED;	/* CHDLC link status */
-	unsigned char no_Data_frms_for_app PACKED;	/* number of Data frames available for the application */
-	unsigned char receiver_status PACKED;	/* enabled/disabled */
-	unsigned char SLARP_state PACKED;	/* internal SLARP state */
+	unsigned char CHDLC_link_status;	/* CHDLC link status */
+	unsigned char no_Data_frms_for_app;	/* number of Data frames available for the application */
+	unsigned char receiver_status;	/* enabled/disabled */
+	unsigned char SLARP_state;	/* internal SLARP state */
 } CHDLC_LINK_STATUS_STRUCT;
 
 /* settings for the 'CHDLC_link_status' variable */
@@ -519,8 +519,8 @@
 
 /* the structure used for the SET_CHDLC_INTERRUPT_TRIGGERS/READ_CHDLC_INTERRUPT_TRIGGERS command */
 typedef struct {
-	unsigned char CHDLC_interrupt_triggers PACKED;	/* CHDLC interrupt trigger configuration */
-	unsigned char IRQ PACKED;			/* IRQ to be used */
+	unsigned char CHDLC_interrupt_triggers;	/* CHDLC interrupt trigger configuration */
+	unsigned char IRQ;			/* IRQ to be used */
 	unsigned short interrupt_timer PACKED;		/* interrupt timer */
 	unsigned short misc_interrupt_bits PACKED;	/* miscellaneous bits */
 } CHDLC_INT_TRIGGERS_STRUCT;
@@ -563,9 +563,9 @@
 
 /* the Data frame transmit status element structure */
 typedef struct {
-	unsigned char opp_flag PACKED;		/* opp flag */
+	unsigned char opp_flag;		/* opp flag */
 	unsigned short frame_length PACKED;	/* length of the frame to be transmitted */
-	unsigned char reserved_1 PACKED;	/* reserved for internal use */
+	unsigned char reserved_1;	/* reserved for internal use */
 	unsigned long reserved_2 PACKED;	/* reserved for internal use */
 	unsigned long reserved_3 PACKED;	/* reserved for internal use */
 	unsigned long ptr_data_bfr PACKED;	/* pointer to the data area */
@@ -588,9 +588,9 @@
 
 /* the Data frame receive status element structure */
 typedef struct {
-	unsigned char opp_flag PACKED;		/* opp flag */
+	unsigned char opp_flag;		/* opp flag */
 	unsigned short frame_length PACKED;   /* length of the received frame */
-        unsigned char error_flag PACKED; /* frame errors (HDLC_STREAMING_MODE)*/
+        unsigned char error_flag; /* frame errors (HDLC_STREAMING_MODE)*/
         unsigned short time_stamp PACKED; /* receive time stamp (HDLC_STREAMING_MODE) */
         unsigned long reserved_1 PACKED; 	/* reserved for internal use */
         unsigned short reserved_2 PACKED; 	/* reserved for internal use */
@@ -605,33 +605,33 @@
 
 /* the global information structure */
 typedef struct {
- 	unsigned char global_status PACKED;		/* global status */
- 	unsigned char modem_status PACKED;		/* current modem status */
- 	unsigned char global_excep_conditions PACKED;	/* global exception conditions */
-	unsigned char glob_info_reserved[5] PACKED;	/* reserved */
-	unsigned char codename[4] PACKED;		/* Firmware name */
-	unsigned char codeversion[4] PACKED;		/* Firmware version */
+ 	unsigned char global_status;		/* global status */
+ 	unsigned char modem_status;		/* current modem status */
+ 	unsigned char global_excep_conditions;	/* global exception conditions */
+	unsigned char glob_info_reserved[5];	/* reserved */
+	unsigned char codename[4];		/* Firmware name */
+	unsigned char codeversion[4];		/* Firmware version */
 } GLOBAL_INFORMATION_STRUCT;
 
 /* the CHDLC information structure */
 typedef struct {
-	unsigned char CHDLC_status PACKED;		/* CHDLC status */
- 	unsigned char CHDLC_excep_conditions PACKED;	/* CHDLC exception conditions */
-	unsigned char CHDLC_info_reserved[14] PACKED;	/* reserved */
+	unsigned char CHDLC_status;		/* CHDLC status */
+ 	unsigned char CHDLC_excep_conditions;	/* CHDLC exception conditions */
+	unsigned char CHDLC_info_reserved[14];	/* reserved */
 } CHDLC_INFORMATION_STRUCT;
 
 /* the interrupt information structure */
 typedef struct {
- 	unsigned char interrupt_type PACKED;		/* type of interrupt triggered */
- 	unsigned char interrupt_permission PACKED;	/* interrupt permission mask */
-	unsigned char int_info_reserved[14] PACKED;	/* reserved */
+ 	unsigned char interrupt_type;		/* type of interrupt triggered */
+ 	unsigned char interrupt_permission;	/* interrupt permission mask */
+	unsigned char int_info_reserved[14];	/* reserved */
 } INTERRUPT_INFORMATION_STRUCT;
 
 /* the S508/FT1 information structure */
 typedef struct {
- 	unsigned char parallel_port_A_input PACKED;	/* input - parallel port A */
- 	unsigned char parallel_port_B_input PACKED;	/* input - parallel port B */
-	unsigned char FT1_info_reserved[14] PACKED;	/* reserved */
+ 	unsigned char parallel_port_A_input;	/* input - parallel port A */
+ 	unsigned char parallel_port_B_input;	/* input - parallel port B */
+	unsigned char FT1_info_reserved[14];	/* reserved */
 } FT1_INFORMATION_STRUCT;
 
 /* the shared memory area information structure */
@@ -650,32 +650,32 @@
    This is essentially a mailbox structure, without the large data field */
 
 typedef struct {
-        unsigned char  opp_flag PACKED;                  /* the opp flag */
-        unsigned char  command PACKED;                   /* the user command */
+        unsigned char  opp_flag;                  /* the opp flag */
+        unsigned char  command;                   /* the user command */
         unsigned short buffer_length PACKED;             /* the data length */
-        unsigned char  return_code PACKED;               /* the return code */
-	unsigned char  MB_reserved[NUMBER_MB_RESERVED_BYTES] PACKED;	/* reserved for later */
+        unsigned char  return_code;               /* the return code */
+	unsigned char  MB_reserved[NUMBER_MB_RESERVED_BYTES];	/* reserved for later */
 } cblock_t;
 
 
 /* UDP management packet layout (data area of ip packet) */
 /*
 typedef struct {
-	unsigned char		signature[8]	PACKED;
-	unsigned char		request_reply	PACKED;
-	unsigned char		id		PACKED;
-	unsigned char		reserved[6]	PACKED;
+	unsigned char		signature[8];
+	unsigned char		request_reply;
+	unsigned char		id;
+	unsigned char		reserved[6];
 	cblock_t		cblock		PACKED;
-	unsigned char		num_frames	PACKED;
-	unsigned char		ismoredata	PACKED;
-	unsigned char 		data[SIZEOF_MB_DATA_BFR] 	PACKED;
+	unsigned char		num_frames;
+	unsigned char		ismoredata;
+	unsigned char 		data[SIZEOF_MB_DATA_BFR];
 } udp_management_packet_t;
 
 */
 
 typedef struct {
-	unsigned char		num_frames	PACKED;
-	unsigned char		ismoredata	PACKED;
+	unsigned char		num_frames;
+	unsigned char		ismoredata;
 } trace_info_t;
 
 typedef struct {
@@ -684,20 +684,20 @@
 	wp_mgmt_t		wp_mgmt		PACKED;
 	cblock_t                cblock          PACKED;
 	trace_info_t       	trace_info      PACKED;
-	unsigned char           data[SIZEOF_MB_DATA_BFR]      PACKED;
+	unsigned char           data[SIZEOF_MB_DATA_BFR];
 } chdlc_udp_pkt_t;
 
 typedef struct ft1_exec_cmd{
-	unsigned char  command PACKED;                   /* the user command */
+	unsigned char  command;                   /* the user command */
         unsigned short buffer_length PACKED;             /* the data length */
-        unsigned char  return_code PACKED;               /* the return code */
-	unsigned char  MB_reserved[NUMBER_MB_RESERVED_BYTES] PACKED;
+        unsigned char  return_code;               /* the return code */
+	unsigned char  MB_reserved[NUMBER_MB_RESERVED_BYTES];
 } ft1_exec_cmd_t;
 
 typedef struct {
-	unsigned char  opp_flag 			PACKED;
+	unsigned char  opp_flag;
 	ft1_exec_cmd_t cmd				PACKED;
-	unsigned char  data[SIZEOF_MB_DATA_BFR]      	PACKED;
+	unsigned char  data[SIZEOF_MB_DATA_BFR];
 } ft1_exec_t;
 
 #define UDPMGMT_SIGNATURE	"CTPIPEAB"
@@ -706,11 +706,11 @@
 /* UDP/IP packet (for UDP management) layout */
 /*
 typedef struct {
-	unsigned char	reserved[2]	PACKED;
+	unsigned char	reserved[2];
 	unsigned short	ip_length	PACKED;
-	unsigned char	reserved2[4]	PACKED;
-	unsigned char	ip_ttl		PACKED;
-	unsigned char	ip_protocol	PACKED;
+	unsigned char	reserved2[4];
+	unsigned char	ip_ttl;
+	unsigned char	ip_protocol;
 	unsigned short	ip_checksum	PACKED;
 	unsigned long	ip_src_address	PACKED;
 	unsigned long	ip_dst_address	PACKED;
@@ -727,17 +727,17 @@
 
 
 typedef struct {
-	unsigned char	status		PACKED;
-	unsigned char	data_avail	PACKED;
+	unsigned char	status;
+	unsigned char	data_avail;
 	unsigned short	real_length	PACKED;
 	unsigned short	time_stamp	PACKED;
-	unsigned char	data[1]		PACKED;
+	unsigned char	data[1];
 } trace_pkt_t;
 
 typedef struct {
-	unsigned char	error_flag	PACKED;
+	unsigned char	error_flag;
 	unsigned short	time_stamp	PACKED;
-	unsigned char	reserved[13]	PACKED;
+	unsigned char	reserved[13];
 } api_rx_hdr_t;
 
 typedef struct {
@@ -746,8 +746,8 @@
 } api_rx_element_t;
 
 typedef struct {
-	unsigned char 	attr		PACKED;
-	unsigned char  	reserved[15]	PACKED;
+	unsigned char 	attr;
+	unsigned char  	reserved[15];
 } api_tx_hdr_t;
 
 typedef struct {
diff -urN linux-2.4.30.old/include/linux/sdla_x25.h linux-2.4.30.dev/include/linux/sdla_x25.h
--- linux-2.4.30.old/include/linux/sdla_x25.h	2001-04-12 21:11:39.000000000 +0200
+++ linux-2.4.30.dev/include/linux/sdla_x25.h	2008-05-11 02:17:53.000000000 +0200
@@ -56,16 +56,16 @@
  */
 typedef struct X25Cmd
 {
-	unsigned char command	PACKED;	/* command code */
+	unsigned char command;	/* command code */
 	unsigned short length	PACKED;	/* transfer data length */
-	unsigned char result	PACKED;	/* return code */
-	unsigned char pf	PACKED;	/* P/F bit */
+	unsigned char result;	/* return code */
+	unsigned char pf;	/* P/F bit */
 	unsigned short lcn	PACKED;	/* logical channel */
-	unsigned char qdm	PACKED;	/* Q/D/M bits */
-	unsigned char cause	PACKED;	/* cause field */
-	unsigned char diagn	PACKED;	/* diagnostics */
-	unsigned char pktType	PACKED;	/* packet type */
-	unsigned char resrv[4]	PACKED;	/* reserved */
+	unsigned char qdm;	/* Q/D/M bits */
+	unsigned char cause;	/* cause field */
+	unsigned char diagn;	/* diagnostics */
+	unsigned char pktType;	/* packet type */
+	unsigned char resrv[4];	/* reserved */
 } TX25Cmd;
 
 /*
@@ -228,9 +228,9 @@
  */
 typedef struct X25Mbox
 {
-	unsigned char opflag	PACKED;	/* 00h: execution flag */
+	unsigned char opflag;	/* 00h: execution flag */
 	TX25Cmd cmd		PACKED;	/* 01h: command block */
-	unsigned char data[1]	PACKED;	/* 10h: data buffer */
+	unsigned char data[1];	/* 10h: data buffer */
 } TX25Mbox;
 
 /*----------------------------------------------------------------------------
@@ -238,11 +238,11 @@
  */
 typedef struct X25TimeStamp
 {
-	unsigned char month	PACKED;
-	unsigned char date	PACKED;
-	unsigned char sec	PACKED;
-	unsigned char min	PACKED;
-	unsigned char hour	PACKED;
+	unsigned char month;
+	unsigned char date;
+	unsigned char sec;
+	unsigned char min;
+	unsigned char hour;
 } TX25TimeStamp;
 
 /*----------------------------------------------------------------------------
@@ -257,11 +257,11 @@
 	unsigned short twc_map	PACKED;	/* 04h: Two-way Cnan. map */
 	unsigned short ogc_map	PACKED;	/* 06h: Outgoing Chan. map */
 	TX25TimeStamp tstamp	PACKED;	/* 08h: timestamp (BCD) */
-	unsigned char iflags	PACKED;	/* 0Dh: interrupt flags */
-	unsigned char imask     PACKED; /* 0Eh: interrupt mask  */
-	unsigned char resrv	PACKED;	/* 0Eh: */
-	unsigned char gflags	PACKED;	/* 10h: misc. HDLC/X25 flags */
-	unsigned char cflags[X25_MAX_CHAN] PACKED; /* channel status bytes */
+	unsigned char iflags;	/* 0Dh: interrupt flags */
+	unsigned char imask;		/* 0Eh: interrupt mask  */
+	unsigned char resrv;	/* 0Eh: */
+	unsigned char gflags;	/* 10h: misc. HDLC/X25 flags */
+	unsigned char cflags[X25_MAX_CHAN]; /* channel status bytes */
 } TX25Status;
 
 /*
@@ -299,9 +299,9 @@
  */
 typedef struct X25GlobalVars
 {
-	unsigned char resrv	PACKED;	/* 00h: reserved */
-	unsigned char dtrCtl	PACKED;	/* 01h: DTR control code */
-	unsigned char resErr	PACKED;	/* 01h: '1' - reset modem error */
+	unsigned char resrv;	/* 00h: reserved */
+	unsigned char dtrCtl;	/* 01h: DTR control code */
+	unsigned char resErr;	/* 01h: '1' - reset modem error */
 } TX25GlobalVars;
 
 /*
@@ -315,7 +315,7 @@
  */
 typedef struct X25ModemStatus
 {
-	unsigned char	status	PACKED;		/* 00h: modem status */
+	unsigned char	status;		/* 00h: modem status */
 } TX25ModemStatus;
 
 /*
@@ -329,11 +329,11 @@
  */
 typedef struct X25LinkStatus
 {
-	unsigned char txQueued	PACKED;	/* 00h: queued Tx I-frames*/
-	unsigned char rxQueued	PACKED;	/* 01h: queued Rx I-frames*/
-	unsigned char station	PACKED;	/* 02h: DTE/DCE config. */
-	unsigned char reserved	PACKED;	/* 03h: reserved */
-	unsigned char sfTally	PACKED;	/* 04h: supervisory frame tally */
+	unsigned char txQueued;	/* 00h: queued Tx I-frames*/
+	unsigned char rxQueued;	/* 01h: queued Rx I-frames*/
+	unsigned char station;	/* 02h: DTE/DCE config. */
+	unsigned char reserved;	/* 03h: reserved */
+	unsigned char sfTally;	/* 04h: supervisory frame tally */
 } TX25LinkStatus;
 
 /*
@@ -371,16 +371,16 @@
  */
 typedef struct HdlcCommErr
 {						/*	a number of ... */
-	unsigned char rxOverrun		PACKED;	/* 00h: Rx overrun errors */
-	unsigned char rxBadCrc		PACKED;	/* 01h: Rx CRC errors */
-	unsigned char rxAborted		PACKED;	/* 02h: Rx aborted frames */
-	unsigned char rxDropped		PACKED;	/* 03h: frames lost */
-	unsigned char txAborted		PACKED;	/* 04h: Tx aborted frames */
-	unsigned char txUnderrun	PACKED;	/* 05h: Tx underrun errors */
-	unsigned char txMissIntr	PACKED;	/* 06h: missed underrun ints */
-	unsigned char reserved		PACKED;	/* 07h: reserved */
-	unsigned char droppedDCD	PACKED;	/* 08h: times DCD dropped */
-	unsigned char droppedCTS	PACKED;	/* 09h: times CTS dropped */
+	unsigned char rxOverrun;	/* 00h: Rx overrun errors */
+	unsigned char rxBadCrc;	/* 01h: Rx CRC errors */
+	unsigned char rxAborted;	/* 02h: Rx aborted frames */
+	unsigned char rxDropped;	/* 03h: frames lost */
+	unsigned char txAborted;	/* 04h: Tx aborted frames */
+	unsigned char txUnderrun;	/* 05h: Tx underrun errors */
+	unsigned char txMissIntr;	/* 06h: missed underrun ints */
+	unsigned char reserved;	/* 07h: reserved */
+	unsigned char droppedDCD;	/* 08h: times DCD dropped */
+	unsigned char droppedCTS;	/* 09h: times CTS dropped */
 } THdlcCommErr;
 
 /* ---------------------------------------------------------------------------
@@ -388,18 +388,18 @@
  */
 typedef struct X25Config
 {
-unsigned char baudRate		PACKED;	/* 00h:  */
-	unsigned char t1		PACKED;	/* 01h:  */
-	unsigned char t2		PACKED;	/* 02h:  */
-	unsigned char n2		PACKED;	/* 03h:  */
+unsigned char baudRate;	/* 00h:  */
+	unsigned char t1;	/* 01h:  */
+	unsigned char t2;	/* 02h:  */
+	unsigned char n2;	/* 03h:  */
 	unsigned short hdlcMTU		PACKED;	/* 04h:  */
-	unsigned char hdlcWindow	PACKED;	/* 06h:  */
-	unsigned char t4		PACKED;	/* 07h:  */
-	unsigned char autoModem		PACKED;	/* 08h:  */
-	unsigned char autoHdlc		PACKED;	/* 09h:  */
-	unsigned char hdlcOptions	PACKED;	/* 0Ah:  */
-	unsigned char station		PACKED;	/* 0Bh:  */
-	unsigned char pktWindow		PACKED;	/* 0Ch:  */
+	unsigned char hdlcWindow;	/* 06h:  */
+	unsigned char t4;	/* 07h:  */
+	unsigned char autoModem;	/* 08h:  */
+	unsigned char autoHdlc;	/* 09h:  */
+	unsigned char hdlcOptions;	/* 0Ah:  */
+	unsigned char station;	/* 0Bh:  */
+	unsigned char pktWindow;	/* 0Ch:  */
 	unsigned short defPktSize	PACKED;	/* 0Dh:  */
 	unsigned short pktMTU		PACKED;	/* 0Fh:  */
 	unsigned short loPVC		PACKED;	/* 11h:  */
@@ -411,21 +411,21 @@
 	unsigned short loOutgoingSVC	PACKED;	/* 1Dh:  */
 	unsigned short hiOutgoingSVC	PACKED;	/* 1Fh:  */
 	unsigned short options		PACKED;	/* 21h:  */
-	unsigned char responseOpt	PACKED;	/* 23h:  */
+	unsigned char responseOpt;	/* 23h:  */
 	unsigned short facil1		PACKED;	/* 24h:  */
 	unsigned short facil2		PACKED;	/* 26h:  */
 	unsigned short ccittFacil	PACKED;	/* 28h:  */
 	unsigned short otherFacil	PACKED;	/* 2Ah:  */
 	unsigned short ccittCompat	PACKED;	/* 2Ch:  */
-	unsigned char t10t20		PACKED;	/* 2Eh:  */
-	unsigned char t11t21		PACKED;	/* 2Fh:  */
-	unsigned char t12t22		PACKED;	/* 30h:  */
-	unsigned char t13t23		PACKED;	/* 31h:  */
-	unsigned char t16t26		PACKED;	/* 32H:  */
-	unsigned char t28		PACKED;	/* 33h:  */
-	unsigned char r10r20		PACKED;	/* 34h:  */
-	unsigned char r12r22		PACKED;	/* 35h:  */
-	unsigned char r13r23		PACKED;	/* 36h:  */
+	unsigned char t10t20;	/* 2Eh:  */
+	unsigned char t11t21;	/* 2Fh:  */
+	unsigned char t12t22;	/* 30h:  */
+	unsigned char t13t23;	/* 31h:  */
+	unsigned char t16t26;	/* 32H:  */
+	unsigned char t28;	/* 33h:  */
+	unsigned char r10r20;	/* 34h:  */
+	unsigned char r12r22;	/* 35h:  */
+	unsigned char r13r23;	/* 36h:  */
 } TX25Config;
 
 /* ---------------------------------------------------------------------------
@@ -445,9 +445,9 @@
 
 typedef struct X25ChanCfg		/*------ Channel configuration -----*/
 {
-	unsigned char type	PACKED;	/* 00h: channel type */
-	unsigned char txConf	PACKED;	/* 01h: Tx packet and window sizes */
-	unsigned char rxConf	PACKED;	/* 01h: Rx packet and window sizes */
+	unsigned char type;	/* 00h: channel type */
+	unsigned char txConf;	/* 01h: Tx packet and window sizes */
+	unsigned char rxConf;	/* 01h: Rx packet and window sizes */
 } TX25ChanCfg;
 
 /*
@@ -502,11 +502,11 @@
  */
 typedef struct X25EventLog
 {
-	unsigned char	type	PACKED;	/* 00h: transaction type */
+	unsigned char	type;	/* 00h: transaction type */
 	unsigned short	lcn	PACKED;	/* 01h: logical channel num */
-	unsigned char	packet	PACKED;	/* 03h: async packet type */
-	unsigned char	cause	PACKED;	/* 04h: X.25 cause field */
-	unsigned char	diag	PACKED;	/* 05h: X.25 diag field */
+	unsigned char	packet;	/* 03h: async packet type */
+	unsigned char	cause;	/* 04h: X.25 cause field */
+	unsigned char	diag;	/* 05h: X.25 diag field */
 	TX25TimeStamp	ts	PACKED;	/* 06h: time stamp */
 } TX25EventLog;
 
@@ -540,8 +540,8 @@
  */
 typedef struct X25TraceCfg
 {
-	unsigned char flags	PACKED;	/* 00h: trace configuration flags */
-	unsigned char timeout	PACKED;	/* 01h: timeout for trace delay mode*/
+	unsigned char flags;	/* 00h: trace configuration flags */
+	unsigned char timeout;	/* 01h: timeout for trace delay mode*/
 } TX25TraceCfg;
 
 /*
@@ -562,11 +562,11 @@
 typedef struct X25Trace			/*----- Trace data structure -------*/
 {
 	unsigned short length	PACKED;	/* 00h: trace data length */
-	unsigned char type	PACKED;	/* 02h: trace type */
-	unsigned char lost_cnt	PACKED;	/* 03h: N of traces lost */
+	unsigned char type;	/* 02h: trace type */
+	unsigned char lost_cnt;	/* 03h: N of traces lost */
 	TX25TimeStamp tstamp	PACKED;	/* 04h: mon/date/sec/min/hour */
 	unsigned short millisec	PACKED;	/* 09h: ms time stamp */
-	unsigned char data[0]	PACKED;	/* 0Bh: traced frame */
+	unsigned char data[0];	/* 0Bh: traced frame */
 } TX25Trace;
 
 /*
@@ -591,17 +591,17 @@
 
 typedef struct HDLCFrame		/*----- DHLC Frame Format ----------*/
 {
-	unsigned char addr	PACKED;	/* address field */
-	unsigned char cntl	PACKED;	/* control field */
-	unsigned char data[0]	PACKED;
+	unsigned char addr;	/* address field */
+	unsigned char cntl;	/* control field */
+	unsigned char data[0];
 } THDLCFrame;
 
 typedef struct X25Pkt			/*----- X.25 Paket Format ----------*/
 {
-	unsigned char lcn_hi	PACKED;	/* 4 MSB of Logical Channel Number */
-	unsigned char lcn_lo	PACKED;	/* 8 LSB of Logical Channel Number */
-	unsigned char type	PACKED;
-	unsigned char data[0]	PACKED;
+	unsigned char lcn_hi;	/* 4 MSB of Logical Channel Number */
+	unsigned char lcn_lo;	/* 8 LSB of Logical Channel Number */
+	unsigned char type;
+	unsigned char data[0];
 } TX25Pkt;
 
 /*
@@ -636,25 +636,25 @@
 
 typedef struct {
 	TX25Cmd cmd		PACKED;
-	char data[X25_MAX_DATA]	PACKED;
+	char data[X25_MAX_DATA];
 } mbox_cmd_t;
 
 
 typedef struct {
-	unsigned char  qdm	PACKED;	/* Q/D/M bits */
-	unsigned char  cause	PACKED;	/* cause field */
-	unsigned char  diagn	PACKED;	/* diagnostics */
-	unsigned char  pktType  PACKED;
+	unsigned char  qdm;	/* Q/D/M bits */
+	unsigned char  cause;	/* cause field */
+	unsigned char  diagn;	/* diagnostics */
+	unsigned char  pktType;
 	unsigned short length   PACKED;
-	unsigned char  result	PACKED;
+	unsigned char  result;
 	unsigned short lcn	PACKED;
-	char reserved[7]	PACKED;
+	char reserved[7];
 }x25api_hdr_t;
 
 
 typedef struct {
 	x25api_hdr_t hdr	PACKED;
-	char data[X25_MAX_DATA]	PACKED;
+	char data[X25_MAX_DATA];
 }x25api_t;
 
 
@@ -674,17 +674,17 @@
 
 
 typedef struct {
-	unsigned char opp_flag  PACKED; /* the opp flag */
-	unsigned char command	PACKED;	/* command code */
+	unsigned char opp_flag; /* the opp flag */
+	unsigned char command;	/* command code */
 	unsigned short length	PACKED;	/* transfer data length */
-	unsigned char result	PACKED;	/* return code */
-	unsigned char pf	PACKED;	/* P/F bit */
+	unsigned char result;	/* return code */
+	unsigned char pf;	/* P/F bit */
 	unsigned short lcn	PACKED;	/* logical channel */
-	unsigned char qdm	PACKED;	/* Q/D/M bits */
-	unsigned char cause	PACKED;	/* cause field */
-	unsigned char diagn	PACKED;	/* diagnostics */
-	unsigned char pktType	PACKED;	/* packet type */
-	unsigned char resrv[4]	PACKED;	/* reserved */
+	unsigned char qdm;	/* Q/D/M bits */
+	unsigned char cause;	/* cause field */
+	unsigned char diagn;	/* diagnostics */
+	unsigned char pktType;	/* packet type */
+	unsigned char resrv[4];	/* reserved */
 } cblock_t;
 
 typedef struct {
@@ -692,7 +692,7 @@
 	udp_pkt_t		udp_pkt		PACKED;
 	wp_mgmt_t 		wp_mgmt       	PACKED;
         cblock_t                cblock          PACKED;
-        unsigned char           data[4080]      PACKED;
+        unsigned char           data[4080];
 } x25_udp_pkt_t;
 
 
@@ -717,25 +717,25 @@
 } read_hdlc_stat_t;
 
 typedef struct read_comms_err_stats{
-	unsigned char overrun_err_rx PACKED;
-	unsigned char CRC_err PACKED;
-	unsigned char abort_frames_rx PACKED;
-	unsigned char frames_dropped_buf_full PACKED;
-	unsigned char abort_frames_tx PACKED;
-	unsigned char transmit_underruns PACKED;
-	unsigned char missed_tx_underruns_intr PACKED;
-	unsigned char reserved PACKED;
-	unsigned char DCD_drop PACKED;
-	unsigned char CTS_drop PACKED;
+	unsigned char overrun_err_rx;
+	unsigned char CRC_err;
+	unsigned char abort_frames_rx;
+	unsigned char frames_dropped_buf_full;
+	unsigned char abort_frames_tx;
+	unsigned char transmit_underruns;
+	unsigned char missed_tx_underruns_intr;
+	unsigned char reserved;
+	unsigned char DCD_drop;
+	unsigned char CTS_drop;
 } read_comms_err_stats_t;
 
 typedef struct trace_data {
 	unsigned short length PACKED;
-	unsigned char  type PACKED;
-	unsigned char  trace_dropped PACKED;
-	unsigned char  reserved[5] PACKED;
+	unsigned char  type;
+	unsigned char  trace_dropped;
+	unsigned char  reserved[5];
 	unsigned short timestamp PACKED;
-        unsigned char  data PACKED;
+        unsigned char  data;
 } trace_data_t;
 
 enum {UDP_XPIPE_TYPE};
diff -urN linux-2.4.30.old/include/linux/serial.h linux-2.4.30.dev/include/linux/serial.h
--- linux-2.4.30.old/include/linux/serial.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.30.dev/include/linux/serial.h	2008-05-11 02:17:50.000000000 +0200
@@ -75,7 +75,8 @@
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff -urN linux-2.4.30.old/include/linux/sched.h linux-2.4.30.dev/include/linux/sched.h
--- linux-2.4.30.old/include/linux/sched.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/sched.h	2008-05-11 02:17:50.000000000 +0200
@@ -617,6 +617,10 @@
 extern int in_group_p(gid_t);
 extern int in_egroup_p(gid_t);
 
+extern ATTRIB_NORET void cpu_idle(void);
+
+extern void release_task(struct task_struct * p);
+
 extern void proc_caches_init(void);
 extern void flush_signals(struct task_struct *);
 extern void flush_signal_handlers(struct task_struct *);
diff -urN linux-2.4.30.old/include/linux/skbuff.h linux-2.4.30.dev/include/linux/skbuff.h
--- linux-2.4.30.old/include/linux/skbuff.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/skbuff.h	2008-05-11 02:17:54.000000000 +0200
@@ -92,6 +92,23 @@
 struct nf_ct_info {
 	struct nf_conntrack *master;
 };
+
+#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+struct nf_bridge_info {
+	atomic_t use;
+	struct net_device *physindev;
+	struct net_device *physoutdev;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	struct net_device *netoutdev;
+#endif
+	unsigned int mask;
+	unsigned long data[32 / sizeof(unsigned long)];
+};
+#endif
+
+#endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+struct nf_info;
 #endif
 
 struct sk_buff_head {
@@ -135,10 +152,6 @@
 	struct sock	*sk;			/* Socket we are owned by 			*/
 	struct timeval	stamp;			/* Time we arrived				*/
 	struct net_device	*dev;		/* Device we arrived on/are leaving by		*/
-	struct net_device	*real_dev;	/* For support of point to point protocols 
-						   (e.g. 802.3ad) over bonding, we must save the
-						   physical device that got the packet before
-						   replacing skb->dev with the virtual device.  */
 
 	/* Transport layer header */
 	union
@@ -182,7 +195,7 @@
 	unsigned int 	len;			/* Length of actual data			*/
  	unsigned int 	data_len;
 	unsigned int	csum;			/* Checksum 					*/
-	unsigned char 	__unused,		/* Dead field, may be reused			*/
+	unsigned char 	imq_flags,		/* intermediate queueing device	*/
 			cloned, 		/* head may be cloned (check refcnt to be sure). */
   			pkt_type,		/* Packet class					*/
   			ip_summed;		/* Driver fed us an IP checksum			*/
@@ -208,6 +221,9 @@
 #ifdef CONFIG_NETFILTER_DEBUG
         unsigned int nf_debug;
 #endif
+#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+	struct nf_bridge_info	*nf_bridge;	/* Saved data about a bridged frame - see br_netfilter.c */
+#endif
 #endif /*CONFIG_NETFILTER*/
 
 #if defined(CONFIG_HIPPI)
@@ -219,6 +235,13 @@
 #ifdef CONFIG_NET_SCHED
        __u32           tc_index;               /* traffic control index */
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+       struct nf_info	*nf_info;
+#endif
+	struct net_device	*real_dev;	/* For support of point to point protocols 
+						   (e.g. 802.3ad) over bonding, we must save the
+						   physical device that got the packet before
+						   replacing skb->dev with the virtual device.  */
 };
 
 #ifdef __KERNEL__
@@ -912,6 +935,49 @@
 	skb->tail+=len;
 }
 
+/*
+ * CPUs often take a performance hit when accessing unaligned memory
+ * locations. The actual performance hit varies, it can be small if the
+ * hardware handles it or large if we have to take an exception and fix it
+ * in software.
+ *
+ * Since an ethernet header is 14 bytes network drivers often end up with
+ * the IP header at an unaligned offset. The IP header can be aligned by
+ * shifting the start of the packet by 2 bytes. Drivers should do this
+ * with:
+ *
+ * skb_reserve(NET_IP_ALIGN);
+ *
+ * The downside to this alignment of the IP header is that the DMA is now
+ * unaligned. On some architectures the cost of an unaligned DMA is high
+ * and this cost outweighs the gains made by aligning the IP header.
+ * 
+ * Since this trade off varies between architectures, we allow NET_IP_ALIGN
+ * to be overridden.
+ */
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN    2
+#endif
+
+/*
+ * The networking layer reserves some headroom in skb data (via
+ * dev_alloc_skb). This is used to avoid having to reallocate skb data when
+ * the header has to grow. In the default case, if the header has to grow
+ * 16 bytes or less we avoid the reallocation.
+ *
+ * Unfortunately this headroom changes the DMA alignment of the resulting
+ * network packet. As for NET_IP_ALIGN, this unaligned DMA is expensive
+ * on some architectures. An architecture can override this value,
+ * perhaps setting it to a cacheline in size (since that will maintain
+ * cacheline alignment of the DMA). It must be a power of 2.
+ *
+ * Various parts of the networking layer expect at least 16 bytes of
+ * headroom, you should not reduce this.
+ */
+#ifndef NET_SKB_PAD
+#define NET_SKB_PAD     16
+#endif
+ 
 extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);
 
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
@@ -1171,6 +1237,20 @@
 	skb->nf_debug = 0;
 #endif
 }
+
+#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+static inline void nf_bridge_put(struct nf_bridge_info *nf_bridge)
+{
+	if (nf_bridge && atomic_dec_and_test(&nf_bridge->use))
+		kfree(nf_bridge);
+}
+static inline void nf_bridge_get(struct nf_bridge_info *nf_bridge)
+{
+	if (nf_bridge)
+		atomic_inc(&nf_bridge->use);
+}
+#endif
+
 #else /* CONFIG_NETFILTER */
 static inline void nf_reset(struct sk_buff *skb) {}
 #endif /* CONFIG_NETFILTER */
diff -urN linux-2.4.30.old/include/linux/smb_mount.h linux-2.4.30.dev/include/linux/smb_mount.h
--- linux-2.4.30.old/include/linux/smb_mount.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/linux/smb_mount.h	2008-05-11 02:17:53.000000000 +0200
@@ -37,6 +37,10 @@
 #define SMB_MOUNT_OLDATTR	0x0002	/* Use core getattr (Win 95 speedup) */
 #define SMB_MOUNT_DIRATTR	0x0004	/* Use find_first for getattr */
 #define SMB_MOUNT_CASE		0x0008	/* Be case sensitive */
+#define SMB_MOUNT_UID		0x0020  /* Use user specified uid */
+#define SMB_MOUNT_GID		0x0040  /* Use user specified gid */
+#define SMB_MOUNT_FMODE		0x0080  /* Use user specified file mode */
+#define SMB_MOUNT_DMODE		0x0100  /* Use user specified dir mode */
 
 
 struct smb_mount_data_kernel {
diff -urN linux-2.4.30.old/include/linux/squashfs_fs.h linux-2.4.30.dev/include/linux/squashfs_fs.h
--- linux-2.4.30.old/include/linux/squashfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/squashfs_fs.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,512 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#define SQUASHFS_MAJOR			2
+#define SQUASHFS_MINOR			1
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		65536
+#define SQUASHFS_FILE_LOG		16
+
+#define SQUASHFS_FILE_MAX_SIZE		65536
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) 0xffffffff)
+#define SQUASHFS_USED_BLK		((long long) 0xfffffffe)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOI)
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOD)
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOF)
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, SQUASHFS_NO_FRAG)
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_ALWAYS_FRAG)
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, SQUASHFS_DUPLICATE)
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, SQUASHFS_CHECK)
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, duplicate_checking)	(noi | (nod << 1) | (check_data << 2) | (nof << 3) | (no_frag << 4) | (always_frag << 5) | (duplicate_checking << 6))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+					(B) & ~SQUASHFS_COMPRESSED_BIT : SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK) ? \
+					(B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)		(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an uncompressed
+ * offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode)(((squashfs_inode) (A) << 16)\
+					+ (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + ((b) >> 2) + 1))
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+typedef unsigned int			squashfs_fragment_index;
+#define SQUASHFS_FRAGMENT_BYTES(A)	(A * sizeof(squashfs_fragment_entry))
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + SQUASHFS_METADATA_SIZE - 1) / SQUASHFS_METADATA_SIZE)
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) * sizeof(squashfs_fragment_index))
+#define SQUASHFS_CACHED_FRAGMENTS	3
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	32
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << (SQUASHFS_MAX_FILE_SIZE_LOG - 1))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef unsigned int		squashfs_block;
+typedef long long		squashfs_inode;
+
+typedef unsigned int		squashfs_uid;
+
+typedef struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used;
+	unsigned int		uid_start;
+	unsigned int		guid_start;
+	unsigned int		inode_table_start;
+	unsigned int		directory_table_start;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode		root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start;
+} __attribute__ ((packed)) squashfs_super_block;
+
+typedef struct {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed)) squashfs_dir_index;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed)) squashfs_base_inode_header;
+
+typedef squashfs_base_inode_header squashfs_ipc_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed)) squashfs_dev_inode_header;
+	
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed)) squashfs_symlink_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	squashfs_block		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned short		block_list[0];
+} __attribute__ ((packed)) squashfs_reg_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed)) squashfs_dir_inode_header;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	squashfs_dir_index	index[0];
+} __attribute__  ((packed)) squashfs_ldir_inode_header;
+
+typedef union {
+	squashfs_base_inode_header	base;
+	squashfs_dev_inode_header	dev;
+	squashfs_symlink_inode_header	symlink;
+	squashfs_reg_inode_header	reg;
+	squashfs_dir_inode_header	dir;
+	squashfs_ldir_inode_header	ldir;
+	squashfs_ipc_inode_header	ipc;
+} squashfs_inode_header;
+	
+typedef struct {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed)) squashfs_dir_entry;
+
+typedef struct {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed)) squashfs_dir_header;
+
+typedef struct {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed)) squashfs_fragment_entry;
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem on a
+ * machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 472, 32);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ipc_inode_header))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dev_inode_header));\
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, SQUASHFS_MAX_FILE_SIZE_LOG);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_MEMSET(s, d, sizeof(squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+#ifdef SQUASHFS_1_0_COMPATIBILITY
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed)) squashfs_base_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed)) squashfs_ipc_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed)) squashfs_dev_inode_header_1;
+	
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed)) squashfs_symlink_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	squashfs_block		start_block;
+	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned short		block_list[0];
+} __attribute__ ((packed)) squashfs_reg_inode_header_1;
+
+typedef struct {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed)) squashfs_dir_inode_header_1;
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, SQUASHFS_MAX_FILE_SIZE_LOG);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+#endif
+
+#ifdef __KERNEL__
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing architectures
+ */
+#include <asm/byteorder.h>
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	int bits;\
+	int b_pos = pos % 8;\
+	unsigned long long val = 0;\
+	unsigned char *s = (unsigned char *)p + (pos / 8);\
+	unsigned char *d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+#endif
+#endif
diff -urN linux-2.4.30.old/include/linux/squashfs_fs_i.h linux-2.4.30.dev/include/linux/squashfs_fs_i.h
--- linux-2.4.30.old/include/linux/squashfs_fs_i.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/squashfs_fs_i.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+typedef struct squashfs_inode_info {
+	unsigned int	start_block;
+	unsigned int	block_list_start;
+	unsigned int	offset;
+	union {
+		struct {
+			unsigned int	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+		} s1;
+		struct {
+			unsigned int	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+		} s2;
+	} u;
+	} squashfs_inode_info;
+#endif
diff -urN linux-2.4.30.old/include/linux/squashfs_fs_sb.h linux-2.4.30.dev/include/linux/squashfs_fs_sb.h
--- linux-2.4.30.old/include/linux/squashfs_fs_sb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/include/linux/squashfs_fs_sb.h	2008-05-11 02:17:50.000000000 +0200
@@ -0,0 +1,65 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004 Phillip Lougher <plougher@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+typedef struct {
+	unsigned int	block;
+	int		length;
+	unsigned int	next_index;
+	char		*data;
+	} squashfs_cache;
+
+struct squashfs_fragment_cache {
+	unsigned int	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+	};
+
+typedef struct squashfs_sb_info {
+	squashfs_super_block	sBlk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	squashfs_cache		*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	squashfs_uid		*uid;
+	squashfs_uid		*guid;
+	squashfs_fragment_index		*fragment_index;
+	unsigned int		read_size;
+	char			*read_data;
+	char			*read_page;
+	struct semaphore	read_page_mutex;
+	struct semaphore	block_cache_mutex;
+	struct semaphore	fragment_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct inode		*(*iget)(struct super_block *s, squashfs_inode inode);
+	unsigned int		(*read_blocklist)(struct inode *inode, int index, int readahead_blks,
+					char *block_list, unsigned short **block_p, unsigned int *bsize);
+	} squashfs_sb_info;
+#endif
diff -urN linux-2.4.30.old/include/linux/swap.h linux-2.4.30.dev/include/linux/swap.h
--- linux-2.4.30.old/include/linux/swap.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30.dev/include/linux/swap.h	2008-05-11 02:17:50.000000000 +0200
@@ -1,6 +1,12 @@
 #ifndef _LINUX_SWAP_H
 #define _LINUX_SWAP_H
 
+#include <linux/config.h>
+
+#define MAX_SWAPFILES 32
+
+#ifdef __KERNEL__
+
 #include <linux/spinlock.h>
 #include <asm/page.h>
 
@@ -8,8 +14,6 @@
 #define SWAP_FLAG_PRIO_MASK	0x7fff
 #define SWAP_FLAG_PRIO_SHIFT	0
 
-#define MAX_SWAPFILES 32
-
 /*
  * Magic header for a swap area. The first part of the union is
  * what the swap magic looks like for the old (limited to 128MB)
@@ -39,8 +43,6 @@
 	} info;
 };
 
-#ifdef __KERNEL__
-
 /*
  * Max bad pages in the new format..
  */
diff -urN linux-2.4.30.old/include/linux/sysctl.h linux-2.4.30.dev/include/linux/sysctl.h
--- linux-2.4.30.old/include/linux/sysctl.h	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/include/linux/sysctl.h	2008-05-11 02:17:53.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/list.h>
 
 struct file;
+struct completion;
 
 #define CTL_MAXNAME 10
 
@@ -158,6 +159,7 @@
 	VM_LAPTOP_MODE=21,	/* kernel in laptop flush mode */
 	VM_BLOCK_DUMP=22,	/* dump fs activity to log */
 	VM_ANON_LRU=23,		/* immediatly insert anon pages in the vm page lru */
+	VM_MMAP_MIN_ADDR=24,	/* prevent mapping of low addresses by mmap() */
 };
 
 
@@ -609,6 +611,15 @@
 	NET_DECNET_CONF_DEV_STATE = 7
 };
 
+/* /proc/sys/net/bridge */
+enum {
+	NET_BRIDGE_NF_CALL_ARPTABLES = 1,
+	NET_BRIDGE_NF_CALL_IPTABLES = 2,
+	NET_BRIDGE_NF_CALL_IP6TABLES = 3,
+	NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
+};
+
+
 /* CTL_PROC names: */
 
 /* CTL_FS names: */
@@ -829,6 +840,8 @@
 {
 	ctl_table *ctl_table;
 	struct list_head ctl_entry;
+	int used;
+	struct completion *unregistering;
 };
 
 struct ctl_table_header * register_sysctl_table(ctl_table * table, 
diff -urN linux-2.4.30.old/include/linux/ufs_fs.h linux-2.4.30.dev/include/linux/ufs_fs.h
--- linux-2.4.30.old/include/linux/ufs_fs.h	2001-11-22 20:46:18.000000000 +0100
+++ linux-2.4.30.dev/include/linux/ufs_fs.h	2008-05-11 02:17:53.000000000 +0200
@@ -555,7 +555,6 @@
 extern struct file_operations ufs_dir_operations;
         
 /* super.c */
-extern struct file_system_type ufs_fs_type;
 extern void ufs_warning (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
 extern void ufs_error (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
 extern void ufs_panic (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
diff -urN linux-2.4.30.old/include/linux/usbdevice_fs.h linux-2.4.30.dev/include/linux/usbdevice_fs.h
--- linux-2.4.30.old/include/linux/usbdevice_fs.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/include/linux/usbdevice_fs.h	2008-05-11 02:17:52.000000000 +0200
@@ -185,8 +185,6 @@
 extern struct file_operations usbdevfs_devices_fops;
 extern struct file_operations usbdevfs_device_file_operations;
 extern struct inode_operations usbdevfs_device_inode_operations;
-extern struct inode_operations usbdevfs_bus_inode_operations;
-extern struct file_operations usbdevfs_bus_file_operations;
 extern void usbdevfs_conn_disc_event(void);
 
 #endif /* __KERNEL__ */
diff -urN linux-2.4.30.old/include/linux/usb.h linux-2.4.30.dev/include/linux/usb.h
--- linux-2.4.30.old/include/linux/usb.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/linux/usb.h	2008-05-11 02:17:53.000000000 +0200
@@ -252,14 +252,14 @@
 
 /* Endpoint descriptor */
 struct usb_endpoint_descriptor {
-	__u8  bLength		__attribute__ ((packed));
-	__u8  bDescriptorType	__attribute__ ((packed));
-	__u8  bEndpointAddress	__attribute__ ((packed));
-	__u8  bmAttributes	__attribute__ ((packed));
-	__u16 wMaxPacketSize	__attribute__ ((packed));
-	__u8  bInterval		__attribute__ ((packed));
-	__u8  bRefresh		__attribute__ ((packed));
-	__u8  bSynchAddress	__attribute__ ((packed));
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bEndpointAddress;
+	__u8  bmAttributes;
+	__u16 wMaxPacketSize;
+	__u8  bInterval;
+	__u8  bRefresh;
+	__u8  bSynchAddress;
 
    	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
@@ -267,15 +267,15 @@
 
 /* Interface descriptor */
 struct usb_interface_descriptor {
-	__u8  bLength		__attribute__ ((packed));
-	__u8  bDescriptorType	__attribute__ ((packed));
-	__u8  bInterfaceNumber	__attribute__ ((packed));
-	__u8  bAlternateSetting	__attribute__ ((packed));
-	__u8  bNumEndpoints	__attribute__ ((packed));
-	__u8  bInterfaceClass	__attribute__ ((packed));
-	__u8  bInterfaceSubClass __attribute__ ((packed));
-	__u8  bInterfaceProtocol __attribute__ ((packed));
-	__u8  iInterface	__attribute__ ((packed));
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bInterfaceNumber;
+	__u8  bAlternateSetting;
+	__u8  bNumEndpoints;
+	__u8  bInterfaceClass;
+	__u8  bInterfaceSubClass;
+	__u8  bInterfaceProtocol;
+	__u8  iInterface;
 
   	struct usb_endpoint_descriptor *endpoint;
 
@@ -296,14 +296,14 @@
 
 /* Configuration descriptor information.. */
 struct usb_config_descriptor {
-	__u8  bLength		__attribute__ ((packed));
-	__u8  bDescriptorType	__attribute__ ((packed));
-	__u16 wTotalLength	__attribute__ ((packed));
-	__u8  bNumInterfaces	__attribute__ ((packed));
-	__u8  bConfigurationValue __attribute__ ((packed));
-	__u8  iConfiguration	__attribute__ ((packed));
-	__u8  bmAttributes	__attribute__ ((packed));
-	__u8  MaxPower		__attribute__ ((packed));
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u16 wTotalLength;
+	__u8  bNumInterfaces;
+	__u8  bConfigurationValue;
+	__u8  iConfiguration;
+	__u8  bmAttributes;
+	__u8  MaxPower;
 
 	struct usb_interface *interface;
 
@@ -483,6 +483,8 @@
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
 					/* ... less overhead for QUEUE_BULK */
 #define USB_TIMEOUT_KILLED	0x1000	// only set by HCD!
+#define URB_NO_TRANSFER_DMA_MAP	0x0400	/* urb->transfer_dma valid on submit */
+#define URB_NO_SETUP_DMA_MAP	0x0800	/* urb->setup_dma valid on submit */
 
 struct iso_packet_descriptor
 {
@@ -828,8 +830,19 @@
 
 	atomic_t refcnt;		/* Reference count */
 	struct semaphore serialize;
-	struct semaphore exclusive_access; /* prevent driver & proc accesses  */
-					   /* from overlapping cmds at device */
+
+	/*
+	 * This is our custom open-coded lock, similar to r/w locks in concept.
+	 * It prevents drivers and /proc access from simultaneous access.
+	 * Type:
+	 *   0 - unlocked
+	 *   1 - locked for reads
+	 *   2 - locked for writes
+	 *   3 - locked for everything
+	 */
+	wait_queue_head_t excl_wait;
+	spinlock_t excl_lock;
+	unsigned excl_type;
 
 	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
 	unsigned int halted[2];		/* endpoint halts; one bit per endpoint # & direction; */
@@ -904,6 +917,8 @@
 
 int usb_get_current_frame_number (struct usb_device *usb_dev);
 
+int usb_excl_lock(struct usb_device *dev, unsigned int type, int interruptible);
+void usb_excl_unlock(struct usb_device *dev, unsigned int type);
 
 /**
  * usb_make_path - returns stable device path in the usb tree
diff -urN linux-2.4.30.old/include/linux/videodev.h linux-2.4.30.dev/include/linux/videodev.h
--- linux-2.4.30.old/include/linux/videodev.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/include/linux/videodev.h	2008-05-11 02:17:53.000000000 +0200
@@ -421,7 +421,7 @@
 #define VID_HARDWARE_VICAM      34
 #define VID_HARDWARE_SF16FMR2	35
 #define VID_HARDWARE_W9968CF	36
-#define VID_HARDWARE_SAA7114H	36
+#define VID_HARDWARE_SAA7114H	37
 
 #endif /* __LINUX_VIDEODEV_H */
 
diff -urN linux-2.4.30.old/include/linux/wanpipe.h linux-2.4.30.dev/include/linux/wanpipe.h
--- linux-2.4.30.old/include/linux/wanpipe.h	2001-08-15 10:22:17.000000000 +0200
+++ linux-2.4.30.dev/include/linux/wanpipe.h	2008-05-11 02:17:53.000000000 +0200
@@ -227,13 +227,13 @@
 
 
 typedef struct {
-	unsigned char	ver_inet_hdr_length	PACKED;
-	unsigned char	service_type		PACKED;
+	unsigned char	ver_inet_hdr_length;
+	unsigned char	service_type;
 	unsigned short	total_length		PACKED;
 	unsigned short	identifier		PACKED;
 	unsigned short	flags_frag_offset	PACKED;
-	unsigned char	ttl			PACKED;
-	unsigned char	protocol		PACKED;
+	unsigned char	ttl;
+	unsigned char	protocol;
 	unsigned short	hdr_checksum		PACKED;
 	unsigned long	ip_src_address		PACKED;
 	unsigned long	ip_dst_address		PACKED;
@@ -241,10 +241,10 @@
 
 
 typedef struct {
-        unsigned char           signature[8]    PACKED;
-        unsigned char           request_reply   PACKED;
-        unsigned char           id              PACKED;
-        unsigned char           reserved[6]     PACKED;
+        unsigned char           signature[8];
+        unsigned char           request_reply;
+        unsigned char           id;
+        unsigned char           reserved[6];
 } wp_mgmt_t;
 
 /*************************************************************************
diff -urN linux-2.4.30.old/include/linux/zlib.h linux-2.4.30.dev/include/linux/zlib.h
--- linux-2.4.30.old/include/linux/zlib.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30.dev/include/linux/zlib.h	2008-05-11 02:17:53.000000000 +0200
@@ -516,6 +516,11 @@
    stream state was inconsistent (such as zalloc or state being NULL).
 */
 
+static inline unsigned long deflateBound(unsigned long s)
+{
+	return s + ((s + 7) >> 3) + ((s + 63) >> 6) + 11;
+}
+
 ZEXTERN int ZEXPORT zlib_deflateParams OF((z_streamp strm,
 					      int level,
 					      int strategy));
diff -urN linux-2.4.30.old/include/net/ax25.h linux-2.4.30.dev/include/net/ax25.h
--- linux-2.4.30.old/include/net/ax25.h	2001-11-22 20:47:11.000000000 +0100
+++ linux-2.4.30.dev/include/net/ax25.h	2008-05-11 02:17:53.000000000 +0200
@@ -142,7 +142,7 @@
 	ax25_address		calls[AX25_MAX_DIGIS];
 	unsigned char		repeated[AX25_MAX_DIGIS];
 	unsigned char		ndigi;
-	char			lastrepeat;
+	signed char		lastrepeat;
 } ax25_digi;
 
 typedef struct ax25_route {
diff -urN linux-2.4.30.old/include/net/dn_dev.h linux-2.4.30.dev/include/net/dn_dev.h
--- linux-2.4.30.old/include/net/dn_dev.h	2000-01-09 06:36:20.000000000 +0100
+++ linux-2.4.30.dev/include/net/dn_dev.h	2008-05-11 02:17:53.000000000 +0200
@@ -99,56 +99,56 @@
 
 struct dn_short_packet
 {
-	unsigned char   msgflg          __attribute__((packed));
+	unsigned char   msgflg;
         unsigned short  dstnode         __attribute__((packed));
         unsigned short  srcnode         __attribute__((packed));
-        unsigned char   forward         __attribute__((packed));
+        unsigned char   forward;
 };
 
 struct dn_long_packet
 {
-	unsigned char   msgflg          __attribute__((packed));
-        unsigned char   d_area          __attribute__((packed));
-        unsigned char   d_subarea       __attribute__((packed));
-        unsigned char   d_id[6]         __attribute__((packed));
-        unsigned char   s_area          __attribute__((packed));
-        unsigned char   s_subarea       __attribute__((packed));
-        unsigned char   s_id[6]         __attribute__((packed));
-        unsigned char   nl2             __attribute__((packed));
-        unsigned char   visit_ct        __attribute__((packed));
-        unsigned char   s_class         __attribute__((packed));
-        unsigned char   pt              __attribute__((packed));
+	unsigned char   msgflg;
+        unsigned char   d_area;
+        unsigned char   d_subarea;
+        unsigned char   d_id[6];
+        unsigned char   s_area;
+        unsigned char   s_subarea;
+        unsigned char   s_id[6];
+        unsigned char   nl2;
+        unsigned char   visit_ct;
+        unsigned char   s_class;
+        unsigned char   pt;
 };
 
 /*------------------------- DRP - Routing messages ---------------------*/
 
 struct endnode_hello_message
 {
-	unsigned char   msgflg          __attribute__((packed));
-        unsigned char   tiver[3]        __attribute__((packed));
-        unsigned char   id[6]           __attribute__((packed));
-        unsigned char   iinfo           __attribute__((packed));
+	unsigned char   msgflg;
+        unsigned char   tiver[3];
+        unsigned char   id[6];
+        unsigned char   iinfo;
         unsigned short  blksize         __attribute__((packed));
-        unsigned char   area            __attribute__((packed));
-        unsigned char   seed[8]         __attribute__((packed));
-        unsigned char   neighbor[6]     __attribute__((packed));
+        unsigned char   area;
+        unsigned char   seed[8];
+        unsigned char   neighbor[6];
         unsigned short  timer           __attribute__((packed));
-        unsigned char   mpd             __attribute__((packed));
-        unsigned char   datalen         __attribute__((packed));
-        unsigned char   data[2]         __attribute__((packed));
+        unsigned char   mpd;
+        unsigned char   datalen;
+        unsigned char   data[2];
 };
 
 struct rtnode_hello_message
 {
-	unsigned char   msgflg          __attribute__((packed));
-        unsigned char   tiver[3]        __attribute__((packed));
-        unsigned char   id[6]           __attribute__((packed));
-        unsigned char   iinfo           __attribute__((packed));
+	unsigned char   msgflg;
+        unsigned char   tiver[3];
+        unsigned char   id[6];
+        unsigned char   iinfo;
         unsigned short  blksize         __attribute__((packed));
-        unsigned char   priority        __attribute__((packed));
-        unsigned char   area            __attribute__((packed));
+        unsigned char   priority;
+        unsigned char   area;
         unsigned short  timer           __attribute__((packed));
-        unsigned char   mpd             __attribute__((packed));
+        unsigned char   mpd;
 };
 
 
diff -urN linux-2.4.30.old/include/net/dn_nsp.h linux-2.4.30.dev/include/net/dn_nsp.h
--- linux-2.4.30.old/include/net/dn_nsp.h	2001-01-22 22:32:10.000000000 +0100
+++ linux-2.4.30.dev/include/net/dn_nsp.h	2008-05-11 02:17:53.000000000 +0200
@@ -72,9 +72,9 @@
 
 struct nsp_data_seg_msg
 {
-	unsigned char   msgflg          __attribute__((packed));
-	unsigned short  dstaddr         __attribute__((packed));
-	unsigned short  srcaddr         __attribute__((packed));
+	unsigned char   msgflg;
+	unsigned short  dstaddr;
+	unsigned short  srcaddr;
 };
 
 struct nsp_data_opt_msg
@@ -94,7 +94,7 @@
 /* Acknowledgment Message (data/other data)                             */
 struct nsp_data_ack_msg
 {
-	unsigned char   msgflg          __attribute__((packed));
+	unsigned char   msgflg;
 	unsigned short  dstaddr         __attribute__((packed));
 	unsigned short  srcaddr         __attribute__((packed));
 	unsigned short  acknum          __attribute__((packed));
@@ -103,7 +103,7 @@
 /* Connect Acknowledgment Message */
 struct  nsp_conn_ack_msg
 {
-	unsigned char   msgflg          __attribute__((packed));
+	unsigned char   msgflg;
 	unsigned short  dstaddr         __attribute__((packed));
 };
 
@@ -111,24 +111,24 @@
 /* Connect Initiate/Retransmit Initiate/Connect Confirm */
 struct  nsp_conn_init_msg
 {
-	unsigned char   msgflg          __attribute__((packed));
+	unsigned char   msgflg;
 #define NSP_CI      0x18            /* Connect Initiate     */
 #define NSP_RCI     0x68            /* Retrans. Conn Init   */
 	unsigned short  dstaddr         __attribute__((packed));
         unsigned short  srcaddr         __attribute__((packed));
-        unsigned char   services        __attribute__((packed));
+        unsigned char   services;
 #define NSP_FC_NONE   0x00            /* Flow Control None    */
 #define NSP_FC_SRC    0x04            /* Seg Req. Count       */
 #define NSP_FC_SCMC   0x08            /* Sess. Control Mess   */
 #define NSP_FC_MASK   0x0c            /* FC type mask         */
-	unsigned char   info            __attribute__((packed));
+	unsigned char   info;
         unsigned short  segsize         __attribute__((packed));
 };
 
 /* Disconnect Initiate/Disconnect Confirm */
 struct  nsp_disconn_init_msg
 {
-	unsigned char   msgflg          __attribute__((packed));
+	unsigned char   msgflg;
         unsigned short  dstaddr         __attribute__((packed));
         unsigned short  srcaddr         __attribute__((packed));
         unsigned short  reason          __attribute__((packed));
@@ -138,11 +138,11 @@
 
 struct  srcobj_fmt
 {
-	char            format          __attribute__((packed));
-        unsigned char   task            __attribute__((packed));
+	char            format;
+        unsigned char   task;
         unsigned short  grpcode         __attribute__((packed));
         unsigned short  usrcode         __attribute__((packed));
-        char            dlen            __attribute__((packed));
+        char            dlen;
 };
 
 /*
diff -urN linux-2.4.30.old/include/net/icmp.h linux-2.4.30.dev/include/net/icmp.h
--- linux-2.4.30.old/include/net/icmp.h	2001-11-22 20:47:15.000000000 +0100
+++ linux-2.4.30.dev/include/net/icmp.h	2008-05-11 02:17:52.000000000 +0200
@@ -23,6 +23,7 @@
 
 #include <net/sock.h>
 #include <net/protocol.h>
+#include <net/snmp.h>
 
 struct icmp_err {
   int		errno;
diff -urN linux-2.4.30.old/include/net/ip_vs.h linux-2.4.30.dev/include/net/ip_vs.h
--- linux-2.4.30.old/include/net/ip_vs.h	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/include/net/ip_vs.h	2008-05-11 02:17:53.000000000 +0200
@@ -82,6 +82,7 @@
 #define IP_VS_CONN_F_IN_SEQ           0x0400    /* must do input seq adjust */
 #define IP_VS_CONN_F_SEQ_MASK         0x0600    /* in/out sequence mask */
 #define IP_VS_CONN_F_NO_CPORT         0x0800    /* no client port set yet */
+#define IP_VS_CONN_F_TEMPLATE         0x1000    /* template, not connection */
 
 /* Move it to better place one day, for now keep it unique */
 #define NFC_IPVS_PROPERTY	0x10000
@@ -592,6 +593,8 @@
 
 extern struct ip_vs_conn *ip_vs_conn_in_get
 (int protocol, __u32 s_addr, __u16 s_port, __u32 d_addr, __u16 d_port);
+extern struct ip_vs_conn *ip_vs_ct_in_get
+(int protocol, __u32 s_addr, __u16 s_port, __u32 d_addr, __u16 d_port);
 extern struct ip_vs_conn *ip_vs_conn_out_get
 (int protocol, __u32 s_addr, __u16 s_port, __u32 d_addr, __u16 d_port);
 
diff -urN linux-2.4.30.old/include/net/ipv6.h linux-2.4.30.dev/include/net/ipv6.h
--- linux-2.4.30.old/include/net/ipv6.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/net/ipv6.h	2008-05-11 02:17:53.000000000 +0200
@@ -101,6 +101,7 @@
 #ifdef __KERNEL__
 
 #include <net/sock.h>
+#include <net/snmp.h>
 
 /* sysctls */
 extern int sysctl_ipv6_bindv6only;
diff -urN linux-2.4.30.old/include/net/ip6_fib.h linux-2.4.30.dev/include/net/ip6_fib.h
--- linux-2.4.30.old/include/net/ip6_fib.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/net/ip6_fib.h	2008-05-11 02:17:53.000000000 +0200
@@ -171,13 +171,16 @@
 
 extern int			fib6_add(struct fib6_node *root,
 					 struct rt6_info *rt,
-					 struct nlmsghdr *nlh);
+					 struct nlmsghdr *nlh,
+					 struct netlink_skb_parms *req);
 
 extern int			fib6_del(struct rt6_info *rt,
-					 struct nlmsghdr *nlh);
+					 struct nlmsghdr *nlh,
+					 struct netlink_skb_parms *req);
 
 extern void			inet6_rt_notify(int event, struct rt6_info *rt,
-						struct nlmsghdr *nlh);
+						struct nlmsghdr *nlh,
+						struct netlink_skb_parms *req);
 
 extern void			fib6_run_gc(unsigned long dummy);
 
diff -urN linux-2.4.30.old/include/net/ip6_route.h linux-2.4.30.dev/include/net/ip6_route.h
--- linux-2.4.30.old/include/net/ip6_route.h	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.30.dev/include/net/ip6_route.h	2008-05-11 02:17:53.000000000 +0200
@@ -39,9 +39,11 @@
 extern int			ipv6_route_ioctl(unsigned int cmd, void *arg);
 
 extern int			ip6_route_add(struct in6_rtmsg *rtmsg,
-					      struct nlmsghdr *);
+					      struct nlmsghdr *,
+					      struct netlink_skb_parms *req);
 extern int			ip6_del_rt(struct rt6_info *,
-					   struct nlmsghdr *);
+					   struct nlmsghdr *,
+					   struct netlink_skb_parms *req);
 
 extern int			ip6_rt_addr_add(struct in6_addr *addr,
 						struct net_device *dev);
diff -urN linux-2.4.30.old/include/net/irda/irlan_event.h linux-2.4.30.dev/include/net/irda/irlan_event.h
--- linux-2.4.30.old/include/net/irda/irlan_event.h	2000-12-11 22:33:09.000000000 +0100
+++ linux-2.4.30.dev/include/net/irda/irlan_event.h	2008-05-11 02:17:53.000000000 +0200
@@ -67,8 +67,6 @@
 	IRLAN_WATCHDOG_TIMEOUT,
 } IRLAN_EVENT;
 
-extern char *irlan_state[];
-
 void irlan_do_client_event(struct irlan_cb *self, IRLAN_EVENT event, 
 			   struct sk_buff *skb);
 
diff -urN linux-2.4.30.old/include/net/irda/irttp.h linux-2.4.30.dev/include/net/irda/irttp.h
--- linux-2.4.30.old/include/net/irda/irttp.h	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.30.dev/include/net/irda/irttp.h	2008-05-11 02:17:53.000000000 +0200
@@ -209,6 +209,4 @@
 	return(irlap_is_primary(self->lsap->lap->irlap));
 }
 
-extern struct irttp_cb *irttp;
-
 #endif /* IRTTP_H */
diff -urN linux-2.4.30.old/include/net/irda/qos.h linux-2.4.30.dev/include/net/irda/qos.h
--- linux-2.4.30.old/include/net/irda/qos.h	2001-11-22 20:47:11.000000000 +0100
+++ linux-2.4.30.dev/include/net/irda/qos.h	2008-05-11 02:17:53.000000000 +0200
@@ -83,7 +83,6 @@
 extern int sysctl_max_baud_rate;
 extern int sysctl_max_inactive_time;
 
-extern __u32 baud_rates[];
 extern __u32 data_sizes[];
 extern __u32 min_turn_times[];
 extern __u32 add_bofs[];
diff -urN linux-2.4.30.old/include/net/pkt_sched.h linux-2.4.30.dev/include/net/pkt_sched.h
--- linux-2.4.30.old/include/net/pkt_sched.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/net/pkt_sched.h	2008-05-11 02:17:54.000000000 +0200
@@ -5,7 +5,11 @@
 #define PSCHED_JIFFIES 		2
 #define PSCHED_CPU 		3
 
+#ifdef __mips__
+#define PSCHED_CLOCK_SOURCE	PSCHED_CPU
+#else
 #define PSCHED_CLOCK_SOURCE	PSCHED_JIFFIES
+#endif
 
 #include <linux/config.h>
 #include <linux/types.h>
@@ -59,8 +63,11 @@
 	int 			(*enqueue)(struct sk_buff *, struct Qdisc *);
 	struct sk_buff *	(*dequeue)(struct Qdisc *);
 	int 			(*requeue)(struct sk_buff *, struct Qdisc *);
-	unsigned int		(*drop)(struct Qdisc *);
-
+#ifdef CONFIG_BCM4710
+	int			(*drop)(struct Qdisc *);
+#else
+	unsigned int            (*drop)(struct Qdisc *);
+#endif
 	int			(*init)(struct Qdisc *, struct rtattr *arg);
 	void			(*reset)(struct Qdisc *);
 	void			(*destroy)(struct Qdisc *);
@@ -80,12 +87,19 @@
 #define TCQ_F_THROTTLED	2
 #define TCQ_F_INGRESS	4
 	struct Qdisc_ops	*ops;
+#ifdef CONFIG_BCM4710
+	struct Qdisc            *next;
+#endif
 	u32			handle;
-	u32			parent;
+#ifndef CONFIG_BCM4710
+	u32                     parent;
+#endif
 	atomic_t		refcnt;
 	struct sk_buff_head	q;
 	struct net_device	*dev;
-	struct list_head	list;
+#ifndef CONFIG_BCM4710
+	struct list_head        list;
+#endif
 
 	struct tc_stats		stats;
 	int			(*reshape_fail)(struct sk_buff *skb, struct Qdisc *q);
@@ -261,7 +275,7 @@
 #define PSCHED_US2JIFFIE(delay) (((delay)+psched_clock_per_hz-1)/psched_clock_per_hz)
 #define PSCHED_JIFFIE2US(delay) ((delay)*psched_clock_per_hz)
 
-#ifdef CONFIG_X86_TSC
+#if defined(CONFIG_X86_TSC) || defined(__mips__)
 
 #define PSCHED_GET_TIME(stamp) \
 ({ u64 __cur; \
diff -urN linux-2.4.30.old/include/net/sctp/sctp.h linux-2.4.30.dev/include/net/sctp/sctp.h
--- linux-2.4.30.old/include/net/sctp/sctp.h	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/include/net/sctp/sctp.h	2008-05-11 02:17:53.000000000 +0200
@@ -410,19 +410,6 @@
 	return ((head->next != head) && (head->next == head->prev));
 }
 
-/* Calculate the size (in bytes) occupied by the data of an iovec.  */
-static inline size_t get_user_iov_size(struct iovec *iov, int iovlen)
-{
-	size_t retval = 0;
-
-	for (; iovlen > 0; --iovlen) {
-		retval += iov->iov_len;
-		iov++;
-	}
-
-	return retval;
-}
-
 /* Generate a random jitter in the range of -50% ~ +50% of input RTO. */
 static inline __s32 sctp_jitter(__u32 rto)
 {
@@ -466,12 +453,12 @@
  * there is room for a param header too.
  */
 #define sctp_walk_params(pos, chunk, member)\
-_sctp_walk_params((pos), (chunk), WORD_ROUND(ntohs((chunk)->chunk_hdr.length)), member)
+_sctp_walk_params((pos), (chunk), ntohs((chunk)->chunk_hdr.length), member)
 
 #define _sctp_walk_params(pos, chunk, end, member)\
 for (pos.v = chunk->member;\
      pos.v <= (void *)chunk + end - sizeof(sctp_paramhdr_t) &&\
-     pos.v <= (void *)chunk + end - WORD_ROUND(ntohs(pos.p->length)) &&\
+     pos.v <= (void *)chunk + end - ntohs(pos.p->length) &&\
      ntohs(pos.p->length) >= sizeof(sctp_paramhdr_t);\
      pos.v += WORD_ROUND(ntohs(pos.p->length)))
 
@@ -482,7 +469,7 @@
 for (err = (sctp_errhdr_t *)((void *)chunk_hdr + \
 	    sizeof(sctp_chunkhdr_t));\
      (void *)err <= (void *)chunk_hdr + end - sizeof(sctp_errhdr_t) &&\
-     (void *)err <= (void *)chunk_hdr + end - WORD_ROUND(ntohs(err->length)) &&\
+     (void *)err <= (void *)chunk_hdr + end - ntohs(err->length) &&\
      ntohs(err->length) >= sizeof(sctp_errhdr_t); \
      err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err->length))))
 
diff -urN linux-2.4.30.old/include/net/sctp/sm.h linux-2.4.30.dev/include/net/sctp/sm.h
--- linux-2.4.30.old/include/net/sctp/sm.h	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/include/net/sctp/sm.h	2008-05-11 02:17:53.000000000 +0200
@@ -221,8 +221,7 @@
 				      const struct sctp_chunk *,
 				      __u32 tsn);
 struct sctp_chunk *sctp_make_abort_user(const struct sctp_association *,
-				   const struct sctp_chunk *,
-				   const struct msghdr *);
+					const struct msghdr *, size_t msg_len);
 struct sctp_chunk *sctp_make_abort_violation(const struct sctp_association *,
 				   const struct sctp_chunk *,
 				   const __u8 *,
diff -urN linux-2.4.30.old/include/net/sock.h linux-2.4.30.dev/include/net/sock.h
--- linux-2.4.30.old/include/net/sock.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/net/sock.h	2008-05-11 02:17:51.000000000 +0200
@@ -488,7 +488,13 @@
 	} bictcp;
 };
 
- 	
+#if 1
+#define UDP_OPT_IN_SOCK 1
+struct udp_opt {
+	__u32 esp_in_udp;
+};
+#endif
+
 /*
  * This structure really needs to be cleaned up.
  * Most of it is for TCP, and not used by any of
@@ -655,6 +661,9 @@
 #if defined(CONFIG_SPX) || defined (CONFIG_SPX_MODULE)
 		struct spx_opt		af_spx;
 #endif /* CONFIG_SPX */
+#if 1
+		struct udp_opt          af_udp;
+#endif
 
 	} tp_pinfo;
 
diff -urN linux-2.4.30.old/include/net/udp.h linux-2.4.30.dev/include/net/udp.h
--- linux-2.4.30.old/include/net/udp.h	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/include/net/udp.h	2008-05-11 02:17:53.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/udp.h>
 #include <linux/poll.h>
 #include <net/sock.h>
+#include <net/snmp.h>
 
 #define UDP_HTABLE_SIZE		128
 
diff -urN linux-2.4.30.old/include/scsi/scsi.h linux-2.4.30.dev/include/scsi/scsi.h
--- linux-2.4.30.old/include/scsi/scsi.h	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30.dev/include/scsi/scsi.h	2008-05-11 02:17:53.000000000 +0200
@@ -96,6 +96,10 @@
 /* values for service action in */
 #define SAI_READ_CAPACITY_16  0x10
 
+/* Values for T10/04-262r7 */
+#define	ATA_16		      0x85	/* 16-byte pass-thru */
+#define	ATA_12		      0xa1	/* 12-byte pass-thru */
+
 #define SCSI_RETRY_10(c) ((c) == READ_6 || (c) == WRITE_6 || (c) == SEEK_6)
 
 /*
diff -urN linux-2.4.30.old/include/video/newport.h linux-2.4.30.dev/include/video/newport.h
--- linux-2.4.30.old/include/video/newport.h	2001-04-12 21:20:31.000000000 +0200
+++ linux-2.4.30.dev/include/video/newport.h	2008-05-11 02:17:50.000000000 +0200
@@ -291,8 +291,6 @@
 	unsigned int _unused2[0x1ef];
 	struct newport_cregs cgo;
 };
-extern struct newport_regs *npregs;
-
 
 typedef struct {
 	unsigned int drawmode1;
@@ -450,38 +448,26 @@
 
 /* Miscellaneous NEWPORT routines. */
 #define BUSY_TIMEOUT 100000
-static __inline__ int newport_wait(void)
+static __inline__ int newport_wait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_GBUSY))
+	while (t--)
+		if (!(regs->cset.status & NPORT_STAT_GBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-static __inline__ int newport_bfwait(void)
+static __inline__ int newport_bfwait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_BBUSY))
+	while (t--)
+		if(!(regs->cset.status & NPORT_STAT_BBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-/* newport.c and cons_newport.c routines */
-extern struct graphics_ops *newport_probe (int, const char **);
-
-void newport_save    (void *);
-void newport_restore (void *);
-void newport_reset   (void);
-int  newport_ioctl   (int card, int cmd, unsigned long arg);
-
 /*
  * DCBMODE register defines:
  */
@@ -564,7 +550,7 @@
 {
         rex->set.dcbmode = DCB_XMAP0 | XM9_CRS_FIFO_AVAIL |
 		DCB_DATAWIDTH_1 | R_DCB_XMAP9_PROTOCOL;
-        newport_bfwait ();
+        newport_bfwait (rex);
 	
         while ((rex->set.dcbdata0.bybytes.b3 & 3) != XM9_FIFO_EMPTY)
 		;
diff -urN linux-2.4.30.old/lib/Config.in linux-2.4.30.dev/lib/Config.in
--- linux-2.4.30.old/lib/Config.in	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30.dev/lib/Config.in	2008-05-11 02:17:50.000000000 +0200
@@ -10,6 +10,7 @@
 # Do we need the compression support?
 #
 if [ "$CONFIG_CRAMFS" = "y" -o \
+     "$CONFIG_SQUASHFS" = "y" -o \
      "$CONFIG_PPP_DEFLATE" = "y" -o \
      "$CONFIG_CRYPTO_DEFLATE" = "y" -o \
      "$CONFIG_JFFS2_FS" = "y" -o \
@@ -17,6 +18,7 @@
    define_tristate CONFIG_ZLIB_INFLATE y
 else
   if [ "$CONFIG_CRAMFS" = "m" -o \
+       "$CONFIG_SQUASHFS" = "m" -o \
        "$CONFIG_PPP_DEFLATE" = "m" -o \
        "$CONFIG_CRYPTO_DEFLATE" = "m" -o \
        "$CONFIG_JFFS2_FS" = "m" -o \
diff -urN linux-2.4.30.old/Makefile linux-2.4.30.dev/Makefile
--- linux-2.4.30.old/Makefile	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30.dev/Makefile	2008-05-11 02:17:54.000000000 +0200
@@ -5,7 +5,7 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH = mips
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -17,7 +17,7 @@
 FINDHPATH	= $(HPATH)/asm $(HPATH)/linux $(HPATH)/scsi $(HPATH)/net $(HPATH)/math-emu
 
 HOSTCC  	= gcc
-HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS	= -Wall -Wstrict-prototypes -Os -fomit-frame-pointer
 
 CROSS_COMPILE 	=
 
@@ -91,13 +91,22 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
 	  -fno-strict-aliasing -fno-common
+CFLAGS += -fno-builtin-strpbrk -fno-builtin-sprintf
+
+
 ifndef CONFIG_FRAME_POINTER
 CFLAGS += -fomit-frame-pointer
 endif
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
+check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
+if_gcc4 = $(shell if echo __GNUC__ | $(CC) -E -xc - | grep -q '^4$$' > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
+ 
+# disable pointer signedness warnings in gcc 4.0
+CFLAGS += $(call check_gcc,-Wno-pointer-sign,)
+
 #
 # ROOT_DEV specifies the default root-device when making the image.
 # This can be either FLOPPY, CURRENT, /dev/xxxx or empty, in which case
@@ -354,7 +363,7 @@
 	@rm -f .ver1
 
 include/linux/version.h: ./Makefile
-	@expr length "$(KERNELRELEASE)" \<= $(uts_len) > /dev/null || \
+	@-expr length "$(KERNELRELEASE)" \<= $(uts_len) > /dev/null || \
 	  (echo KERNELRELEASE \"$(KERNELRELEASE)\" exceeds $(uts_len) characters >&2; false)
 	@echo \#define UTS_RELEASE \"$(KERNELRELEASE)\" > .ver
 	@echo \#define LINUX_VERSION_CODE `expr $(VERSION) \\* 65536 + $(PATCHLEVEL) \\* 256 + $(SUBLEVEL)` >> .ver
diff -urN linux-2.4.30.old/net/bridge/netfilter/Config.in linux-2.4.30.dev/net/bridge/netfilter/Config.in
--- linux-2.4.30.old/net/bridge/netfilter/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30.dev/net/bridge/netfilter/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# Bridge netfilter configuration
+#
+dep_tristate '  Bridge: ebtables' CONFIG_BRIDGE_NF_EBTABLES $CONFIG_BRIDGE
+dep_tristate '    ebt: filter table support' CONFIG_BRIDGE_EBT_T_FILTER $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: nat table support' CONFIG_BRIDGE_EBT_T_NAT $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: broute table support' CONFIG_BRIDGE_EBT_BROUTE $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: log support' CONFIG_BRIDGE_EBT_LOG $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: ulog support' CONFIG_BRIDGE_EBT_LOG $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: IP filter support' CONFIG_BRIDGE_EBT_IPF $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: ARP filter support' CONFIG_BRIDGE_EBT_ARPF $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: among filter support' CONFIG_BRIDGE_EBT_AMONG $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: limit filter support' CONFIG_BRIDGE_EBT_LIMIT $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: 802.1Q VLAN filter support' CONFIG_BRIDGE_EBT_VLANF $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: 802.3 filter support' CONFIG_BRIDGE_EBT_802_3 $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: packet type filter support' CONFIG_BRIDGE_EBT_PKTTYPE $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: STP filter support' CONFIG_BRIDGE_EBT_STP $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: mark filter support' CONFIG_BRIDGE_EBT_MARKF $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: arp reply target support' CONFIG_BRIDGE_EBT_ARPREPLY $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: snat target support' CONFIG_BRIDGE_EBT_SNAT $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: dnat target support' CONFIG_BRIDGE_EBT_DNAT $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: redirect target support' CONFIG_BRIDGE_EBT_REDIRECT $CONFIG_BRIDGE_NF_EBTABLES
+dep_tristate '    ebt: mark target support' CONFIG_BRIDGE_EBT_MARK_T $CONFIG_BRIDGE_NF_EBTABLES
diff -urN linux-2.4.30.old/net/Config.in linux-2.4.30.dev/net/Config.in
--- linux-2.4.30.old/net/Config.in	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/net/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -70,6 +70,9 @@
    source net/decnet/Config.in
 fi
 dep_tristate '802.1d Ethernet Bridging' CONFIG_BRIDGE $CONFIG_INET
+if [ "$CONFIG_BRIDGE" != "n" -a "$CONFIG_NETFILTER" != "n" ]; then
+   source net/bridge/netfilter/Config.in
+fi
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
    tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
@@ -104,4 +107,6 @@
 dep_tristate 'Packet Generator (USE WITH CAUTION)' CONFIG_NET_PKTGEN $CONFIG_PROC_FS
 endmenu
 
+bool 'IPSEC NAT-Traversal' CONFIG_IPSEC_NAT_TRAVERSAL
+
 endmenu
diff -urN linux-2.4.30.old/net/ipv4/netfilter/Config.in linux-2.4.30.dev/net/ipv4/netfilter/Config.in
--- linux-2.4.30.old/net/ipv4/netfilter/Config.in	2005-01-19 15:10:13.000000000 +0100
+++ linux-2.4.30.dev/net/ipv4/netfilter/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -6,10 +6,15 @@
 
 tristate 'Connection tracking (required for masq/NAT)' CONFIG_IP_NF_CONNTRACK
 if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ]; then
-  dep_tristate '  FTP protocol support' CONFIG_IP_NF_FTP $CONFIG_IP_NF_CONNTRACK
+  bool '  Connection mark tracking support' CONFIG_IP_NF_CONNTRACK_MARK
+  dep_tristate '  FTP protocol support' CONFIG_IP_NF_FTP $CONFIG_IP_NF_CONNTRACKa
   dep_tristate '  Amanda protocol support' CONFIG_IP_NF_AMANDA $CONFIG_IP_NF_CONNTRACK
   dep_tristate '  TFTP protocol support' CONFIG_IP_NF_TFTP $CONFIG_IP_NF_CONNTRACK
   dep_tristate '  IRC protocol support' CONFIG_IP_NF_IRC $CONFIG_IP_NF_CONNTRACK
+  dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
+  dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
+  dep_tristate '  H.323 (netmeeting) support' CONFIG_IP_NF_H323 $CONFIG_IP_NF_CONNTRACK
+  dep_tristate '  RTSP protocol support' CONFIG_IP_NF_RTSP $CONFIG_IP_NF_CONNTRACK
 fi
 
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
@@ -26,6 +31,7 @@
   dep_tristate '  TOS match support' CONFIG_IP_NF_MATCH_TOS $CONFIG_IP_NF_IPTABLES
   dep_tristate '  recent match support' CONFIG_IP_NF_MATCH_RECENT $CONFIG_IP_NF_IPTABLES
   dep_tristate '  ECN match support' CONFIG_IP_NF_MATCH_ECN $CONFIG_IP_NF_IPTABLES
+  dep_tristate '  peer to peer traffic match support' CONFIG_IP_NF_MATCH_IPP2P $CONFIG_IP_NF_IPTABLES
  
   dep_tristate '  DSCP match support' CONFIG_IP_NF_MATCH_DSCP $CONFIG_IP_NF_IPTABLES
  
@@ -39,10 +45,22 @@
   if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ]; then
     dep_tristate '  Connection state match support' CONFIG_IP_NF_MATCH_STATE $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES 
     dep_tristate '  Connection tracking match support' CONFIG_IP_NF_MATCH_CONNTRACK $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES 
+	if [ "$CONFIG_IP_NF_CONNTRACK_MARK" != "n" ]; then
+	  dep_tristate '  Connection mark match support' CONFIG_IP_NF_MATCH_CONNMARK $CONFIG_IP_NF_IPTABLES
+	fi
+    dep_tristate '  Connection byte counter support' CONFIG_IP_NF_MATCH_CONNBYTES $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES
   fi
   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
     dep_tristate '  Unclean match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_UNCLEAN $CONFIG_IP_NF_IPTABLES
+    dep_tristate '  String match support (EXPERIMENTAL) ' CONFIG_IP_NF_MATCH_STRING $CONFIG_IP_NF_IPTABLES
     dep_tristate '  Owner match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_OWNER $CONFIG_IP_NF_IPTABLES
+    dep_tristate '  Layer 7 match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_LAYER7 $CONFIG_IP_NF_CONNTRACK
+    dep_mbool '  Layer 7 debugging output (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_LAYER7_DEBUG $CONFIG_IP_NF_MATCH_LAYER7
+    int  '  Buffer size for application layer data (256-65536)' CONFIG_IP_NF_MATCH_LAYER7_MAXDATALEN 2048
+ 
+  fi
+  if [ "$CONFIG_BRIDGE" != "n" ]; then
+    dep_tristate '  Physdev match support' CONFIG_IP_NF_MATCH_PHYSDEV $CONFIG_IP_NF_IPTABLES
   fi
 # The targets
   dep_tristate '  Packet filtering' CONFIG_IP_NF_FILTER $CONFIG_IP_NF_IPTABLES 
@@ -50,6 +68,7 @@
     dep_tristate '    REJECT target support' CONFIG_IP_NF_TARGET_REJECT $CONFIG_IP_NF_FILTER
     if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       dep_tristate '    MIRROR target support (EXPERIMENTAL)' CONFIG_IP_NF_TARGET_MIRROR $CONFIG_IP_NF_FILTER
+      dep_tristate '    TARPIT target support (EXPERIMENTAL)' CONFIG_IP_NF_TARGET_TARPIT $CONFIG_IP_NF_FILTER
     fi
   fi
 
@@ -59,6 +78,20 @@
       define_bool CONFIG_IP_NF_NAT_NEEDED y
       dep_tristate '    MASQUERADE target support' CONFIG_IP_NF_TARGET_MASQUERADE $CONFIG_IP_NF_NAT
       dep_tristate '    REDIRECT target support' CONFIG_IP_NF_TARGET_REDIRECT $CONFIG_IP_NF_NAT
+      if [ "$CONFIG_IP_NF_PPTP" = "m" ]; then
+        define_tristate CONFIG_IP_NF_NAT_PPTP m
+      else
+        if [ "$CONFIG_IP_NF_PPTP" = "y" ]; then
+          define_tristate CONFIG_IP_NF_NAT_PPTP $CONFIG_IP_NF_NAT
+        fi
+      fi
+      if [ "$CONFIG_IP_NF_CT_PROTO_GRE" = "m" ]; then
+        define_tristate CONFIG_IP_NF_NAT_PROTO_GRE m
+      else
+        if [ "$CONFIG_IP_NF_CT_PROTO_GRE" = "y" ]; then
+          define_tristate CONFIG_IP_NF_NAT_PROTO_GRE $CONFIG_IP_NF_NAT
+        fi
+      fi
       if [ "$CONFIG_IP_NF_AMANDA" = "m" ]; then
         define_tristate CONFIG_IP_NF_NAT_AMANDA m
       else
@@ -66,6 +99,20 @@
           define_tristate CONFIG_IP_NF_NAT_AMANDA $CONFIG_IP_NF_NAT
         fi
       fi
+      if [ "$CONFIG_IP_NF_H323" = "m" ]; then
+       define_tristate CONFIG_IP_NF_NAT_H323 m
+      else
+       if [ "$CONFIG_IP_NF_H323" = "y" ]; then
+         define_tristate CONFIG_IP_NF_NAT_H323 $CONFIG_IP_NF_NAT
+       fi
+      fi
+      if [ "$CONFIG_IP_NF_RTSP" = "m" ]; then
+        define_tristate CONFIG_IP_NF_NAT_RTSP m
+      else
+       if [ "$CONFIG_IP_NF_RTSP" = "y" ]; then
+         define_tristate CONFIG_IP_NF_NAT_RTSP $CONFIG_IP_NF_NAT
+       fi
+      fi
       if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
         dep_tristate '    Basic SNMP-ALG support (EXPERIMENTAL)' CONFIG_IP_NF_NAT_SNMP_BASIC $CONFIG_IP_NF_NAT
       fi
@@ -103,8 +150,14 @@
     dep_tristate '    DSCP target support' CONFIG_IP_NF_TARGET_DSCP $CONFIG_IP_NF_MANGLE
  
     dep_tristate '    MARK target support' CONFIG_IP_NF_TARGET_MARK $CONFIG_IP_NF_MANGLE
+    dep_tristate '    CLASSIFY target support (EXPERIMENTAL)' CONFIG_IP_NF_TARGET_CLASSIFY $CONFIG_IP_NF_MANGLE
+    dep_tristate '    IMQ target support' CONFIG_IP_NF_TARGET_IMQ $CONFIG_IP_NF_MANGLE
+  fi
+  if [ "$CONFIG_IP_NF_CONNTRACK_MARK" != "n" ]; then
+    dep_tristate '  CONNMARK target support' CONFIG_IP_NF_TARGET_CONNMARK $CONFIG_IP_NF_IPTABLES
   fi
   dep_tristate '  LOG target support' CONFIG_IP_NF_TARGET_LOG $CONFIG_IP_NF_IPTABLES
+  dep_tristate '  TTL target support' CONFIG_IP_NF_TARGET_TTL $CONFIG_IP_NF_IPTABLES
   dep_tristate '  ULOG target support' CONFIG_IP_NF_TARGET_ULOG $CONFIG_IP_NF_IPTABLES
   dep_tristate '  TCPMSS target support' CONFIG_IP_NF_TARGET_TCPMSS $CONFIG_IP_NF_IPTABLES
 fi
diff -urN linux-2.4.30.old/net/ipv6/netfilter/Config.in linux-2.4.30.dev/net/ipv6/netfilter/Config.in
--- linux-2.4.30.old/net/ipv6/netfilter/Config.in	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.30.dev/net/ipv6/netfilter/Config.in	2008-05-11 02:17:52.000000000 +0200
@@ -71,6 +71,7 @@
   if [ "$CONFIG_IP6_NF_MANGLE" != "n" ]; then
 #    dep_tristate '    TOS target support' CONFIG_IP6_NF_TARGET_TOS $CONFIG_IP_NF_MANGLE
     dep_tristate '    MARK target support' CONFIG_IP6_NF_TARGET_MARK $CONFIG_IP6_NF_MANGLE
+    dep_tristate '    IMQ target support' CONFIG_IP6_NF_TARGET_IMQ $CONFIG_IP6_NF_MANGLE
   fi
   #dep_tristate '  LOG target support' CONFIG_IP6_NF_TARGET_LOG $CONFIG_IP6_NF_IPTABLES
 fi
diff -urN linux-2.4.30.old/Rules.make linux-2.4.30.dev/Rules.make
--- linux-2.4.30.old/Rules.make	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30.dev/Rules.make	2008-05-11 02:17:54.000000000 +0200
@@ -126,7 +126,7 @@
 # This make dependencies quickly
 #
 fastdep: dummy
-	$(TOPDIR)/scripts/mkdep $(CFLAGS) $(EXTRA_CFLAGS_nostdinc) -- $(wildcard *.[chS]) > .depend
+	find -name '*.[chS]' | xargs $(TOPDIR)/scripts/mkdep $(CFLAGS) $(EXTRA_CFLAGS_nostdinc) -- > .depend
 ifdef ALL_SUB_DIRS
 	$(MAKE) $(patsubst %,_sfdep_%,$(ALL_SUB_DIRS)) _FASTDEP_ALL_SUB_DIRS="$(ALL_SUB_DIRS)"
 endif
@@ -176,7 +176,14 @@
 _modinst__: dummy
 ifneq "$(strip $(ALL_MOBJS))" ""
 	mkdir -p $(MODLIB)/kernel/$(MOD_DESTDIR)
-	cp $(sort $(ALL_MOBJS)) $(MODLIB)/kernel/$(MOD_DESTDIR)
+	#@cp $(sort $(ALL_MOBJS)) $(MODLIB)/kernel/$(MOD_DESTDIR)
+	for f in $(ALL_MOBJS) ; do \
+		$(OBJCOPY) -R __ksymtab -R .comment -R .note -x \
+		`$(NM) $$f | cut -f3- -d' ' | sed -n \
+			-e 's/__module_parm_\(.*\)/-K \1/p' \
+			-e 's/__ks..tab_\(.*\)/-K \1/p'` \
+		$$f $(MODLIB)/kernel/$(MOD_DESTDIR)$(MOD_TARGET)$$f; \
+	done
 endif
 
 .PHONY: modules_install
diff -urN linux-2.4.30.old/scripts/ver_linux linux-2.4.30.dev/scripts/ver_linux
--- linux-2.4.30.old/scripts/ver_linux	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30.dev/scripts/ver_linux	2008-05-11 02:17:54.000000000 +0200
@@ -22,7 +22,8 @@
       '/GNU Make/{print "Gnu make              ",$NF}'
 
 ld -v 2>&1 | awk -F\) '{print $1}' | awk \
-      '/BFD/{print "binutils              ",$NF}'
+      '/BFD/{print "binutils              ",$NF} \
+       /^GNU/{print "binutils              ",$4}'
 
 fdformat --version | awk -F\- '{print "util-linux            ", $NF}'
 
